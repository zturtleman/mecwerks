<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0048)http://www.frag.com/tectonic/quake3/tuts/wof.htm -->
<HTML><HEAD><TITLE>Q3Coding: Creating a Baisc Mod</TITLE><!-- #BeginTemplate "/Templates/model.dwt" --><!-- #BeginEditable "titre" --><!-- #EndEditable -->
<META content="text/html; charset=iso-8859-1" http-equiv=Content-Type><LINK 
href="../main.css" rel=stylesheet>
<META content="MSHTML 5.00.2314.1000" name=GENERATOR></HEAD>
<BODY bgColor=#ffffff>
<TABLE border=0 width="75%">
  <TBODY>
  <TR align=left bgColor=#006699 vAlign=top>
    <TD><!-- #BeginEditable "matiere" -->
      <DIV align=left><B><FONT color=#ccccff face="Arial, Helvetica, sans-serif" 
      size=4>Q3 Coding</FONT></B></DIV><!-- #EndEditable --></TD></TR>
  <TR align=left bgColor=#ccccff vAlign=top>
    <TD class=titre1>
      <DIV align=left><FONT face="Tahoma, Verdana" size=2><!-- #BeginEditable "tit" --></FONT><FONT 
      face="Arial, Helvetica, sans-serif" size=2><B>Creating a Basic 
      Mod</B></FONT></DIV></TD></TR>
  <TR align=left vAlign=top>
    <TD height=465><!-- #BeginEditable "texte" -->
      <P align=right><FONT face="Tahoma, Verdana" size=2><B>Date :</B> 
      17/01/99<BR><B>Author(s) </B>: <A 
      href="mailto:wilka@frag.com">Wilka</A><BR><B>Skill(s) :</B> 
      Medium<BR><B>Source Project(s) :</B> Game<BR><B>Revision :</B> 
2</FONT></P>
      <P><FONT face="Tahoma, Verdana" size=2>This is a server side mod, so all 
      changes will be for the 'game' code. I'll use text boxes for the code, so 
      it's easy for you to copy &amp; paste them in to the q3 source. This mod 
      is based on one <A href="http://www.ritualistic.com/sincest">I wrote</A> a 
      while ago for SiN. It's not very complex, but it does cover all the 
      basic's that most mods are made of from. In this mod (Weapons of Fury, or 
      WoF for short) the aim is to get a kill with each weapon. Without dieing. 
      The server sets what weapons, in what order, are used via a 
      <I>g_wofOrder</I> cvar. By filling it with numbers that corresponded to a 
      weapon. So if the server admin wants you do get 2 rocket launcher kills 1 
      rail kill, and a BFG kill to win, he would set <I>g_wofOrder</I> to 
      "5579". Each time you die, you have to start again at the first weapon (a 
      rocket launcher in this case). Now that you know what the mod is, here's 
      how to make it.</FONT></P>
      <H4><FONT face="Arial, Helvetica, sans-serif">Creating a New 
      Cvar</FONT></H4>
      <P><FONT face="Tahoma, Verdana" size=2>The first thing we need to do is 
      create a new console variable (cvar) so the server can set the weapon 
      order. To do that, open up the file <B>g_main.c</B> and go to line 57. 
      You'll see a list of <I>vmCvar_t</I> definitions like this:</FONT></P>
      <FORM>
      <P><TEXTAREA cols=92 name=S1 rows=4>vmCvar_t  g_teamForceBalance;
vmCvar_t  g_banIPs;
vmCvar_t  g_filterBan;</TEXTAREA></P></FORM>
      <P><FONT face="Tahoma, Verdana" size=2>We'll add our new cvar to the end 
      of these, so under the last "vmCvar_t" add "vmCvar_t g_wofOrder". I'll use 
      //Wilka and //W to mark my changes to original code, so it should now look 
      like this :</FONT> 
      <FORM>
      <P><TEXTAREA cols=92 name=S1 rows=6>vmCvar_t  g_teamForceBalance;
vmCvar_t  g_banIPs;
vmCvar_t  g_filterBan;
//Wilka
vmCvar_t  g_wofOrder;
//W</TEXTAREA></P></FORM>
      <P><FONT face="Tahoma, Verdana" size=2>Now move down to line 121. This is 
      where q3 sets the default values and settings for the cvars. Go to the 
      line starts "{ &amp;g_allowVote", and add a command to the end of the 
      line. So that we can put another item in the array. Every item, apart from 
      the last one needs a comma at the end (after the close brace). Then add 
      our new cvar, so it should now look like this :</FONT> <BR>
      <FORM>
      <P><TEXTAREA cols=92 name=S1 rows=6>{ &amp;g_podiumDrop, "g_podiumDrop", "70", 0, 0, qfalse },
{ &amp;g_allowVote, "g_allowVote", "1", 0, 0, qfalse },
//Wilka
{ &amp;g_wofOrder, "g_wofOrder", "2345678", CVAR_SERVERINFO | CVAR_ARCHIVE| CVAR_LATCH, 0, qfalse }
//W</TEXTAREA></P></FORM><FONT face="Tahoma, Verdana" size=2>The line you 
      added tells q3 how you want your new cvar to be set up. Here's what each 
      thing is for:</FONT> 
      <UL>
        <LI><FONT face="Tahoma, Verdana" size=2>&amp;g_wofOrder : This is the 
        vmCvar_t that you want to to set.&nbsp;</FONT> 
        <LI><FONT face="Tahoma, Verdana" size=2>"g_wofOrder" : This is name of 
        the cvar that you use in the console. It doesn't have to be the same 
        name as your vmCvar_t variable. But it makes more sense if they 
        are.</FONT> 
        <LI><FONT face="Tahoma, Verdana" size=2>"2345678" : This is the default 
        value of the cvar - it needs be enclosed in quotes, even if it's a 
        number.</FONT> 
        <LI><FONT face="Tahoma, Verdana" size=2>CVAR_SERVERINFO | CVAR_ARCHIVE| 
        CVAR_LATCH : These are all one item (which is why there is no "," 
        between them). They each set a prosperity of the cvar. CVAR_SERVERINFO 
        tells q3 that cvar is a server info cvar, this will make it show up in 
        the rules section GameSpy, or any time the server gets queried. You only 
        use this for cvars that affect the game (i.e. fraglimit, sv_minping, 
        etc). CVAR_ARCHIVE tells Quake3 that you want this cvar to be saved to 
        q3config.cfg when Quake3 is closed. This makes any changes to to the 
        cvar permanent, because they are loaded back in when q3 starts. Lastly 
        CVAR_LATCH, means that any changes to this cvar do not take effect until 
        the game is restarted (i.e. a map change, or a map_restart). If you want 
        to use more than one option for your cvar, you need to 'or' them 
        together with | (like I have here)</FONT> 
        <LI><FONT face="Tahoma, Verdana" size=2>0 : This is the modification 
        count for the cvar, you should always start this at 0. Otherwise you 
        wont know how many times it's been changed. Although I'm not sure why 
        you'd care how many times it was changed :)</FONT> 
        <LI><FONT face="Tahoma, Verdana" size=2>qfalse : This can be qfalse or 
        qtrue. It tells q3 if you want clients to be notified when this cvar is 
        changes via a printed message.<BR></FONT></LI></UL>
      <P><FONT face="Tahoma, Verdana" size=2>Now that we've got our new cvar 
      added, we can move on to actually using it.</FONT></P>
      <H4><FONT face="Arial, Helvetica, sans-serif">Modifying The Client 
      Struct</FONT></H4>
      <P><FONT face="Tahoma, Verdana" size=2>We need some way to keep track of 
      what the clients current weapon position. The easiest way to that is to 
      simply add an 'int' to the player's struct. Go to line 284 in 
      <B>g_local.h</B>, then under "int timeResidual;" add our new variable so 
      it looks like this.</FONT> 
      <FORM>
      <P><TEXTAREA cols=92 name=S1 rows=7>// timeResidual is used to handle events that happen every second
// like health / armor countdowns and regeneration
int	timeResidual;

//Wilka
int	iCurrentWeapon; //current weapon for this client
//W
</TEXTAREA></P></FORM><FONT face="Tahoma, Verdana" size=2>This new 
      variables will used to work out what weapon the player will get when he 
      makes his next kill. Now we add a function that will move this client to 
      the next weapon, and update the <I>iCurrentWeapon</I> variable.</FONT> 
      <H4><FONT face="Arial, Helvetica, sans-serif">Adding New 
      Functions</FONT></H4>
      <P><FONT face="Tahoma, Verdana" size=2>We'll call this function 
      <I>Wof_NextWeapon</I>, and since it'll be used for the client we'll put it 
      in the <B>g_client.c</B> file. Open up <B>g_client.c</B> and scroll to the 
      end, then add the following code.</FONT></P>
      <FORM>
      <P><TEXTAREA cols=92 name=S1 rows=22>void Wof_NextWeapon(gentity_t *ent)
{
	gclient_t	*client = ent-&gt;client;
	int iWep;
	
	//move them to the next weapon
 	client-&gt;iCurrentWeapon++;

	//get the char for the next weapon
	iWep = g_wofOrder.string[client-&gt;iCurrentWeapon]; 

	//find out what weapon they need
	switch(iWep)
	{
	case '1': //gauntlet
		client-&gt;ps.stats[STAT_WEAPONS] = ( 1 &lt;&lt; WP_GAUNTLET );
		client-&gt;ps.ammo[WP_GAUNTLET] = -1;
		client-&gt;ps.weapon = WP_GAUNTLET;
		break;

	case '2': //machingun
		client-&gt;ps.stats[STAT_WEAPONS] = ( 1 &lt;&lt; WP_MACHINEGUN );
		client-&gt;ps.ammo[WP_MACHINEGUN] = 150;
		client-&gt;ps.weapon = WP_MACHINEGUN;
		break;

	case '3': //shotgun
		client-&gt;ps.stats[STAT_WEAPONS] = ( 1 &lt;&lt; WP_SHOTGUN );
		client-&gt;ps.ammo[WP_SHOTGUN] = 100;
		client-&gt;ps.weapon = WP_SHOTGUN;
		break;

	case '4': //gren
		client-&gt;ps.stats[STAT_WEAPONS] = ( 1 &lt;&lt; WP_GRENADE_LAUNCHER );
		client-&gt;ps.ammo[WP_GRENADE_LAUNCHER] = 100;
		client-&gt;ps.weapon = WP_GRENADE_LAUNCHER;
		break;

	case '5': //rocket
		client-&gt;ps.stats[STAT_WEAPONS] = ( 1 &lt;&lt; WP_ROCKET_LAUNCHER );
		client-&gt;ps.ammo[WP_ROCKET_LAUNCHER] = 100;
		client-&gt;ps.weapon = WP_ROCKET_LAUNCHER;
		break;

	case '6': //light
		client-&gt;ps.stats[STAT_WEAPONS] = ( 1 &lt;&lt; WP_LIGHTNING );
		client-&gt;ps.ammo[WP_LIGHTNING] = 300;
		client-&gt;ps.weapon = WP_LIGHTNING;
		break;

	case '7': //rail
		client-&gt;ps.stats[STAT_WEAPONS] = ( 1 &lt;&lt; WP_RAILGUN );
		client-&gt;ps.ammo[WP_RAILGUN] = 100;
		client-&gt;ps.weapon = WP_RAILGUN;
		break;

	case '8': //plasma
		client-&gt;ps.stats[STAT_WEAPONS] = ( 1 &lt;&lt; WP_PLASMAGUN );
		client-&gt;ps.ammo[WP_PLASMAGUN] = 300;
		client-&gt;ps.weapon = WP_PLASMAGUN;
		break;

	case '9': //bfg
		client-&gt;ps.stats[STAT_WEAPONS] = ( 1 &lt;&lt; WP_BFG );
		client-&gt;ps.ammo[WP_BFG] = 150;
		client-&gt;ps.weapon = WP_BFG;
		break;
	}
	
	//make the weapon ready
	client-&gt;ps.weaponstate = WEAPON_READY;
	
	//give them some feedback so the notice they have changed weapons
	G_Sound( ent, CHAN_AUTO, G_SoundIndex("sound/weapons/change.wav"));
}</TEXTAREA></P></FORM>
      <P><FONT face="Tahoma, Verdana" size=2>That handles giving them the next 
      weapon. The way this works is the first time a client spawns, their 
      current weapon gets set to -1. Then when <I>Wof_NextWeapon</I> is called, 
      their current weapon variables gets increased by 1 (so it's now 0), and 
      <I>iWep</I> stores the number at position 0 in the <I>g_wofOrder</I> 
      string. So that's the first character. We then check what weapon they need 
      in the <I>switch</I> block. We then set the <I>STAT_WEAPONS</I> item in 
      <I>ps.stats</I> array to whatever weapon they should have (this gets rid 
      of any weapons they had before). Give them some ammo for the weapon, and 
      set their current weapon (so it forces them to switch from the old weapon) 
      with the line "client-&gt;ps.weapon = WP_&lt;weapon&gt;".</FONT></P>
      <P><FONT face="Tahoma, Verdana" size=2>When we exit the switch, we force 
      the weapon state to ready and play a sound so the client releases they 
      have change weapons (the change is instant, so they could miss 
      it).</FONT></P>
      <P><FONT face="Tahoma, Verdana" size=2>The only problem with this is that 
      they're is no way for the player to win. So we need to add a default case 
      to our switch block. The default case will be used when none of the other 
      case's apply. All string's need to end in a 0, and since we are only 
      checking for char's that are numbers (i.e. a char '0' is not the same as 
      an int 0), when we reach the end of the string (or anything that's not a 
      number we are looking for), the default case is used. So go back to your 
      <I>Wof_NextWeapon</I> function, and add this to the end of the switch 
      (after the BFG case).</FONT></P>
      <FORM>
      <P><TEXTAREA cols=92 name=S1 rows=16>case '9': //bfg
	client-&gt;ps.stats[STAT_WEAPONS] = ( 1 &lt;&lt; WP_BFG );
	client-&gt;ps.ammo[WP_BFG] = 150;
	client-&gt;ps.weapon = WP_BFG;
	break;
		
default: //not a number, so this player wins
	//let eveyone know this player has won
	trap_SendServerCommand( -1, va("print \"%s" S_COLOR_WHITE " wins.\n\"",client-&gt;pers.netname ) );
	
	//give them some feedback
	G_Sound( ent, CHAN_AUTO, G_SoundIndex("sound/feedback/excellent.wav"));

	//end the game, and let all the players know who won
	LogExit( va("print \"%s wins.\n\"",client-&gt;pers.netname ));
	return;
}</TEXTAREA></P></FORM>
      <P><FONT face="Tahoma, Verdana" size=2>Now we need let this function know 
      that <I>LogExit</I> and out new cvar exist otherwise we'll get an error 
      when we try and compile the mod. So scroll up to the top of the file, and 
      change it so it looks like this.</FONT></P>
      <FORM>
      <P><TEXTAREA cols=92 name=S1 rows=7>// Copyright (C) 1999-2000 Id Software, Inc.
//
#include "g_local.h"
//Wilka
void LogExit( const char *string );
extern vmCvar_t	 g_wofOrder;
//W</TEXTAREA></P></FORM>
      <P>t<FONT face="Tahoma, Verdana" size=2>he extern keyword tells the 
      compiler that this variable is declared in another (external) file. If we 
      didn't use extern we would get an error because we'd be trying to declare 
      the same thing twice. All that's left for us to do now is tie it all 
      together so our mod works the way we want it to.</FONT></P>
      <H4><FONT face="Arial, Helvetica, sans-serif">Joining The 
      Pieces</FONT></H4>
      <P><FONT face="Tahoma, Verdana" size=2>We need to make sure that the 
      client's current weapon stars at -1 when they spawn. Otherwise when they 
      die they wont start back at the first weapon. Then we need to call 
      <I>Wof_NextWeapon</I> so the move on to the first weapon. Do that&nbsp; to 
      line 996 in <B>g_client.c</B> (the <I>ClientSpawn</I> function), and just 
      after <I>G_UseTargets</I> is called add this code.</FONT></P>
      <FORM>
      <P><TEXTAREA cols=92 name=S1 rows=10>	} else {
		// fire the targets of the spawn point
		G_UseTargets( spawnPoint, ent );
		
		//Wilka
		//start them at wep -1
		ent-&gt;client-&gt;iCurrentWeapon = -1;

		//them move to the next weapon
		Wof_NextWeapon(ent);
		//W</TEXTAREA></P></FORM>
      <P><FONT face="Tahoma, Verdana" size=2>We need to put it after 
      <I>G_UseTargets</I> so that any target_give entities on the map don't give 
      the client weapons they shouldn't have. Now need to make the client move 
      to the next weapon when they get a kill. So open up the <B>g_combat.c</B> 
      file and go to line 240 (the <I>player_die</I> function). Then on the line 
      before <I>AddScore</I> we need to move the attacker to his next weapon. So 
      change the code to look like this.</FONT></P>
      <FORM>
      <P><TEXTAREA cols=92 name=S1 rows=6>		} else {
			//Wilka
			//move them up a weapon
			Wof_NextWeapon(attacker);
			//W
			AddScore( attacker, 1 );</TEXTAREA></P></FORM>
      <P><FONT face="Tahoma, Verdana" size=2>Now we need to make sure that 
      <I>player_die</I> and <I>ClientBegin </I>know about our 
      <I>Wof_NextWeapon</I> function. So open <B>g_local.h </B>and go to the end 
      of the file. Then add the following code.</FONT></P>
      <FORM>
      <P><TEXTAREA cols=92 name=S1 rows=4>//Wilka
void Wof_NextWeapon(gentity_t *ent);
//W</TEXTAREA></P></FORM>
      <P><FONT face="Tahoma, Verdana" size=2>You could compile and play your mod 
      now, and it would work. But there is a problem with it. Players can pick 
      up another weapon and start using that. So we need to stop them being able 
      to pickup weapons. To do that we need to go the <I>Pickup_Weapon</I> 
      function in <B>g_items.c</B>. Go down to line 163 and comment out the part 
      that gives the client the weapon (we still want them to have the ammo, so 
      leave that alone). It should look like this when your done.</FONT></P>
      <FORM>
      <P><TEXTAREA cols=92 name=S1 rows=6>	// add the weapon
	//Wilka
	//other-&gt;client-&gt;ps.stats[STAT_WEAPONS] |= ( 1 &lt;&lt; ent-&gt;item-&gt;giTag );
	//W

	Add_Ammo( other, ent-&gt;item-&gt;giTag, quantity );</TEXTAREA></P></FORM>
      <P><FONT face="Tahoma, Verdana" size=2>Now when they collect a weapon, 
      they only get the ammo for it. The mod is almost complete, we just need to 
      add a way for the player to go back a weapon in case they run out of ammo 
      (they're might not be any ammo for the weapon on the map they're 
      playing).</FONT> </P>
      <P><FONT face="Tahoma, Verdana" size=2>Now when a player gets a kill, they 
      will move on to the next weapon. But if that weapon isn't already on the 
      map, the clients wont have it memory so they will need to load it. Which 
      will cause a slight 'hitch' in the game (the same thing happens when you 
      bring up the scores and you don't have the model loaded for a player that 
      has joined). While it's not a good idea to load all of the players on game 
      start because they take up a lot of ram, weapons are a lot smaller. So we 
      want to precache them&nbsp; so when a player loads the map, they load all 
      the weapons as well. To do that we'll need to edit the 
      <I>ClearRegisteredItems</I> function on line 576 of <B>g_items.c</B>. Just 
      after the default weapons are registed, we want to add all the other 
      weapons. So change the function to look like this.</FONT> </P>
      <P><TEXTAREA cols=92 name=S1 rows=15>void ClearRegisteredItems( void ) {
	memset( itemRegistered, 0, sizeof( itemRegistered ) );

	// players always start with the base weapon
	RegisterItem( BG_FindItemForWeapon( WP_MACHINEGUN ) );
	RegisterItem( BG_FindItemForWeapon( WP_GAUNTLET ) );
	//Wilka
	//precache all weapons
	RegisterItem( BG_FindItemForWeapon(WP_SHOTGUN) );
	RegisterItem( BG_FindItemForWeapon(WP_GRENADE_LAUNCHER) );
	RegisterItem( BG_FindItemForWeapon(WP_ROCKET_LAUNCHER) );
	RegisterItem( BG_FindItemForWeapon(WP_LIGHTNING) );
	RegisterItem( BG_FindItemForWeapon(WP_RAILGUN) );
	RegisterItem( BG_FindItemForWeapon(WP_PLASMAGUN) );
	RegisterItem( BG_FindItemForWeapon(WP_BFG) );
	RegisterItem( BG_FindItemForWeapon(WP_GRAPPLING_HOOK) );
	//W
}</TEXTAREA> </P>
      <P><FONT face="Tahoma, Verdana" size=2>It would have been better if we 
      only loaded the weapons that we needed (we can find out by looking at 
      g_wofOrder), but you should be able to work out how to that for 
      yourself.</FONT> </P>
      <H4><FONT face="Arial, Helvetica, sans-serif">Adding A New 
      Command</FONT></H4>
      <P><FONT face="Tahoma, Verdana" size=2>It's pretty easy to add a new 
      command. What you need to do is go to ClientCommand in g_cmds.c, then on 
      line 1094 add your new command like this.</FONT></P>
      <FORM>
      <P><TEXTAREA cols=92 name=S1 rows=7>	else if (Q_stricmp (cmd, "setviewpos") == 0)
		Cmd_SetViewpos_f( ent );
	//Wilka
	else if (Q_stricmp (cmd, "wof_backWeapon") == 0)
	{
		//dont let them go back passed weapon 0
		if(ent-&gt;client-&gt;iCurrentWeapon &gt; 0)
			ent-&gt;client-&gt;iCurrentWeapon-=2; 
		else
			ent-&gt;client-&gt;iCurrentWeapon=-1;

		//move them to the next weapon
		WofNextWeapon(ent);
	}
	//W
	else
		trap_SendServerCommand( clientNum, va("print \"unknown cmd %s\n\"", cmd ) );</TEXTAREA></P></FORM>
      <P><FONT face="Tahoma, Verdana" size=2>Now when the client use the 
      "wof_backWeapon" command, they will be moved back 1 weapon. We need to 
      subtract 2 from <I>iCurrentWeapon</I>, so that their current weapon gets 
      set to the one before the previous weapon. Then when <I>Wof_NextWeapon</I> 
      adds one to <I>iCurrentWeapon</I>, they will be set to the previous 
      weapon.</FONT></P>
      <H4><FONT face="Arial, Helvetica, sans-serif">Printing 
Messages</FONT></H4>
      <P><FONT face="Tahoma, Verdana" size=2>It would be nice to let the client 
      know this server is a non-standard dm server when the join, so they don't 
      get confused about not being able to pickup weapons. While we're at it we 
      should let them know what <I>g_wofOrder</I> is when they join. To do that 
      we'll need to edit the <I>ClientBegin</I> function. Go to line 814 in 
      <B>g_client.c</B>, we need to add out print messages after "&lt;Player&gt; 
      has joined the game." gets printed. So change it to look like 
      this.</FONT></P>
      <FORM>
      <P><TEXTAREA cols=92 name=S1 rows=12>if ( g_gametype.integer != GT_TOURNAMENT ) {
	trap_SendServerCommand( -1, va("print \"%s" S_COLOR_WHITE " entered the game\n\"", client-&gt;pers.netname) );
	//Wilka
	//tell them what the weapon order is
	trap_SendServerCommand( ent-g_entities, va("print \"wof_order is %s\n\"", g_wofOrder.string));
		
	//let them know this is a WoF server (use center print so they notice it)
	trap_SendServerCommand( ent-g_entities, va("cp \"This Server is Running WoF\""));
	//W
}</TEXTAREA></P></FORM>
      <P><FONT face="Tahoma, Verdana" size=2>The very last thing we need to do 
      is change the gameversion to "wof". So go to line 12 in <B>g_local.h</B> 
      and change it to this.</FONT></P>
      <FORM>
      <P><TEXTAREA cols=92 name=S1 rows=6>// the "gameversion" client command will print this plus compile date
//Wilka
//#define	GAMEVERSION	"baseq3"
#define	GAMEVERSION	"wof"
//W</TEXTAREA></P></FORM>
      <P><FONT face="Tahoma, Verdana" size=2>Now your mod is complete. If you 
      feel like giving it a bit more 'polish', you could let the player know how 
      many more kills they need to win. A good place for that happen would be 
      the <I>Wof_NextWeapon</I> function, and you might find the <I>strlen</I> 
      function (in <B>bg_lib.c</B>) handy. I'll leave the rest up to 
      you.</FONT></P>
      <P><FONT face="Tahoma, Verdana" size=2>Almost all mods are made of these 
      basic parts, so once you understand all of this you'll be able to make 
      whatever mod you like, well almost, your still limited to what Quake3 will 
      let you change :)</FONT></P>
      <P><FONT face="Tahoma, Verdana" size=2>Thanks to Rick Terrill for letting 
      me know what the "0" was for in the cvar struct. I also fixed a typo where 
      I used "WofNextWeapon" when I meant to type "Wof_NextWeapon", so sorry to 
      any of you that had trouble compiling the code because of it (thanks Jim 
      Frantzen for letting me know).</FONT></P>
      <HR>

      <P align=center><FONT face="Tahoma, Verdana" size=2>Tutorial by <A 
      href="mailto:wilka@frag.com">Wilka</A></FONT><FONT size=2><BR><FONT 
      face="Tahoma, Verdana"><A href="http://wiretap.gamedesign.net/">Wiretap 
      Development</A></FONT><BR><FONT face="Tahoma, Verdana"><A 
      href="http://www.planetquake.com/wiretap">Wiretap HQ</A></FONT></FONT></P>
      <P align=center>&nbsp;</P>
      <P align=left>&nbsp;</P>
      <P align=left>&nbsp;</P></TD></TR></TBODY></TABLE>
<P>&nbsp;</P><!-- #EndTemplate --></BODY></HTML>
