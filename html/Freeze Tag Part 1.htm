<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0055)http://quakestyle.telefragged.com/quake3/tutorial22.htm -->
<HTML><HEAD><TITLE>Quake Style - Quake 3 Tutorials - Freeze Tag - Freeze Tag Part 1</TITLE>
<META content="text/html; charset=iso-8859-1" http-equiv=Content-Type>
<STYLE type=text/css>BODY {
	FONT-FAMILY: verdana
}
TABLE {
	FONT-FAMILY: verdana
}
TR {
	FONT-FAMILY: verdana
}
TD {
	FONT-FAMILY: verdana
}
INPUT {
	FONT-FAMILY: verdana; FONT-SIZE: 10px
}
TEXTAREA {
	FONT-FAMILY: verdana; FONT-SIZE: 10px
}
SELECT {
	FONT-FAMILY: verdana; FONT-SIZE: 10px
}
OPTION {
	FONT-FAMILY: verdana; FONT-SIZE: 10px
}
PRE {
	FONT-FAMILY: verdana; FONT-WEIGHT: bold
}
A {
	COLOR: #00ff00
}
A:hover {
	COLOR: white; TEXT-DECORATION: none
}
</STYLE>

<META content="MSHTML 5.00.2919.6307" name=GENERATOR></HEAD>
<BODY bgColor=black text=#ffff80><FONT size=1>
<DIV align=right>
<TABLE border=0 cellSpacing=0 cellborder="0">
  <TBODY>
  <TR>
    <TD align=middle><FONT size=1><B><FONT color=white>Quake Style - Quake 3 
      Tutorials</FONT><BR><FONT color=#bbcc77>Freeze Tag </FONT><FONT 
      color=#ff8000>- Freeze Tag Part 1 </FONT><BR>Starting off the freeze tag 
      tuts.. 
</B></FONT></TD></TR></TBODY></TABLE></DIV><BR><!-- START TUTORIAL -->Making a 
Player Freeze <BR><BR>The first thing I worked on for Freeze was getting the 
player to actually freeze. The plan is to make it so they can fly around when 
dead. This means we'll have to leave a body behind in the spot they died. Here's 
g_combat.c player_die <BR><BR><PRE><FONT size=1>
	self-&gt;r.maxs[2] = -8;

	// don't allow respawn until the death anim is done
	// g_forcerespawn may force spawning at some later time
<FONT color=#00ffff>
/*freeze
	self-&gt;client-&gt;respawnTime = level.time + 1700;
freeze*/
</FONT>

	// remove powerups
	memset( self-&gt;client-&gt;ps.powerups, 0, sizeof(self-&gt;client-&gt;ps.powerups) );
<FONT color=#00ffff>
//freeze
	player_freeze( self, attacker, meansOfDeath );
	self-&gt;client-&gt;respawnTime = level.time + 1700;
//freeze
</FONT>
	// never gib in a nodrop
	if ( self-&gt;health &lt;= GIB_HEALTH &amp;&amp; !(contents &amp; CONTENTS_NODROP) &amp;&amp; g_blood.integer ) {
		// gib death
		GibEntity( self, killer );
	} else {
		// normal death
		static int i;
</FONT></PRE><BR>I call player_freeze BEFORE it checks to GibEntity from 
excessive damage. This way if we are freezing them I can set their health to 
GIB_HEALTH + 1. Here's g_freeze.c player_freeze <BR><BR><PRE><FONT size=1> 
<FONT color=#00ffff>
void player_freeze( gentity_t *targ, gentity_t *attacker, int mod ) 
{
// Don't freeze anyone if we're not in team play or during warmup time
	if ( g_gametype.integer &lt; GT_TEAM || level.warmupTime ) {
		return;
	}
// If they just (3 sec) respawned then don't freeze them
// Note we check their respawnTime so earlier I made sure this didn't get reset until after player_freeze was called
	if ( level.time - targ-&gt;client-&gt;respawnTime &lt; 3000 ) {
		return;
	}
// Don't freeze someone for certain cases
	switch ( mod ) {
	case MOD_WATER:
	case MOD_CRUSH:
	case MOD_TELEFRAG:
	case MOD_FALLING:
	case MOD_SUICIDE:
	case MOD_TARGET_LASER:
	case MOD_TRIGGER_HURT:
	case MOD_GRAPPLE:
		return;
	}
// Did a teammate kill us or did we kill ourselves?
	if ( OnSameTeam( targ, attacker ) &amp;&amp; targ != attacker ) {
		return;
	}

	targ-&gt;client-&gt;ps.powerups[ PW_BALL ] = INT_MAX;
	targ-&gt;client-&gt;noclip = qtrue;
	targ-&gt;health = 0;
	G_AddEvent( targ, EV_DEATH1, 0 );
	targ-&gt;client-&gt;ps.pm_time = 4000;
}
</FONT>
</FONT></PRE><BR>The last lines are very important. Let me show you this 
g_freeze.c IsFrozen <BR><BR><PRE><FONT size=1> 
<FONT color=#00ffff>
qboolean IsFrozen( gentity_t *ent ) {
// For clients and bots
	if ( ent-&gt;client &amp;&amp; ent-&gt;client-&gt;ps.powerups[ PW_BALL ] ) {
		return qtrue;
// For my fake bodies
	} else if ( ent-&gt;s.powerups &amp; ( 1 &lt;&lt; PW_BALL ) ) {
		return qtrue;
	}
	return qfalse;
}
</FONT> 
</FONT></PRE><BR>So the only way I know someone is frozen is if they have the 
powerup PW_BALL. THIS IS VERY IMPORTANT! The game (server) talks to cgame 
(client). How do I tell the cgame someone is frozen so that it can render them 
with a frozen look? Only certain stuff is "passed" to cgame and powerups are one 
of them. I noticed PW_BALL wasn't being used so I use that. This way I don't add 
any extra variable to the network code. Then I make the player noclip so they 
can move around, set their health to 0 so they don't GibEntity and that pm_time 
is there to hold them in place for 4 seconds so they can recognize they just 
died. ANOTHER VERY IMPORTANT TRICK I did was use G_AddEvent and EV_DEATH1. Let's 
look at cgame cg_event.c CG_EntityEvent <BR><BR><PRE><FONT size=1> 
	case EV_DEATH1:
<FONT color=#00ffff>
//freeze
		if ( es-&gt;number == cg.snap-&gt;ps.clientNum ) {
			cg.powerupTime = cg.time;
		}
		break;
//freeze
</FONT> 
	case EV_DEATH2:
	case EV_DEATH3:
		DEBUGNAME("EV_DEATHx");
		trap_S_StartSound( NULL, es-&gt;number, CHAN_VOICE, 
				CG_CustomSound( es-&gt;number, va("*death%i.wav", event - EV_DEATH1 + 1) ) );
		break;
</FONT></PRE><BR>EV_DEATH1 is never called by anything. player_die calls 
EV_DEATH1 + 1 which is just EV_DEATH2. So EV_DEATH1 is like a free event I can 
use (kinda like PW_BALL was free to change). I didn't want to bother with 
worrying about adding any new event. What this does is, this event is sent to 
every client. If you happen to be THE player that just died then we will set 
your powerupTime to the current time. Look throughout the source and you'll see 
powerupTime is free to use. I do this a lot and it's probably a bad practice, 
but throughout Freeze Tag I take other variables and use them to my whim. I made 
sure nothing else is using them during the time I use them. Anyways, what this 
will do is call up the scoreboard for our player that just frozen since the 
scoreboard isn't normally displayed if you're in noclip mode. Here's 
cg_scoreboard.c CG_DrawScoreboard <BR><PRE><FONT size=1> 
	if ( cg.showScores || cg.predictedPlayerState.pm_type == PM_DEAD ||
<FONT color=#00ffff>
//freeze
		( cg.predictedPlayerState.pm_type == PM_NOCLIP &amp;&amp; cg.powerupTime + 4000 &gt; cg.time ) ||
//freeze
</FONT>
		 cg.predictedPlayerState.pm_type == PM_INTERMISSION ) {
		fade = 1.0;
		fadeColor = colorWhite;
	} 
else {
</FONT></PRE><BR>It'll show the scores if you are pressing TAB (cg.showScores), 
if you're PM_DEAD, or if you're PM_NOCLIP (our frozen friend) and your 
powerupTime is still 4 seconds close to current time. <BR>Now our player's dead 
so back in g_combat.c player_die <BR><PRE><FONT size=1> 
		self-&gt;client-&gt;ps.torsoAnim = 
			( ( self-&gt;client-&gt;ps.torsoAnim &amp; ANIM_TOGGLEBIT ) ^ ANIM_TOGGLEBIT ) | anim;
<FONT color=#00ffff>
//freeze
		if ( IsFrozen( self ) ) {
			CopyToBody( self );
		} else {
//freeze
</FONT>
		G_AddEvent( self, EV_DEATH1 + 1, killer );
<FONT color=#00ffff>
//freeze
		}
//freeze
</FONT>
		// the body can still be gibbed
		self-&gt;die = body_die;
</FONT></PRE><BR>We're going to make a body for them (CopyToBody) if they're 
frozen, otherwise we'll make a screaming death noise. Here's g_freeze.c 
CopyToBody <BR><BR><PRE><FONT size=1>
<FONT color=#00ffff>
void CopyToBody( gentity_t *ent ) {
	gentity_t	*body;

// Create a game entity (our lovely frozen body)
	body = G_Spawn();
	if ( !body ) {
		return;
	}

	body-&gt;classname = "body";
// This is basically a copy of g_client.c CopyToBodyQue (normal body created when dead player respawns)
	body-&gt;s = ent-&gt;s;
	body-&gt;s.eFlags = EF_DEAD;
// This body's frozen
	body-&gt;s.powerups = ( 1 &lt;&lt; PW_BALL );
	body-&gt;s.loopSound = 0;
	body-&gt;s.number = body - g_entities;
	body-&gt;timestamp = level.time;
	body-&gt;physicsObject = qtrue;
	body-&gt;physicsBounce = 0;

// This is special
// This means we can shoot and bounce this body around
	G_SetOrigin( body, ent-&gt;r.currentOrigin );
	body-&gt;s.pos.trType = TR_GRAVITY;
	body-&gt;s.pos.trTime = level.time;
// Make sure to copy dead player's velocity to our body so it goes flying
	VectorCopy( ent-&gt;client-&gt;ps.velocity, body-&gt;s.pos.trDelta );

	body-&gt;s.event = 0;

	switch ( body-&gt;s.legsAnim &amp; ~ANIM_TOGGLEBIT ) {
	case BOTH_DEATH1:
	case BOTH_DEAD1:
		body-&gt;s.torsoAnim = body-&gt;s.legsAnim = BOTH_DEAD1;
		break;
	case BOTH_DEATH2:
	case BOTH_DEAD2:
		body-&gt;s.torsoAnim = body-&gt;s.legsAnim = BOTH_DEAD2;
		break;
	case BOTH_DEATH3:
	case BOTH_DEAD3:
	default:
		body-&gt;s.torsoAnim = body-&gt;s.legsAnim = BOTH_DEAD3;
		break;
	}

	body-&gt;r.svFlags = ent-&gt;r.svFlags;
// I am making the body have the default player's bounding box
// This isn't right though
// Could put body outside map so I need to fix this for later version
	VectorSet ( body-&gt;r.mins, -15, -15, -24 );
	VectorSet ( body-&gt;r.maxs, 15, 15, 32 );
	VectorCopy( ent-&gt;r.absmin, body-&gt;r.absmin );
	VectorCopy( ent-&gt;r.absmax, body-&gt;r.absmax );

	body-&gt;clipmask = CONTENTS_SOLID | CONTENTS_PLAYERCLIP;
// Make the body something solid
	body-&gt;r.contents = CONTENTS_BODY;
	body-&gt;r.ownerNum = ent-&gt;s.number;

	body-&gt;nextthink = level.time + FRAMETIME;
	body-&gt;think = BodyThink;

	body-&gt;die = Body_die;

	body-&gt;takedamage = qtrue;

	trap_LinkEntity( body );

	body-&gt;noise_index = G_SoundIndex( "sound/player/tankjr/jump1.wav" );
// I use splashDamage to remember what team this body is on
	body-&gt;splashDamage = level.clients[ ent-&gt;s.clientNum ].sess.sessionTeam;
// This will be used for when you look at the body and see a player's name
	body-&gt;s.otherEntityNum = ent-&gt;s.number;

	ent-&gt;health = GIB_HEALTH;
// Don't let bullets and rockets hit us
	ent-&gt;r.contents = 0;
// So they don't move after free to move around (push from explosion they died from)
	VectorClear( ent-&gt;client-&gt;ps.velocity );
}
</FONT>
</FONT></PRE><BR>When I set the player's health to GIB_HEALTH meant that in 
bg_misc.c BG_PlayerStateToEntityState the player goes invisible so as they 
noclip around you can't see them. <BR><PRE><FONT size=1>
	if ( ps-&gt;pm_type == PM_INTERMISSION || ps-&gt;pm_type == PM_SPECTATOR ) {
		s-&gt;eType = ET_INVISIBLE;
	} else if ( ps-&gt;stats[STAT_HEALTH] &lt;= GIB_HEALTH ) {
		s-&gt;eType = ET_INVISIBLE;
	} else {
		s-&gt;eType = ET_PLAYER;
	}
</FONT></PRE><BR>Vondi's Note: I quakestyle'd this tutorial and i had to denote 
the "new code" and the "old code" BUT i've never even looked at the q3a code 
so... erm.. its probably amazingly innacurate, i apolagise. Email me any 
corrections. Oh and i don't understand this code either so it could make a 
cluster chicken launcher for all i know. <!--- END TUTORIAL ---><BR><BR><FONT 
color=#ff8000><B>-- Credits:</B></FONT> <BR>&nbsp;&nbsp; Tutorial by <A 
href="mailto:dbircsak@earthlink.net"><B>Doolittle</B></A> <BR>&nbsp;&nbsp; 
Return to <A href="http://quakestyle.telefragged.com/tuts.shtml"><B>QS 
Tutorials</B></A> <BR><BR><FONT color=#ff8000><B>-- Important:</B></FONT> 
<BR>&nbsp;&nbsp; If you do use something from QuakeStyle in your mod, please 
give us credit. <BR>&nbsp;&nbsp; Our code is copyrighted, but we give permission 
to everyone to use it in any way they see fit, as long as we are recognized. 
</FONT></BODY></HTML>
