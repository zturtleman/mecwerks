<SCRIPT SRC="http://ads.gamespy.com/jserver/SITE=PQ/AREA=HOSTED/GENRE=ACTION/TIER=3/AAMSZ=PRESTITIAL?304249921"></SCRIPT><!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0039)http://www.q3f.com/atmospheric_src.html -->
<HTML><HEAD><TITLE>Source: Atmospheric Effects</TITLE>
<META content="text/html; charset=windows-1252" http-equiv=Content-Type>
<META content="MSHTML 5.00.2614.3500" name=GENERATOR></HEAD>
<BODY bgColor=#ffffff><FONT face="Verdana, Tahoma, Arial" size=2><B>Source: 
Atmospheric Effects</B><BR>
<HR>
Date: 05-05-2001<BR>Authors: Golliwog and Arnout 'RR2DO2' van Meer 
<P>This is the code that is used in Q3F to create the atmospheric effects in the 
maps, such as rain and snow. Please keep in mind that this is not a tutorial, 
only a direct source dump. Thus there is a lack of comments and clarity at some 
points. (And unless someone can give me a really good reason to change that, it 
isn't likely to change ;) 
<P>First a new file is needed in the cgame module, cg_atmospheric.c: 
<P>
<TABLE border=2 cellPadding=15 cellSpacing=0 width="100%">
  <TBODY>
  <TR>
    <TD bgColor=#ffffff><PRE><FONT color=#007f00>/*
**  	Copyright (C) 2000, 2001 by the Q3F Development team
**  	All rights reserved.
**
**  	cg_atmospheric.c
**
**  	Add atmospheric effects to view.
**
**  	Current supported effects are rain and snow.
*/</FONT>

<FONT color=#0000ff>#include</FONT> "cg_local.h"

<FONT color=#0000ff>#define</FONT> MAX_ATMOSPHERIC_PARTICLES  	  	1000  	<FONT color=#007f00>// maximum # of particles</FONT>
<FONT color=#0000ff>#define</FONT> MAX_ATMOSPHERIC_DISTANCE  	  	1000  	<FONT color=#007f00>// maximum distance from refdef origin that particles are visible</FONT>
<FONT color=#0000ff>#define</FONT> MAX_ATMOSPHERIC_HEIGHT  	  	  	4096  	<FONT color=#007f00>// maximum world height (FIXME: since 1.27 this should be 65536)</FONT>
<FONT color=#0000ff>#define</FONT> MIN_ATMOSPHERIC_HEIGHT  	  	  	-4096  	<FONT color=#007f00>// minimum world height (FIXME: since 1.27 this should be -65536)</FONT>
<FONT color=#0000ff>#define</FONT> MAX_ATMOSPHERIC_EFFECTSHADERS  	6  	  	<FONT color=#007f00>// maximum different effectshaders for an atmospheric effect</FONT>
<FONT color=#0000ff>#define</FONT> ATMOSPHERIC_DROPDELAY  	  	  	1000
<FONT color=#0000ff>#define</FONT> ATMOSPHERIC_CUTHEIGHT  	  	  	800


<FONT color=#0000ff>#define</FONT> ATMOSPHERIC_RAIN_SPEED  	  	1.1f * DEFAULT_GRAVITY
<FONT color=#0000ff>#define</FONT> ATMOSPHERIC_RAIN_HEIGHT  	  	150

<FONT color=#0000ff>#define</FONT> ATMOSPHERIC_SNOW_SPEED  	  	0.1f * DEFAULT_GRAVITY
<FONT color=#0000ff>#define</FONT> ATMOSPHERIC_SNOW_HEIGHT  	  	10

<FONT color=#0000ff>typedef</FONT> <FONT color=#0000ff>struct</FONT> cg_atmosphericParticle_s {
  	vec3_t pos, delta, deltaNormalized, colour, surfacenormal;
  	<FONT color=#0000ff>float</FONT> height, minz, weight;
  	qboolean active;
  	<FONT color=#0000ff>int</FONT> contents, surface, nextDropTime;
  	qhandle_t *effectshader;
} cg_atmosphericParticle_t;

<FONT color=#0000ff>typedef</FONT> <FONT color=#0000ff>struct</FONT> cg_atmosphericEffect_s {
  	cg_atmosphericParticle_t particles[MAX_ATMOSPHERIC_PARTICLES];
  	qhandle_t effectshaders[MAX_ATMOSPHERIC_EFFECTSHADERS];
  	qhandle_t effectwatershader, effectlandshader;
  	<FONT color=#0000ff>int</FONT> lastRainTime, numDrops;
  	<FONT color=#0000ff>int</FONT> gustStartTime, gustEndTime;
  	<FONT color=#0000ff>int</FONT> baseStartTime, baseEndTime;
  	<FONT color=#0000ff>int</FONT> gustMinTime, gustMaxTime;
  	<FONT color=#0000ff>int</FONT> changeMinTime, changeMaxTime;
  	<FONT color=#0000ff>int</FONT> baseMinTime, baseMaxTime;
  	<FONT color=#0000ff>float</FONT> baseWeight, gustWeight;
  	<FONT color=#0000ff>int</FONT> baseDrops, gustDrops;
  	<FONT color=#0000ff>int</FONT> numEffectShaders;
  	qboolean waterSplash, landSplash;
  	vec3_t baseVec, gustVec;

  	qboolean (*ParticleCheckVisible)( cg_atmosphericParticle_t *particle );
  	qboolean (*ParticleGenerate)( cg_atmosphericParticle_t *particle, vec3_t currvec, <FONT color=#0000ff>float</FONT> currweight );
  	<FONT color=#0000ff>void</FONT> (*ParticleRender)( cg_atmosphericParticle_t *particle );
} cg_atmosphericEffect_t;

<FONT color=#0000ff>static</FONT> cg_atmosphericEffect_t cg_atmFx;

<FONT color=#007f00>/*
**  Render utility functions
*/</FONT>

<FONT color=#0000ff>void</FONT> CG_EffectMark(  	qhandle_t markShader, <FONT color=#0000ff>const</FONT> vec3_t origin, <FONT color=#0000ff>const</FONT> vec3_t dir, <FONT color=#0000ff>float</FONT> alpha, <FONT color=#0000ff>float</FONT> radius ) {
  	<FONT color=#007f00>// 'quick' version of the CG_ImpactMark function</FONT>

  	vec3_t  	  	  	axis[3];
  	<FONT color=#0000ff>float</FONT>  	  	  	texCoordScale;
  	vec3_t  	  	  	originalPoints[4];
  	byte  	  	  	colors[4];
  	<FONT color=#0000ff>int</FONT>  	  	  	  	i;
  	polyVert_t  	  	*v;
  	polyVert_t  	  	verts[4];

  	<FONT color=#0000ff>if</FONT> ( !cg_addMarks.integer ) {
  	  	<FONT color=#0000ff>return</FONT>;
  	}

  	<FONT color=#0000ff>if</FONT> ( radius &lt;= 0 ) {
  	  	CG_Error( "CG_EffectMark called with &lt;= 0 radius" );
  	}

  	<FONT color=#007f00>// create the texture axis</FONT>
  	VectorNormalize2( dir, axis[0] );
  	PerpendicularVector( axis[1], axis[0] );
  	VectorSet( axis[2], 1, 0, 0 );  	  	  	<FONT color=#007f00>// This is _wrong_, but the function is for water anyway (i.e. usually flat)</FONT>
  	CrossProduct( axis[0], axis[2], axis[1] );

  	texCoordScale = 0.5 * 1.0 / radius;

  	<FONT color=#007f00>// create the full polygon</FONT>
  	<FONT color=#0000ff>for</FONT> ( i = 0 ; i &lt; 3 ; i++ ) {
  	  	originalPoints[0][i] = origin[i] - radius * axis[1][i] - radius * axis[2][i];
  	  	originalPoints[1][i] = origin[i] + radius * axis[1][i] - radius * axis[2][i];
  	  	originalPoints[2][i] = origin[i] + radius * axis[1][i] + radius * axis[2][i];
  	  	originalPoints[3][i] = origin[i] - radius * axis[1][i] + radius * axis[2][i];
  	}

  	colors[0] = 127;
  	colors[1] = 127;
  	colors[2] = 127;
  	colors[3] = alpha * 255;

  	<FONT color=#0000ff>for</FONT> ( i = 0, v = verts ; i &lt; 4 ; i++, v++ ) {
  	  	vec3_t  	  	delta;

  	  	VectorCopy( originalPoints[i], v-&gt;xyz );

  	  	VectorSubtract( v-&gt;xyz, origin, delta );
  	  	v-&gt;st[0] = 0.5 + DotProduct( delta, axis[1] ) * texCoordScale;
  	  	v-&gt;st[1] = 0.5 + DotProduct( delta, axis[2] ) * texCoordScale;
  	  	*(<FONT color=#0000ff>int</FONT> *)v-&gt;modulate = *(<FONT color=#0000ff>int</FONT> *)colors;
  	}

  	trap_R_AddPolyToScene( markShader, 4, verts );
}

<FONT color=#007f00>/*
**  	Raindrop management functions
*/</FONT>

<FONT color=#0000ff>static</FONT> qboolean CG_RainParticleCheckVisible( cg_atmosphericParticle_t *particle )
{
  	<FONT color=#007f00>// Check the raindrop is visible and still going, wrapping if necessary.</FONT>

  	<FONT color=#0000ff>float</FONT> moved;
  	vec3_t distance;

  	<FONT color=#0000ff>if</FONT>( !particle || !particle-&gt;active )
  	  	<FONT color=#0000ff>return</FONT>( qfalse );

  	moved = (cg.time - cg_atmFx.lastRainTime) * 0.001;  	<FONT color=#007f00>// Units moved since last frame</FONT>
  	VectorMA( particle-&gt;pos, moved, particle-&gt;delta, particle-&gt;pos );
  	<FONT color=#0000ff>if</FONT>( particle-&gt;pos[2] + ATMOSPHERIC_CUTHEIGHT &lt; particle-&gt;minz )
  	  	<FONT color=#0000ff>return</FONT>( particle-&gt;active = qfalse );

  	VectorSubtract( cg.refdef.vieworg, particle-&gt;pos, distance );
  	<FONT color=#0000ff>if</FONT>( sqrt( distance[0] * distance[0] + distance[1] * distance[1] ) &gt; MAX_ATMOSPHERIC_DISTANCE )
  	  	<FONT color=#0000ff>return</FONT>( particle-&gt;active = qfalse );

  	<FONT color=#0000ff>return</FONT>( qtrue );
}

<FONT color=#0000ff>static</FONT> qboolean CG_RainParticleGenerate( cg_atmosphericParticle_t *particle, vec3_t currvec, <FONT color=#0000ff>float</FONT> currweight )
{
  	<FONT color=#007f00>// Attempt to 'spot' a raindrop somewhere below a sky texture.</FONT>

  	<FONT color=#0000ff>float</FONT> angle, distance, origz;
  	vec3_t testpoint, testend;
  	trace_t tr;

  	angle = random() * 2*M_PI;
  	distance = 20 + MAX_ATMOSPHERIC_DISTANCE * random();

  	testpoint[0] = testend[0] = cg.refdef.vieworg[0] + sin(angle) * distance;
  	testpoint[1] = testend[1] = cg.refdef.vieworg[1] + cos(angle) * distance;
  	testpoint[2] = origz = cg.refdef.vieworg[2];
  	testend[2] = testpoint[2] + MAX_ATMOSPHERIC_HEIGHT;

  	<FONT color=#0000ff>while</FONT>( 1 )
  	{
  	  	<FONT color=#0000ff>if</FONT>( testpoint[2] &gt;= MAX_ATMOSPHERIC_HEIGHT )
  	  	  	<FONT color=#0000ff>return</FONT>( qfalse );
  	  	<FONT color=#0000ff>if</FONT>( testend[2] &gt;= MAX_ATMOSPHERIC_HEIGHT )
  	  	  	testend[2] = MAX_ATMOSPHERIC_HEIGHT - 1;
  	  	CG_Trace( &amp;tr, testpoint, NULL, NULL, testend, ENTITYNUM_NONE, MASK_SOLID|MASK_WATER );
  	  	<FONT color=#0000ff>if</FONT>( tr.startsolid )  	  	  	<FONT color=#007f00>// Stuck in something, skip over it.</FONT>
  	  	{
  	  	  	testpoint[2] += 64;
  	  	  	testend[2] = testpoint[2] + MAX_ATMOSPHERIC_HEIGHT;
  	  	}
  	  	<FONT color=#0000ff>else</FONT> <FONT color=#0000ff>if</FONT>( tr.fraction == 1 )  	  	<FONT color=#007f00>// Didn't hit anything, we're (probably) outside the world</FONT>
  	  	  	<FONT color=#0000ff>return</FONT>( qfalse );
  	  	<FONT color=#0000ff>else</FONT> <FONT color=#0000ff>if</FONT>( tr.surfaceFlags &amp; SURF_SKY )  	<FONT color=#007f00>// Hit sky, this is where we start.</FONT>
  	  	  	<FONT color=#0000ff>break</FONT>;
  	  	<FONT color=#0000ff>else</FONT> <FONT color=#0000ff>return</FONT>( qfalse );
  	}

  	particle-&gt;active = qtrue;
  	particle-&gt;colour[0] = 0.6 + 0.2 * random();
  	particle-&gt;colour[1] = 0.6 + 0.2 * random();
  	particle-&gt;colour[2] = 0.6 + 0.2 * random();
  	VectorCopy( tr.endpos, particle-&gt;pos );
  	VectorCopy( currvec, particle-&gt;delta );
  	particle-&gt;delta[2] += crandom() * 100;
  	VectorNormalize2( particle-&gt;delta, particle-&gt;deltaNormalized );
  	particle-&gt;height = ATMOSPHERIC_RAIN_HEIGHT + crandom() * 100;
  	particle-&gt;weight = currweight;
  	particle-&gt;effectshader = &amp;cg_atmFx.effectshaders[0];

  	distance =  	((<FONT color=#0000ff>float</FONT>)(tr.endpos[2] - MIN_ATMOSPHERIC_HEIGHT)) / -particle-&gt;delta[2];
  	VectorMA( tr.endpos, distance, particle-&gt;delta, testend );

  	CG_Trace( &amp;tr, particle-&gt;pos, NULL, NULL, testend, ENTITYNUM_NONE, MASK_SOLID|MASK_WATER );
  	particle-&gt;minz = tr.endpos[2];
  	tr.endpos[2]--;
  	VectorCopy( tr.plane.normal, particle-&gt;surfacenormal );
  	particle-&gt;surface = tr.surfaceFlags;
  	particle-&gt;contents = CG_PointContents( tr.endpos, ENTITYNUM_NONE );

  	<FONT color=#0000ff>return</FONT>( qtrue );
}

<FONT color=#0000ff>static</FONT> <FONT color=#0000ff>void</FONT> CG_RainParticleRender( cg_atmosphericParticle_t *particle )
{
  	<FONT color=#007f00>// Draw a raindrop</FONT>

  	vec3_t  	  	forward, right;
  	polyVert_t  	verts[4];
  	vec2_t  	  	line;
  	<FONT color=#0000ff>float</FONT>  	  	len, frac;
  	vec3_t  	  	start, finish;

  	<FONT color=#0000ff>if</FONT>( !particle-&gt;active )
  	  	<FONT color=#0000ff>return</FONT>;

  	VectorCopy( particle-&gt;pos, start );
  	len = particle-&gt;height;
  	<FONT color=#0000ff>if</FONT>( start[2] &lt;= particle-&gt;minz )
  	{
  	  	<FONT color=#007f00>// Stop rain going through surfaces.</FONT>
  	  	len = particle-&gt;height - particle-&gt;minz + start[2];
  	  	frac = start[2];
  	  	VectorMA( start, len - particle-&gt;height, particle-&gt;deltaNormalized, start );

  	  	<FONT color=#0000ff>if</FONT>( !cg_lowEffects.integer )
  	  	{
  	  	  	frac = (ATMOSPHERIC_CUTHEIGHT - particle-&gt;minz + frac) / (<FONT color=#0000ff>float</FONT>) ATMOSPHERIC_CUTHEIGHT;
  	  	  	<FONT color=#007f00>// Splash effects on different surfaces</FONT>
  	  	  	<FONT color=#0000ff>if</FONT>( particle-&gt;contents &amp; (CONTENTS_WATER|CONTENTS_SLIME) )
  	  	  	{
  	  	  	  	<FONT color=#007f00>// Water splash</FONT>
  	  	  	  	<FONT color=#0000ff>if</FONT>( cg_atmFx.effectwatershader &amp;&amp; frac &gt; 0 &amp;&amp; frac &lt; 1 )
  	  	  	  	  	CG_EffectMark( cg_atmFx.effectwatershader, start, particle-&gt;surfacenormal, frac * 0.5, 8 - frac * 8 );
  	  	  	}
  	  	  	<FONT color=#0000ff>else</FONT> <FONT color=#0000ff>if</FONT>( !(particle-&gt;contents &amp; CONTENTS_LAVA) &amp;&amp; !(particle-&gt;surface &amp; (SURF_NODAMAGE|SURF_NOIMPACT|SURF_NOMARKS|SURF_SKY)) )
  	  	  	{
  	  	  	  	<FONT color=#007f00>// Solid splash</FONT>
  	  	  	  	<FONT color=#0000ff>if</FONT>( cg_atmFx.effectlandshader &amp;&amp; frac &gt; 0 &amp;&amp; frac &lt; 1  )
  	  	  	  	  	CG_ImpactMark( cg_atmFx.effectlandshader, start, particle-&gt;surfacenormal, 0, 1, 1, 1, frac * 0.5, qfalse, 3 - frac * 2, qtrue );
  	  	  	}
  	  	}
  	}
  	<FONT color=#0000ff>if</FONT>( len &lt;= 0 )
  	  	<FONT color=#0000ff>return</FONT>;

  	VectorCopy( particle-&gt;deltaNormalized, forward );
  	VectorMA( start, -len, forward, finish );

  	line[0] = DotProduct( forward, cg.refdef.viewaxis[1] );
  	line[1] = DotProduct( forward, cg.refdef.viewaxis[2] );

  	VectorScale( cg.refdef.viewaxis[1], line[1], right );
  	VectorMA( right, -line[0], cg.refdef.viewaxis[2], right );
  	VectorNormalize( right );

  	VectorMA( finish, particle-&gt;weight, right, verts[0].xyz );
  	verts[0].st[0] = 1;
  	verts[0].st[1] = 0;
  	verts[0].modulate[0] = 255;
  	verts[0].modulate[1] = 255;
  	verts[0].modulate[2] = 255;
  	verts[0].modulate[3] = 0;

  	VectorMA( finish, -particle-&gt;weight, right, verts[1].xyz );
  	verts[1].st[0] = 0;
  	verts[1].st[1] = 0;
  	verts[1].modulate[0] = 255;
  	verts[1].modulate[1] = 255;
  	verts[1].modulate[2] = 255;
  	verts[1].modulate[3] = 0;

  	VectorMA( start, -particle-&gt;weight, right, verts[2].xyz );
  	verts[2].st[0] = 0;
  	verts[2].st[1] = 1;
  	verts[2].modulate[0] = 255;
  	verts[2].modulate[1] = 255;
  	verts[2].modulate[2] = 255;
  	verts[2].modulate[3] = 127;

  	VectorMA( start, particle-&gt;weight, right, verts[3].xyz );
  	verts[3].st[0] = 1;
  	verts[3].st[1] = 1;
  	verts[3].modulate[0] = 255;
  	verts[3].modulate[1] = 255;
  	verts[3].modulate[2] = 255;
  	verts[3].modulate[3] = 127;

  	trap_R_AddPolyToScene( *particle-&gt;effectshader, 4, verts );
}

<FONT color=#007f00>/*
**  	Snow management functions
*/</FONT>

<FONT color=#0000ff>static</FONT> qboolean CG_SnowParticleGenerate( cg_atmosphericParticle_t *particle, vec3_t currvec, <FONT color=#0000ff>float</FONT> currweight )
{
  	<FONT color=#007f00>// Attempt to 'spot' a raindrop somewhere below a sky texture.</FONT>

  	<FONT color=#0000ff>float</FONT> angle, distance, origz;
  	vec3_t testpoint, testend;
  	trace_t tr;

  	angle = random() * 2*M_PI;
  	distance = 20 + MAX_ATMOSPHERIC_DISTANCE * random();

  	testpoint[0] = testend[0] = cg.refdef.vieworg[0] + sin(angle) * distance;
  	testpoint[1] = testend[1] = cg.refdef.vieworg[1] + cos(angle) * distance;
  	testpoint[2] = origz = cg.refdef.vieworg[2];
  	testend[2] = testpoint[2] + MAX_ATMOSPHERIC_HEIGHT;

  	<FONT color=#0000ff>while</FONT>( 1 )
  	{
  	  	<FONT color=#0000ff>if</FONT>( testpoint[2] &gt;= MAX_ATMOSPHERIC_HEIGHT )
  	  	  	<FONT color=#0000ff>return</FONT>( qfalse );
  	  	<FONT color=#0000ff>if</FONT>( testend[2] &gt;= MAX_ATMOSPHERIC_HEIGHT )
  	  	  	testend[2] = MAX_ATMOSPHERIC_HEIGHT - 1;
  	  	CG_Trace( &amp;tr, testpoint, NULL, NULL, testend, ENTITYNUM_NONE, MASK_SOLID|MASK_WATER );
  	  	<FONT color=#0000ff>if</FONT>( tr.startsolid )  	  	  	<FONT color=#007f00>// Stuck in something, skip over it.</FONT>
  	  	{
  	  	  	testpoint[2] += 64;
  	  	  	testend[2] = testpoint[2] + MAX_ATMOSPHERIC_HEIGHT;
  	  	}
  	  	<FONT color=#0000ff>else</FONT> <FONT color=#0000ff>if</FONT>( tr.fraction == 1 )  	  	<FONT color=#007f00>// Didn't hit anything, we're (probably) outside the world</FONT>
  	  	  	<FONT color=#0000ff>return</FONT>( qfalse );
  	  	<FONT color=#0000ff>else</FONT> <FONT color=#0000ff>if</FONT>( tr.surfaceFlags &amp; SURF_SKY )  	<FONT color=#007f00>// Hit sky, this is where we start.</FONT>
  	  	  	<FONT color=#0000ff>break</FONT>;
  	  	<FONT color=#0000ff>else</FONT> <FONT color=#0000ff>return</FONT>( qfalse );
  	}

  	particle-&gt;active = qtrue;
  	particle-&gt;colour[0] = 0.6 + 0.2 * random();
  	particle-&gt;colour[1] = 0.6 + 0.2 * random();
  	particle-&gt;colour[2] = 0.6 + 0.2 * random();
  	VectorCopy( tr.endpos, particle-&gt;pos );
  	VectorCopy( currvec, particle-&gt;delta );
  	particle-&gt;delta[2] += crandom() * 25;
  	VectorNormalize2( particle-&gt;delta, particle-&gt;deltaNormalized );
  	particle-&gt;height = ATMOSPHERIC_SNOW_HEIGHT + crandom() * 8;
  	particle-&gt;weight = particle-&gt;height * 0.5f;
  	particle-&gt;effectshader = &amp;cg_atmFx.effectshaders[ (<FONT color=#0000ff>int</FONT>) (random() * ( cg_atmFx.numEffectShaders - 1 )) ];

  	distance =  	((<FONT color=#0000ff>float</FONT>)(tr.endpos[2] - MIN_ATMOSPHERIC_HEIGHT)) / -particle-&gt;delta[2];
  	VectorMA( tr.endpos, distance, particle-&gt;delta, testend );
  	CG_Trace( &amp;tr, particle-&gt;pos, NULL, NULL, testend, ENTITYNUM_NONE, MASK_SOLID|MASK_WATER );
  	particle-&gt;minz = tr.endpos[2];
  	tr.endpos[2]--;
  	VectorCopy( tr.plane.normal, particle-&gt;surfacenormal );
  	particle-&gt;surface = tr.surfaceFlags;
  	particle-&gt;contents = CG_PointContents( tr.endpos, ENTITYNUM_NONE );

  	<FONT color=#0000ff>return</FONT>( qtrue );
}

<FONT color=#0000ff>static</FONT> <FONT color=#0000ff>void</FONT> CG_SnowParticleRender( cg_atmosphericParticle_t *particle )
{
  	<FONT color=#007f00>// Draw a snowflake</FONT>

  	vec3_t  	  	forward, right;
  	polyVert_t  	verts[4];
  	vec2_t  	  	line;
  	<FONT color=#0000ff>float</FONT>  	  	len, frac, sinTumbling, cosTumbling, particleWidth;
  	vec3_t  	  	start, finish;

  	<FONT color=#0000ff>if</FONT>( !particle-&gt;active )
  	  	<FONT color=#0000ff>return</FONT>;

  	VectorCopy( particle-&gt;pos, start );

  	sinTumbling = sin( particle-&gt;pos[2] * 0.03125f );
  	cosTumbling = cos( ( particle-&gt;pos[2] + particle-&gt;pos[1] )  * 0.03125f );

  	start[0] += 24 * ( 1 - particle-&gt;deltaNormalized[2] ) * sinTumbling;
  	start[1] += 24 * ( 1 - particle-&gt;deltaNormalized[2] ) * cosTumbling;

  	len = particle-&gt;height;
  	<FONT color=#0000ff>if</FONT>( start[2] &lt;= particle-&gt;minz )
  	{
  	  	<FONT color=#007f00>// Stop snow going through surfaces.</FONT>
  	  	len = particle-&gt;height - particle-&gt;minz + start[2];
  	  	frac = start[2];
  	  	VectorMA( start, len - particle-&gt;height, particle-&gt;deltaNormalized, start );
  	}
  	<FONT color=#0000ff>if</FONT>( len &lt;= 0 )
  	  	<FONT color=#0000ff>return</FONT>;

  	VectorCopy( particle-&gt;deltaNormalized, forward );
  	VectorMA( start, -( len * sinTumbling ), forward, finish );

  	line[0] = DotProduct( forward, cg.refdef.viewaxis[1] );
  	line[1] = DotProduct( forward, cg.refdef.viewaxis[2] );

  	VectorScale( cg.refdef.viewaxis[1], line[1], right );
  	VectorMA( right, -line[0], cg.refdef.viewaxis[2], right );
  	VectorNormalize( right );

  	particleWidth = cosTumbling * particle-&gt;weight;

  	VectorMA( finish, particleWidth, right, verts[0].xyz );
  	verts[0].st[0] = 1;
  	verts[0].st[1] = 0;
  	verts[0].modulate[0] = 255;
  	verts[0].modulate[1] = 255;
  	verts[0].modulate[2] = 255;
  	verts[0].modulate[3] = 255;

  	VectorMA( finish, -particleWidth, right, verts[1].xyz );
  	verts[1].st[0] = 0;
  	verts[1].st[1] = 0;
  	verts[1].modulate[0] = 255;
  	verts[1].modulate[1] = 255;
  	verts[1].modulate[2] = 255;
  	verts[1].modulate[3] = 255;

  	VectorMA( start, -particleWidth, right, verts[2].xyz );
  	verts[2].st[0] = 0;
  	verts[2].st[1] = 1;
  	verts[2].modulate[0] = 255;
  	verts[2].modulate[1] = 255;
  	verts[2].modulate[2] = 255;
  	verts[2].modulate[3] = 255;

  	VectorMA( start, particleWidth, right, verts[3].xyz );
  	verts[3].st[0] = 1;
  	verts[3].st[1] = 1;
  	verts[3].modulate[0] = 255;
  	verts[3].modulate[1] = 255;
  	verts[3].modulate[2] = 255;
  	verts[3].modulate[3] = 255;

  	trap_R_AddPolyToScene( *particle-&gt;effectshader, 4, verts );
}

<FONT color=#007f00>/*
**  	Set up gust parameters.
*/</FONT>

<FONT color=#0000ff>static</FONT> <FONT color=#0000ff>void</FONT> CG_EffectGust()
{
  	<FONT color=#007f00>// Generate random values for the next gust</FONT>

  	<FONT color=#0000ff>int</FONT> diff;

  	cg_atmFx.baseEndTime  	  	= cg.time  	  	  	  	  	+ cg_atmFx.baseMinTime  	  	+ (rand() % (cg_atmFx.baseMaxTime - cg_atmFx.baseMinTime));
  	diff  	  	  	  	  	  	= cg_atmFx.changeMaxTime  	- cg_atmFx.changeMinTime;
  	cg_atmFx.gustStartTime  	  	= cg_atmFx.baseEndTime  	  	+ cg_atmFx.changeMinTime  	+ (diff ? (rand() % diff) : 0);
  	diff  	  	  	  	  	  	= cg_atmFx.gustMaxTime  	  	- cg_atmFx.gustMinTime;
  	cg_atmFx.gustEndTime  	  	= cg_atmFx.gustStartTime  	+ cg_atmFx.gustMinTime  	  	+ (diff ? (rand() % diff) : 0);
  	diff  	  	  	  	  	  	= cg_atmFx.changeMaxTime  	- cg_atmFx.changeMinTime;
  	cg_atmFx.baseStartTime  	  	= cg_atmFx.gustEndTime  	  	+ cg_atmFx.changeMinTime  	+ (diff ? (rand() % diff) : 0);
}

<FONT color=#0000ff>static</FONT> qboolean CG_EffectGustCurrent( vec3_t curr, <FONT color=#0000ff>float</FONT> *weight, <FONT color=#0000ff>int</FONT> *num )
{
  	<FONT color=#007f00>// Calculate direction for new drops.</FONT>

  	vec3_t temp;
  	<FONT color=#0000ff>float</FONT> frac;

  	<FONT color=#0000ff>if</FONT>( cg.time &lt; cg_atmFx.baseEndTime )
  	{
  	  	VectorCopy( cg_atmFx.baseVec, curr );
  	  	*weight = cg_atmFx.baseWeight;
  	  	*num = cg_atmFx.baseDrops;
  	}
  	<FONT color=#0000ff>else</FONT> {
  	  	VectorSubtract( cg_atmFx.gustVec, cg_atmFx.baseVec, temp );
  	  	<FONT color=#0000ff>if</FONT>( cg.time &lt; cg_atmFx.gustStartTime )
  	  	{
  	  	  	frac = ((<FONT color=#0000ff>float</FONT>)(cg.time - cg_atmFx.baseEndTime))/((<FONT color=#0000ff>float</FONT>)(cg_atmFx.gustStartTime - cg_atmFx.baseEndTime));
  	  	  	VectorMA( cg_atmFx.baseVec, frac, temp, curr );
  	  	  	*weight = cg_atmFx.baseWeight + (cg_atmFx.gustWeight - cg_atmFx.baseWeight) * frac;
  	  	  	*num = cg_atmFx.baseDrops + ((<FONT color=#0000ff>float</FONT>)(cg_atmFx.gustDrops - cg_atmFx.baseDrops)) * frac;
  	  	}
  	  	<FONT color=#0000ff>else</FONT> <FONT color=#0000ff>if</FONT>( cg.time &lt; cg_atmFx.gustEndTime )
  	  	{
  	  	  	VectorCopy( cg_atmFx.gustVec, curr );
  	  	  	*weight = cg_atmFx.gustWeight;
  	  	  	*num = cg_atmFx.gustDrops;
  	  	}
  	  	<FONT color=#0000ff>else</FONT>
  	  	{
  	  	  	frac = 1.0 - ((<FONT color=#0000ff>float</FONT>)(cg.time - cg_atmFx.gustEndTime))/((<FONT color=#0000ff>float</FONT>)(cg_atmFx.baseStartTime - cg_atmFx.gustEndTime));
  	  	  	VectorMA( cg_atmFx.baseVec, frac, temp, curr );
  	  	  	*weight = cg_atmFx.baseWeight + (cg_atmFx.gustWeight - cg_atmFx.baseWeight) * frac;
  	  	  	*num = cg_atmFx.baseDrops + ((<FONT color=#0000ff>float</FONT>)(cg_atmFx.gustDrops - cg_atmFx.baseDrops)) * frac;
  	  	  	<FONT color=#0000ff>if</FONT>( cg.time &gt;= cg_atmFx.baseStartTime )
  	  	  	  	<FONT color=#0000ff>return</FONT>( qtrue );
  	  	}
  	}
  	<FONT color=#0000ff>return</FONT>( qfalse );
}

<FONT color=#0000ff>static</FONT> <FONT color=#0000ff>void</FONT> CG_EP_ParseFloats( <FONT color=#0000ff>char</FONT> *floatstr, <FONT color=#0000ff>float</FONT> *f1, <FONT color=#0000ff>float</FONT> *f2 )
{
  	<FONT color=#007f00>// Parse the float or floats</FONT>

  	<FONT color=#0000ff>char</FONT> *middleptr;
  	<FONT color=#0000ff>char</FONT> buff[64];

  	Q_strncpyz( buff, floatstr, <FONT color=#0000ff>sizeof</FONT>(buff) );
  	<FONT color=#0000ff>for</FONT>( middleptr = buff; *middleptr &amp;&amp; *middleptr != ' '; middleptr++ );
  	<FONT color=#0000ff>if</FONT>( *middleptr )
  	{
  	  	*middleptr++ = 0;
  	  	*f1 = atof( floatstr );
  	  	*f2 = atof( middleptr );
  	}
  	<FONT color=#0000ff>else</FONT> {
  	  	*f1 = *f2 = atof( floatstr );
  	}
}
<FONT color=#0000ff>void</FONT> CG_EffectParse( <FONT color=#0000ff>const</FONT> <FONT color=#0000ff>char</FONT> *effectstr )
{
  	<FONT color=#007f00>// Split the string into it's component parts.</FONT>

  	<FONT color=#0000ff>float</FONT> bmin, bmax, cmin, cmax, gmin, gmax, bdrop, gdrop, wsplash, lsplash;
  	<FONT color=#0000ff>int</FONT> count;
  	<FONT color=#0000ff>char</FONT> *startptr, *eqptr, *endptr, *type;
  	<FONT color=#0000ff>char</FONT> workbuff[128];

  	<FONT color=#0000ff>if</FONT>( CG_AtmosphericKludge() )
  	  	<FONT color=#0000ff>return</FONT>;

  	  	<FONT color=#007f00>// Set up some default values</FONT>
  	cg_atmFx.baseVec[0] = cg_atmFx.baseVec[1] = 0;
  	cg_atmFx.gustVec[0] = cg_atmFx.gustVec[1] = 100;
  	bmin = 5;
  	bmax = 10;
  	cmin = 1;
  	cmax = 1;
  	gmin = 0;
  	gmax = 2;
  	bdrop = gdrop = 300;
  	cg_atmFx.baseWeight = 0.7f;
  	cg_atmFx.gustWeight = 1.5f;
  	wsplash = 1;
  	lsplash = 1;
  	type = NULL;

  	  	<FONT color=#007f00>// Parse the parameter string</FONT>
  	Q_strncpyz( workbuff, effectstr, <FONT color=#0000ff>sizeof</FONT>(workbuff) );
  	<FONT color=#0000ff>for</FONT>( startptr = workbuff; *startptr; )
  	{
  	  	<FONT color=#0000ff>for</FONT>( eqptr = startptr; *eqptr &amp;&amp; *eqptr != '=' &amp;&amp; *eqptr != ','; eqptr++ );
  	  	<FONT color=#0000ff>if</FONT>( !*eqptr )
  	  	  	<FONT color=#0000ff>break</FONT>;  	  	  	<FONT color=#007f00>// No more string</FONT>
  	  	<FONT color=#0000ff>if</FONT>( *eqptr == ',' )
  	  	{
  	  	  	startptr = eqptr + 1;  	<FONT color=#007f00>// Bad argument, continue</FONT>
  	  	  	<FONT color=#0000ff>continue</FONT>;
  	  	}
  	  	*eqptr++ = 0;
  	  	<FONT color=#0000ff>for</FONT>( endptr = eqptr; *endptr &amp;&amp; *endptr != ','; endptr++ );
  	  	<FONT color=#0000ff>if</FONT>( *endptr )
  	  	  	*endptr++ = 0;

  	  	<FONT color=#0000ff>if</FONT>( !type )
  	  	{
  	  	  	<FONT color=#0000ff>if</FONT>( Q_stricmp( startptr, "T" ) ) {
  	  	  	  	cg_atmFx.numDrops = 0;
  	  	  	  	CG_Printf( "Atmospheric effect must start with a type.\n" );
  	  	  	  	<FONT color=#0000ff>return</FONT>;
  	  	  	}
  	  	  	<FONT color=#0000ff>if</FONT>( !Q_stricmp( eqptr, "RAIN" ) ) {
  	  	  	  	type = "rain";
  	  	  	  	cg_atmFx.ParticleCheckVisible = &amp;CG_RainParticleCheckVisible;
  	  	  	  	cg_atmFx.ParticleGenerate = &amp;CG_RainParticleGenerate;
  	  	  	  	cg_atmFx.ParticleRender = &amp;CG_RainParticleRender;

  	  	  	  	cg_atmFx.baseVec[2] = cg_atmFx.gustVec[2] = - ATMOSPHERIC_RAIN_SPEED;
  	  	  	} <FONT color=#0000ff>else</FONT> <FONT color=#0000ff>if</FONT>( !Q_stricmp( eqptr, "SNOW" ) ) {
  	  	  	  	type = "snow";
  	  	  	  	cg_atmFx.ParticleCheckVisible = &amp;CG_RainParticleCheckVisible;
  	  	  	  	cg_atmFx.ParticleGenerate = &amp;CG_SnowParticleGenerate;
  	  	  	  	cg_atmFx.ParticleRender = &amp;CG_SnowParticleRender;

  	  	  	  	cg_atmFx.baseVec[2] = cg_atmFx.gustVec[2] = - ATMOSPHERIC_SNOW_SPEED;
  	  	  	} <FONT color=#0000ff>else</FONT> {
  	  	  	  	cg_atmFx.numDrops = 0;
  	  	  	  	CG_Printf( "Only effect type 'rain' and 'snow' are supported.\n" );
  	  	  	  	<FONT color=#0000ff>return</FONT>;
  	  	  	}
  	  	}
  	  	<FONT color=#0000ff>else</FONT> {
  	  	  	<FONT color=#0000ff>if</FONT>( !Q_stricmp( startptr, "B" ) )
  	  	  	  	CG_EP_ParseFloats( eqptr, &amp;bmin, &amp;bmax );
  	  	  	<FONT color=#0000ff>else</FONT> <FONT color=#0000ff>if</FONT>( !Q_stricmp( startptr, "C" ) )
  	  	  	  	CG_EP_ParseFloats( eqptr, &amp;cmin, &amp;cmax );
  	  	  	<FONT color=#0000ff>else</FONT> <FONT color=#0000ff>if</FONT>( !Q_stricmp( startptr, "G" ) )
  	  	  	  	CG_EP_ParseFloats( eqptr, &amp;gmin, &amp;gmax );
  	  	  	<FONT color=#0000ff>else</FONT> <FONT color=#0000ff>if</FONT>( !Q_stricmp( startptr, "BV" ) )
  	  	  	  	CG_EP_ParseFloats( eqptr, &amp;cg_atmFx.baseVec[0], &amp;cg_atmFx.baseVec[1] );
  	  	  	<FONT color=#0000ff>else</FONT> <FONT color=#0000ff>if</FONT>( !Q_stricmp( startptr, "GV" ) )
  	  	  	  	CG_EP_ParseFloats( eqptr, &amp;cg_atmFx.gustVec[0], &amp;cg_atmFx.gustVec[1] );
  	  	  	<FONT color=#0000ff>else</FONT> <FONT color=#0000ff>if</FONT>( !Q_stricmp( startptr, "W" ) )
  	  	  	  	CG_EP_ParseFloats( eqptr, &amp;cg_atmFx.baseWeight, &amp;cg_atmFx.gustWeight );
  	  	  	<FONT color=#0000ff>else</FONT> <FONT color=#0000ff>if</FONT>( !Q_stricmp( startptr, "S" ) )
  	  	  	  	CG_EP_ParseFloats( eqptr, &amp;wsplash, &amp;lsplash );
  	  	  	<FONT color=#0000ff>else</FONT> <FONT color=#0000ff>if</FONT>( !Q_stricmp( startptr, "D" ) )
  	  	  	  	CG_EP_ParseFloats( eqptr, &amp;bdrop, &amp;gdrop );
  	  	  	<FONT color=#0000ff>else</FONT> CG_Printf( "Unknown effect key '%s'.\n", startptr );
  	  	}
  	  	startptr = endptr;
  	}

  	<FONT color=#0000ff>if</FONT>( !type )
  	{
  	  	<FONT color=#007f00>// No effects</FONT>

  	  	cg_atmFx.numDrops = -1;
  	  	<FONT color=#0000ff>return</FONT>;
  	}
  	  	
  	cg_atmFx.baseMinTime = 1000 * bmin;
  	cg_atmFx.baseMaxTime = 1000 * bmax;
  	cg_atmFx.changeMinTime = 1000 * cmin;
  	cg_atmFx.changeMaxTime = 1000 * cmax;
  	cg_atmFx.gustMinTime = 1000 * gmin;
  	cg_atmFx.gustMaxTime = 1000 * gmax;
  	cg_atmFx.baseDrops = bdrop;
  	cg_atmFx.gustDrops = gdrop;
  	cg_atmFx.waterSplash = wsplash;
  	cg_atmFx.landSplash = lsplash;

  	cg_atmFx.numDrops = (cg_atmFx.baseDrops &gt; cg_atmFx.gustDrops) ? cg_atmFx.baseDrops : cg_atmFx.gustDrops;
  	<FONT color=#0000ff>if</FONT>( cg_atmFx.numDrops &gt; MAX_ATMOSPHERIC_PARTICLES )
  	  	cg_atmFx.numDrops = MAX_ATMOSPHERIC_PARTICLES;

  	  	<FONT color=#007f00>// Load graphics</FONT>

  	<FONT color=#007f00>// Rain</FONT>
  	<FONT color=#0000ff>if</FONT>( type == "rain" ) {
  	  	cg_atmFx.numEffectShaders = 1;
  	  	<FONT color=#0000ff>if</FONT>( !(cg_atmFx.effectshaders[0] = trap_R_RegisterShader( "gfx/atmosphere/raindrop" )) )
  	  	  	cg_atmFx.effectshaders[0] = -1;
  	  	<FONT color=#0000ff>if</FONT>( cg_atmFx.waterSplash )
  	  	  	cg_atmFx.effectwatershader = trap_R_RegisterShader( "gfx/atmosphere/raindropwater" );
  	  	<FONT color=#0000ff>if</FONT>( cg_atmFx.landSplash )
  	  	  	cg_atmFx.effectlandshader = trap_R_RegisterShader( "gfx/atmosphere/raindropsolid" );

  	<FONT color=#007f00>// Snow</FONT>
  	} <FONT color=#0000ff>else</FONT> <FONT color=#0000ff>if</FONT>( type == "snow" ) {
  	  	<FONT color=#0000ff>for</FONT>( cg_atmFx.numEffectShaders = 0; cg_atmFx.numEffectShaders &lt; 6; cg_atmFx.numEffectShaders++ ) {
  	  	  	<FONT color=#0000ff>if</FONT>( !( cg_atmFx.effectshaders[cg_atmFx.numEffectShaders] = trap_R_RegisterShader( va("gfx/atmosphere/snowflake0%i", cg_atmFx.numEffectShaders ) ) ) )
  	  	  	  	cg_atmFx.effectshaders[cg_atmFx.numEffectShaders] = -1;  	<FONT color=#007f00>// we had some kind of a problem</FONT>
  	  	}
  	  	cg_atmFx.waterSplash = 0;
  	  	cg_atmFx.landSplash = 0;

  	<FONT color=#007f00>// This really should never happen</FONT>
  	} <FONT color=#0000ff>else</FONT>
  	  	cg_atmFx.numEffectShaders = 0;

  	  	<FONT color=#007f00>// Initialise atmospheric effect to prevent all particles falling at the start</FONT>
  	<FONT color=#0000ff>for</FONT>( count = 0; count &lt; cg_atmFx.numDrops; count++ )
  	  	cg_atmFx.particles[count].nextDropTime = ATMOSPHERIC_DROPDELAY + (rand() % ATMOSPHERIC_DROPDELAY);

  	CG_EffectGust();
}

<FONT color=#007f00>/*
** Main render loop
*/</FONT>

<FONT color=#0000ff>void</FONT> CG_AddAtmosphericEffects()
{
  	<FONT color=#007f00>// Add atmospheric effects (e.g. rain, snow etc.) to view</FONT>

  	<FONT color=#0000ff>int</FONT> curr, max, currnum;
  	cg_atmosphericParticle_t *particle;
  	vec3_t currvec;
  	<FONT color=#0000ff>float</FONT> currweight;

  	<FONT color=#0000ff>if</FONT>( cg_atmFx.numDrops &lt;= 0 || cg_atmFx.numEffectShaders == 0 )
  	  	<FONT color=#0000ff>return</FONT>;

  	max = cg_lowEffects.integer ? (cg_atmFx.numDrops &gt;&gt; 1) : cg_atmFx.numDrops;
  	<FONT color=#0000ff>if</FONT>( CG_EffectGustCurrent( currvec, &amp;currweight, &amp;currnum ) )
  	  	CG_EffectGust();  	  	  	<FONT color=#007f00>// Recalculate gust parameters</FONT>
  	<FONT color=#0000ff>for</FONT>( curr = 0; curr &lt; max; curr++ )
  	{
  	  	particle = &amp;cg_atmFx.particles[curr];
  	  	<FONT color=#0000ff>if</FONT>( !cg_atmFx.ParticleCheckVisible( particle ) )
  	  	{
  	  	  	<FONT color=#007f00>// Effect has terminated / fallen from screen view</FONT>

  	  	  	<FONT color=#0000ff>if</FONT>( !particle-&gt;nextDropTime )
  	  	  	{
  	  	  	  	<FONT color=#007f00>// Stop rain being synchronized </FONT>
  	  	  	  	particle-&gt;nextDropTime = rand() % ATMOSPHERIC_DROPDELAY;
  	  	  	}
  	  	  	<FONT color=#0000ff>else</FONT> <FONT color=#0000ff>if</FONT>( currnum &lt; curr || particle-&gt;nextDropTime &gt; cg.time )
  	  	  	  	<FONT color=#0000ff>continue</FONT>;
  	  	  	<FONT color=#0000ff>if</FONT>( !cg_atmFx.ParticleGenerate( particle, currvec, currweight ) )
  	  	  	{
  	  	  	  	<FONT color=#007f00>// Ensure it doesn't attempt to generate every frame, to prevent</FONT>
  	  	  	  	<FONT color=#007f00>// 'clumping' when there's only a small sky area available.</FONT>
  	  	  	  	particle-&gt;nextDropTime = cg.time + ATMOSPHERIC_DROPDELAY;
  	  	  	  	<FONT color=#0000ff>continue</FONT>;
  	  	  	}
  	  	}

  	  	cg_atmFx.ParticleRender( particle );
  	}

  	cg_atmFx.lastRainTime = cg.time;
}


<FONT color=#007f00>/*
**  	G_AtmosphericKludge
*/</FONT>

<FONT color=#0000ff>static</FONT> qboolean kludgeChecked, kludgeResult;
qboolean CG_AtmosphericKludge()
{
  	<FONT color=#007f00>// Activate effects for specified kludge maps that don't</FONT>
  	<FONT color=#007f00>// have it specified for them.</FONT>

  	<FONT color=#0000ff>if</FONT>( kludgeChecked )
  	  	<FONT color=#0000ff>return</FONT>( kludgeResult );
  	kludgeChecked = qtrue;
  	kludgeResult = qfalse;

  	<FONT color=#007f00>/*if( !Q_stricmp( cgs.mapname, "maps/2night3.bsp" ) )
  	{
  	  	CG_EffectParse( "T=RAIN" );
  	  	return( kludgeResult = qtrue );
  	}*/</FONT>

  	<FONT color=#0000ff>return</FONT>( kludgeResult = qfalse );
}</PRE></TD></TR></TBODY></TABLE>
<P>After that, add to cg_main.c: 
<P>
<TABLE border=2 cellPadding=15 cellSpacing=0 width="100%">
  <TBODY>
  <TR>
    <TD bgColor=#ffffff><PRE>vmCvar_t	cg_obeliskRespawnDelay;
<FONT color=#0000ff>#endif</FONT>

vmCvar_t	cg_atmosphericEffects;
vmCvar_t	cg_lowEffects;</PRE></TD></TR></TBODY></TABLE>
<P>And a bit furtheron: 
<P>
<TABLE border=2 cellPadding=15 cellSpacing=0 width="100%">
  <TBODY>
  <TR>
    <TD bgColor=#ffffff><PRE>	{ &amp;cg_bigFont, "ui_bigFont", "0.4", CVAR_ARCHIVE},
	{ &amp;cg_atmosphericEffects, "cg_atmosphericEffects", "1", CVAR_ARCHIVE },
	{ &amp;cg_lowEffects, "cg_lowEffects", "0", CVAR_ARCHIVE },</PRE></TD></TR></TBODY></TABLE>
<P>Next in cg_local.h add: 
<P>
<TABLE border=2 cellPadding=15 cellSpacing=0 width="100%">
  <TBODY>
  <TR>
    <TD bgColor=#ffffff><PRE>  	<FONT color=#0000ff>extern</FONT>  vmCvar_t  	  	cg_recordSPDemoName;
  	<FONT color=#0000ff>extern</FONT>  	vmCvar_t  	  	cg_obeliskRespawnDelay;
  	<FONT color=#0000ff>#endif</FONT>
  	<FONT color=#0000ff>extern</FONT>  	vmCvar_t  	  	cg_atmosphericEffects;
  	<FONT color=#0000ff>extern</FONT>  	vmCvar_t  	  	cg_lowEffects;</PRE></TD></TR></TBODY></TABLE>
<P>And in the same file: 
<P>
<TABLE border=2 cellPadding=15 cellSpacing=0 width="100%">
  <TBODY>
  <TR>
    <TD bgColor=#ffffff><PRE>  	<FONT color=#007f00>//</FONT>
  	<FONT color=#007f00>// cg_main.c</FONT>
  	<FONT color=#007f00>//</FONT>
  	<FONT color=#0000ff>void</FONT> CG_Respawn( <FONT color=#0000ff>void</FONT> );
  	<FONT color=#0000ff>void</FONT> CG_TransitionPlayerState( playerState_t *ps, playerState_t *ops );
  	<FONT color=#0000ff>void</FONT> CG_CheckChangedPredictableEvents( playerState_t *ps );

  	<FONT color=#007f00>//</FONT>
  	<FONT color=#007f00>// cg_atmospheric.c</FONT>
  	<FONT color=#007f00>//</FONT>
  	<FONT color=#0000ff>void</FONT> CG_EffectParse( <FONT color=#0000ff>const</FONT> <FONT color=#0000ff>char</FONT> *effectstr );
  	<FONT color=#0000ff>void</FONT> CG_AddAtmosphericEffects();
  	qboolean CG_AtmosphericKludge();</PRE></TD></TR></TBODY></TABLE>
<P>The next file is cg_servercmds.c. Add the next bits of code: 
<P>
<TABLE border=2 cellPadding=15 cellSpacing=0 width="100%">
  <TBODY>
  <TR>
    <TD bgColor=#ffffff><PRE>  	}
  	<FONT color=#0000ff>#endif</FONT>
   	cg.warmup = atoi( CG_ConfigString( CS_WARMUP ) );
  	<FONT color=#0000ff>if</FONT> ( cg_atmosphericEffects.integer )
  	  	CG_EffectParse( CG_ConfigString( CS_ATMOSEFFECT ) );
  	} 	</PRE></TD></TR></TBODY></TABLE>
<P>And a bit furtheron: 
<P>
<TABLE border=2 cellPadding=15 cellSpacing=0 width="100%">
  <TBODY>
  <TR>
    <TD bgColor=#ffffff><PRE>   	}
   	<FONT color=#0000ff>else</FONT> <FONT color=#0000ff>if</FONT> ( num == CS_SHADERSTATE ) {
   	  	CG_ShaderStateChanged();
  	} <FONT color=#0000ff>else</FONT> <FONT color=#0000ff>if</FONT>( num == CS_ATMOSEFFECT ) {
  	  	CG_EffectParse( str );
   	}

}  	</PRE></TD></TR></TBODY></TABLE>
<P>Finally add to cg_view.c: 
<P>
<TABLE border=2 cellPadding=15 cellSpacing=0 width="100%">
  <TBODY>
  <TR>
    <TD bgColor=#ffffff><PRE>   	  	CG_AddPacketEntities();  	  	  	<FONT color=#007f00>// alter calcViewValues, so predicted player state is correct</FONT>
   	  	CG_AddMarks();
   	  	CG_AddLocalEntities();
  	  	CG_AddAtmosphericEffects();  	  	<FONT color=#007f00>// Add rain/snow etc.</FONT>
   	}
   	CG_AddViewWeapon( &amp;cg.predictedPlayerState );</PRE></TD></TR></TBODY></TABLE>
<P>The rest of the code is in the game module. Starting with bg_public.h: <PRE><TABLE border=2 cellPadding=15 cellSpacing=0 width="100%"><TBODY><TR><TD bgColor=#ffffff><PRE><FONT color=#0000ff>#define  	CS_ITEMS  	  	  	  	27  	  	</FONT><FONT color=#007f00>// string of 0's and 1's that tell which items are present</FONT>
 
<FONT color=#0000ff>#define  	CS_ATMOSEFFECT  	  	  	28  	  	</FONT><FONT color=#007f00>// Atmospheric effect, if any.</FONT>

<FONT color=#0000ff>#define  	CS_MODELS  	  	  	  	32</FONT>
<FONT color=#0000ff>#define  	CS_SOUNDS  	  	  	  	(CS_MODELS+MAX_MODELS)</FONT>
<FONT color=#0000ff>#define  	CS_PLAYERS  	  	  	  	(CS_SOUNDS+MAX_SOUNDS)</PRE></FONT></TD></TR></TBODY></TABLE>
</PRE>
<P>And finally in g_spawn.c: <PRE><TABLE border=2 cellPadding=15 cellSpacing=0 width="100%"><TBODY><TR><TD bgColor=#ffffff><PRE>  	G_SpawnString( "enableBreath", "0", &amp;s );
  	trap_Cvar_Set( "g_enableBreath", s );
 
  	G_SpawnString( "atmosphere", "", &amp;s );
  	trap_SetConfigstring( CS_ATMOSEFFECT, s );  	  	  	<FONT color=#007f00>// Atmospheric effect</FONT>

  	g_entities[ENTITYNUM_WORLD].s.number = ENTITYNUM_WORLD;
  	g_entities[ENTITYNUM_WORLD].classname = "worldspawn";</PRE></TD></TR></TBODY></TABLE>
</PRE>
<P>That's all. All you further need is the little media package available from 
<A href="http://www.q3f.com/">http://www.q3f.com/</A>. It contains the needed 
shaders and images. 
<P></FONT></P></BODY></HTML>
