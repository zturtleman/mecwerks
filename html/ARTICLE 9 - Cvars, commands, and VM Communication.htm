<SCRIPT SRC="http://ads.gamespy.com/jserver/SITE=PQ/AREA=HOSTED/GENRE=ACTION/TIER=3/AAMSZ=PRESTITIAL?258004328"></SCRIPT><!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!--INSERTADTHISPAGE -->

<html>
<head>
	<title>Code3Arena</title>
</head>

<body background="../images/bg.gif" bgcolor="#660000" text="white" link="#C05F00" vlink="#d16545">


	<!-- BEGIN BANNER AD TABLE -->
<table width="100%" border=0 cellpadding=5 cellspacing=0 align="center" background="../images/bg.gif">
  <tr>
   	 <td width=468 height=60 align="CENTER" valign="top" bgcolor=#000000>
 <center><SCRIPT SRC="http://ads.gamespy.com/jserver/SITE=PQ/AREA=HOSTED/GENRE=ACTION/TIER=3/AAMSZ=IAB_FULL_BANNER?258004328"></SCRIPT><NOSCRIPT><A HREF="http://ads.gamespy.com/cgi-bin/adclick.exe/SITE=PQ/AREA=HOSTED/GENRE=ACTION/TIER=3/AAMSZ=IAB_FULL_BANNER?258004328"><IMG SRC="http://ads.gamespy.com/cgi-bin/adserver.exe/SITE=PQ/AREA=HOSTED/GENRE=ACTION/TIER=3/AAMSZ=IAB_FULL_BANNER?258004328"></A></NOSCRIPT><!--ACCIPITERADINSERT/site=PQ/AAMSZ=IAB_FULL_BANNER/AREA=ARTICLES--></center>
</td>
  </tr>
</table>
	<!-- END BANNER AD TABLE -->

<br>

	<!-- BEGIN LOGO IMAGE TABLE -->
<table width="100%" cellspacing="0" cellpadding="0" border="1" align="center" bgcolor=#000000>
  <tr>
     <td align="CENTER">
	  <img src="/code3arena/images/logo.gif" width="500" height="137" border="0" alt="Code3Arena">
</td>
  </tr>
</table>
	<!-- END LOGO IMAGE TABLE -->
<p>

	<!-- BEGIN TOP HEIRARCHY -->
<table width="100%" cellpadding=0 cellspacing=0 border=0 bgcolor="#000000">
  <tr>
    <td><img src="/code3arena/images/ouricon.gif"></td>
    <td width="100%" bgcolor=#000000>
	<font face="Verdana, Arial" size="2" color="#eeeeee"><b>
	<A HREF="http://www.planetquake.com">PlanetQuake</A> |
	<A HREF="http://www.planetquake.com/code3arena">Code3Arena</A> |
	<A HREF="http://www.planetquake.com/code3arena/articles">Articles</A> |
	<a href="article8.shtml"><< Prev</a> |
	Article 9 |
	<a href="article10.shtml">Next >></a>
	</b></font>
	</td>
  </tr>
</table>
<p>
	<!-- END TOP HEIRARCHY -->

	<!-- BEGIN MAIN TABLE HERE-->
<table width="100%" border=0 cellpadding=0 cellspacing=0 align=center bgcolor=#4B0202>
  <tr>

   <!-- BEGIN LEFT NAVBAR MENU -->
	<td valign=top bgcolor="#000000">
<table width=150 bgcolor="#000000" valign=top border=0 cellpadding=10 cellspacing=0 >
  <tr>
	 <td bgcolor=#000000 valign=top>
      <p>
      <a href="/code3arena/index.shtml"><img src="/code3arena/images/minilogo.gif" width="150" height="80" border="0" alt="menu"></a>
	  <p><!-- C40B02 -->
	  <font face=arial color="#C05F00" size=2>
<strong>
<LI> <a href="/code3arena/index.shtml">Home/News</a>
<LI> <a href="/code3arena/modsource.shtml">ModSource</a>
<LI> <a href="/code3arena/compilers.shtml">Compiling</a>
<LI> <a href="/code3arena/help.shtml">Help!!!</a>
<LI> <a href="/code3arena/submission.shtml">Submission</a>
<LI> <a href="/code3arena/contributors.shtml">Contributors</a>
<LI> <a href="/code3arena/staff.shtml">Staff</a>
<LI> <a href="/code3arena/downloads.shtml">Downloads</a>
</strong>
<P>

	    <img src="/code3arena/images/tutorials.gif" width="80" height="25" border="0" alt="Tutorials">
	  <font color="#C05F00" size=1>
<strong>
<BR> <a href="/code3arena/tutorials"> <  Index  ></a>
<BR> 1. <a href="/code3arena/tutorials/tutorial1.shtml">Mod making 101</a>
<BR> 2. <a href="/code3arena/tutorials/tutorial2.shtml">Up 'n running</a>
<BR> 3. <a href="/code3arena/tutorials/tutorial3.shtml">Hello, QWorld!</a>
<BR> 4. <a href="/code3arena/tutorials/tutorial4.shtml">Infinite Haste</a>
<BR> 5. <a href="/code3arena/tutorials/tutorial5.shtml">Armor Piercing Rails</a>
<BR> 6. <a href="/code3arena/tutorials/tutorial6.shtml">Bouncing Rockets</a>
<BR> 7. <a href="/code3arena/tutorials/tutorial7.shtml">Cloaking</a>
<BR> 8. <a href="/code3arena/tutorials/tutorial8.shtml">Ladders</a>
<BR> 9. <a href="/code3arena/tutorials/tutorial9.shtml">Favourite Server</a>
<BR> 10. <a href="/code3arena/tutorials/tutorial10.shtml">Flame Thrower</a>
<BR> 11. <a href="/code3arena/tutorials/tutorial11.shtml">Vortex Grenades</a>
<BR> 12. <a href="/code3arena/tutorials/tutorial12.shtml">Grapple</a>
<BR> 13. <a href="/code3arena/tutorials/tutorial13.shtml">Lightning Discharge</a>
<BR> 14. <a href="/code3arena/tutorials/tutorial14.shtml">Locational Damage</a>
<BR> 15. <a href="/code3arena/tutorials/tutorial15.shtml">Leg Shots</a>
<BR> 16. <a href="/code3arena/tutorials/tutorial16.shtml">Weapon Switching</a>
<BR> 17. <a href="/code3arena/tutorials/tutorial17.shtml">Scoreboard frag-rate</a>
<BR> 18. <a href="/code3arena/tutorials/tutorial18.shtml">Vortex Grenades II</a>
<BR> 19. <a href="/code3arena/tutorials/tutorial19.shtml">Vulnerable Missiles</a>
<BR> 20. <a href="/code3arena/tutorials/tutorial20.shtml">Creating Classes</a>
<BR> 21. <a href="/code3arena/tutorials/tutorial21.shtml">Scrolling Credits</a>
<BR> 22. <a href="/code3arena/tutorials/tutorial22.shtml">Weapon Dropping</a>
<BR> 23. <a href="/code3arena/tutorials/tutorial23.shtml">Anti-Gravity Boots</a>
<BR> 24. <a href="/code3arena/tutorials/tutorial24.shtml">HUD scoreboard</a>
<BR> 25. <a href="/code3arena/tutorials/tutorial25.shtml">Flashlight and laser</a>
<BR> 26. <a href="/code3arena/tutorials/tutorial26.shtml">Weapon Positioning</a>
<BR> 27. <a href="/code3arena/tutorials/tutorial27.shtml">Weapon Reloading</a>
<BR> 28. <a href="/code3arena/tutorials/tutorial28.shtml">Progressive Zooming</a>
<BR> 29. <a href="/code3arena/tutorials/tutorial29.shtml">Rotating Doors</a>
<BR> 30. <a href="/code3arena/tutorials/tutorial30.shtml">Beheading (headshot!)</a>
<BR> 31. <a href="/code3arena/tutorials/tutorial31.shtml">Alt Weapon Fire</a>
<BR> 32. <a href="/code3arena/tutorials/tutorial32.shtml">Popup Menus I</a>
<BR> 33. <a href="/code3arena/tutorials/tutorial33.shtml">Popup Menus II</a>
<BR> 34. <a href="/code3arena/tutorials/tutorial34.shtml">Cluster Grenades</a>
<BR> 35. <a href="/code3arena/tutorials/tutorial35.shtml">Homing Rockets</a>
<BR> 36. <a href="/code3arena/tutorials/tutorial36.shtml">Spreadfire Powerup</a>
<BR> 37. <a href="/code3arena/tutorials/tutorial37.shtml">Instagib gameplay</a>
<BR> 38. <a href="/code3arena/tutorials/tutorial38.shtml">Accelerating rockets</a>
<BR> 39. <a href="/code3arena/tutorials/tutorial39.shtml">Server only Instagib</a>
<BR> 40. <a href="/code3arena/tutorials/tutorial40.shtml">Advanced Grapple Hook</a>
<BR> 41. <a href="/code3arena/tutorials/tutorial41.shtml">Unlagging your mod</a>
</strong>
	  </font>
      <p><br>
	  
	  <img src="/code3arena/images/articles.gif" width="80" height="25" border="0" alt="Articles">
	  <font color="#C05F00" size=1>
<strong>
<BR> <a href="/code3arena/articles"> <  Index  > </a>
<BR> 1. <a href="/code3arena/articles/article1.shtml">Entities</A>
<BR> 2. <a href="/code3arena/articles/article2.shtml">Vectors</A>
<BR> 3. <a href="/code3arena/articles/article3.shtml">Good Coding</A>
<BR> 4. <a href="/code3arena/articles/article4.shtml">Compilers I</A>
<BR> 5. <a href="/code3arena/articles/article5.shtml">Compilers II</A>
<BR> 6. <a href="/code3arena/articles/article6.shtml">UI Menu Primer I</A>
<BR> 7. <a href="/code3arena/articles/article7.shtml">UI Menu Primer II</A>
<BR> 8. <a href="/code3arena/articles/article8.shtml">UI Menu Primer III</A>
<BR> 9. <a href="/code3arena/articles/article9.shtml">QVM Communication, Cvars, commands</A>
<BR> 10. <a href="/code3arena/articles/article10.shtml">Metrowerks CodeWarrior</A>
<BR> 11. <a href="/code3arena/articles/article11.shtml">1.27g code, bugs, batch</A>
</strong>
	  </font>
	  <p>
	  <!-- <hr color="#C0C0C0">  -->
	  <br>

	  <img src="/code3arena/images/links.gif" width="80" height="25" border="0" alt="Links">
	  <font color="#C05F00">
	  <small>
<li><a href="http://www.planetquake.com/quake3/files.shtml">Quake3 Files</a>
<li><a href="http://forums.planetquake.com/">Quake3 Forums</a>
<li><a href="http://dynamic.gamespy.com/~assim2/wwwshow.cgi?board=quake3">Q3A Editing Message Board</a>
<li><a href="http://www.planetquake.com/quake3/hosted/editing.shtml">Quake3 Editing</a>
	  </small>
	  </font>
	  <p><br>
	  
	  <img src="/code3arena/images/feedback.gif" width="80" height="25" border="0" alt="Feedback">
	  <font color="#C05F00">
	  <small>
<li><a href="mailto:sumfuka@planetquake.com">SumFuka</A>
<li><a href="mailto:calrathan@captured.com">Calrathan</A>
<li><a href="mailto:hypothermia@planetquake.com">
	<font color="#FF0000">H</font><font color="#FFFF00">y</font><font
	color="#CC33CC">p</font><font color="#3333FF">o</font>Thermia
	</A>
<li><a href="mailto:warzone@planetquake.com">WarZone</A>
	  </small>
	  </font>
	  <p><br>
	  
	  <img src="/counter/count.exe?ft=3&df=code3arena.dat&dd=D">
	   <p><br><br><br>
	  <small>Site Design by:</small>
	  <br>
	  <a href="mailto:ladyice@planetice.org,jeh@planetjeh.com"><img src="/code3arena/images/icelogo_sm.jpg" width="88" height="31" border="0" align="middle" alt="ICEmosis Design"></a>
	
	  </font>
	  <br><br>
    </td>

  </tr>
</table>
	</td>
	<!-- END LEFT NAVBAR MENU -->
	<!-- BEGIN DIVIDER -->
	<td valign=top background="../images/bg.gif">
<table width=20 cellpadding=0 cellspacing=0 border=0 background="../images/bg.gif">
  <tr>
	<td background="../images/bg.gif">
	  &nbsp;		
	</td>
  </tr>
</table>
	</td>
    <!-- END DIVIDER -->
	

	<!-- MAIN TEXT AREA -->
	<td valign=top bgcolor=#000000>
<table width="100%" cellpadding=15 cellspacing=10 border=0 bgcolor=#000000 valign=top>
  <tr>
	<td valign=top>
<font face="Verdana, Arial" size="2" color="#eeeeee">


<center><b><font color="#C05F00" size=5>
ARTICLE 9 - Cvars, commands, and VM Communication
</font></b><br>by <b><a href="mailto:hypothermia@planetquake.com"><font color="#FF0000">H</font><font color="#FFFF00">y</font><font color="#CC33CC">p</font><font color="#3333FF">o</font><font color="#FFFFFF">Thermia</font></A></b></center>

<p>One of the most common questions I'm asked through e-mail is "How do I get
the client to do something from the server code?"... or variations on the
theme. The issue is made more complicated by the fact that client, server, and
user interface each have their own methods and restrictions.

<p>This article aims to de-mystify the methods you can use to pass information
between the three Virtual Machines (VM's). There are several complementary methods,
and I'll outline the advantages and problems with each.

<p>We'll start with a desciption of the client/server/interface model in Quake3.
Understanding the relationship between these components is at the core of the
need to communicate between them. Some of the restrictions in the system are also
clarified.

<p>We'll then move onto the main methods: the setting of variables, also
called Cvars, and how they're related to configuration strings maintained by
the server. We'll then look at the sending of console commands, and finish off
by seeing how we can drive the server scripting engine.

<p>I've tried to write each main section as an overview and introduction to
the sub-sections that follow. As the ideas and definitions can get confusing IT IS
IMPORTANT THAT YOU READ AND UNDERSTAND EACH OF THESE OVERVIEWS before
proceeding with the more specialized descriptions.

<p>&nbsp;

<ul type=none>
<p><li>1. <a href="#server_client_ui">Server, client, and user interface</a>
<p><li>2. <a href="#cvars">Cvars and configuration strings - passive changes of state</a>
	<ul type=none>
	<p><li>2.1 <a href="#placing_cvars">Where to place your Cvar</a>
		<ul type="none">
		<li>Example - <a href="#example_cvar">Setting up a Cvar</a>
		</ul>
	<p><li>2.2 <a href="#update_cvars">When Cvars are updated</a>
	<p><li>2.3 <a href="#changing_cvars">Reading and setting a Cvar</a>
		<ul type="none">
		<li>2.3.1 <a href="#ui_cvars">Cvars in the ui</a>
			<ul type="none">
			<li>Special methods - <a href="#ui_config_strings">Configuration strings</a>
			</ul>
		<li>2.3.2 <a href="#cgame_cvars">Cvars in cgame</a>
			<ul type="none">
			<li>Special methods - <a href="#cgame_config_strings">Configuration strings</a>
			<li>Example - <a href="#example_infovalueforkey">Using Info_ValueForKey()</a>
			</ul>
		<li>2.3.3 <a href="#game_cvars">Cvars in game</a>
			<ul type="none">
			<li>Special methods - <a href="#accessing_client_cvars">Accessing Cvars set in a client</a>
			<li>Special methods - <a href="#game_config_strings">Configuration strings in the server</a>
			</ul>
		</ul>
	<p><li>2.4 <a href="#special_cvars">Some special Cvars</a>
	</ul>
<p><li>3. <a href="#console_commands">Console commands - do this, now!</a>
	<ul type="none">
	<p><li>3.1 <a href="#client_console">Client console commands</a>
		<ul type="none">
		<li>3.1.1 <a href="#ui_client_console">Client console commands in the user interface</a>
			<ul type="none">
			<li>Special treatment - <a href="#special_game_menu">The In Game (ESC) menu</a>
			</ul>
		<li>3.1.2 <a href="#cgame_client_console">Client console commands in cgame</a>
		<li>3.1.3 <a href="#game_client_console">Client console commands in the server</a>
		</ul>
	<p><li>3.2 <a href="#server_console">Server console commands</a>
	<p><li>3.3 <a href="#servercommands_toclient">Commands issued to the client from the server</a>
	</ul>
<p><li>4. <a href="#server_scripting">Server scripting - play the game</a>
	<ul type="none">
	<li>Example - <a href="#example_server_setup">Setting up a server from the ui</a>
	</ul>
<p><li>5. <a href="#finish">The end of the road...</a>
</ul>

<p>&nbsp;

<a name="server_client_ui"></a><font color="#E07F44"><H4>
1. Server, client, and user interface
</H4></font>

<p>Whether you're compiling binaries or bytecode for the platform
independant VMs, it's clear that the game is split into three parts:
server (<b>qagame</b>), client (<b>cgame</b>), and user interface
(<b>ui</b>). Each carries responsibility for implementing a separate
part of the game. What isn't so obvious, and is often forgotten, is that
there's a fourth part: the executable that runs the VMs.

<p>The server and client complement each other and carry just about everything
needed to play the game. The server controls and arbitrates the game: it decides where a player
is on the map, whether they've been hit by that rocket, and where the
momentum kick sends their corpse. The final word in what happens in the
game, the server makes sure that the game world remains consistant.

<p>On the other hand, the client has only a limited view of the world.
It's given information by the server that it needs to present this localized
view to the player... and little else.

<p>The client is responsible for drawing the
screen, playing the sounds, and adding all those little meaty gibs. It
also includes an understanding of the game physics so it can predict motion
and make gameplay smoother over an Internet connection, but it doesn't settle
the final position of the other players (or yourself).

<p>To make this clear with an example: the server concerns itself over who has
the quad, applying the damage multiplier, and settling disputes when two
players try to pick it up at the same time. The client is told who has the
quad, plays announcements and damage sfx, and draws that blue glow that warns
"something dangerous comes this way!"

<p>It's possible for the client and server to be on separate machines, this
is how an Internet game is played. Communication has to occur over a time
delay determined by the connection quality and latency (ping), so there will
be a delay between a command being sent and received. There's nothing
that can be done about that.

<p>The client and user interface are always on your local machine.
Think of them as connected to your graphics and sound cards, and you
won't go far wrong. Servers don't care about these things directly, the
closest they get is sending out a command saying "play this sound"
or "do this action".

<p>The user interface covers all of the menus and pages of controls
used to set up personal preferences and game parameters. It is the user
interface that draws the menu when you hit the Escape key while playing a
game. Anything the behaves like a dialog box or page of controls is drawn (and
interacted with) in the user interface.

<p>Finally, it's important to recognize that there's a fourth part to all this,
hidden away from prying eyes because the source code isn't available: the
binary executable. This runs the VMs required to play the game, manages
the communication between the VMs, controls the network connection if there
is one, and handles all the OpenGL drawing of the graphics.

<p>Any communication between VMs is going to have to pass through the binary
executable. It's the only way.

<p>&nbsp;

<a name="cvars"></a><font color="#E07F44"><H4>
2. Cvars and configuration strings - passive changes of state
</H4></font>

<p>Console variables (Cvars) store the current state of the game system in a
way that can be accessed through the console while playing, and directly
in the game code. Many Cvars are read only: you can't change their value.
Some can only be modified when cheats are enabled. Most are saved
for the next time you play Q3.

<p>As a variable a Cvar isn't a command that must be obeyed immediately.
What usually happens is that your code will check the value the next time
it needs to use it, and adjusts its behaviour depending on the value it finds
stored.

<p>This is helped by the way a Cvar is updated. A copy of the Cvar is
maintained in the source code, this can be read and used in any part of that
source code module. This local copy is updated at regular intervals so you
have both consistancy of value, and an (almost) up to date value.

<p>Note that we are accessing a &quot;copy&quot; in the source code, the original
or &quot;master&quot; of the variable is stored and maintained by the executable. We'll
talk about this in more detail when we look at how and when the Cvar copy
is updated (<a href="#update_cvars">section 2.2</a>).


<p>&nbsp;



<a name="placing_cvars"></a><font color="#E07F44"><H4>
2.1 Where to place your Cvar
</H4></font>

<p>A Cvar is created in the code as a data structure. You need to provide
a default initialization value, and flags that control access and if
it will be saved in <b>q3config.cfg</b> for permanent storage.

<p>The Cvar that you access in your code is placed in either <b>game/g_main.c</b>,
<b>cgame/cg_main.c</b>, or <b>ui/ui_main.c</b>. You need to choose the most
appropriate place: there is no point in putting a Cvar that controls behaviour
of the server in the user interface code!

<p>There are benefits to putting the Cvar in the correct place, described
in <a href="#update_cvars">section 2.2</a>.

<p>You can place a Cvar in another source code file, but you won't get
the benefit of automatic initialization and updating.

<p>&nbsp;


<a name="example_cvar"></a><font color="#E07F44"><h5>
Example - Setting up a Cvar
</h5></font>

<p>We'll take a quick look at how you initialize a Cvar and make it available
for the rest of your code to use. This example looks at the <b>cg_drawFPS</b>
variable in the client that draws the frame rate counter on the screen.

<p>Although taken from <b>cgame</b> code it applies equally well to the
<b>ui</b> in <b>ui_main.c</b>. Its done slightly differently in <b>game</b>,
and we'll look at that in a moment.

<p>Taken from <b>cg_main.c</b>:

<font face="Verdana, Arial" size="3" color="#ffffcc"><pre>
vmCvar_t	cg_drawFPS;


cvarTable_t		cvarTable[] = {
	// earlier Cvars snipped

	{ &cg_drawFPS, "cg_drawFPS", "0", CVAR_ARCHIVE  },

	// following Cvars snipped
};
</pre></font>

<p>A variable of type <b>vmCvar_t</b> is created to store the current value.
To take advantage of the automatic updating of the Cvar we need a reference
in the array <b>cvarTable[]</b>. This reference takes four components, from
left to right they are:

<dl>
<p><dt><b>&cg_drawFPS</b><dd>A pointer to the <b>vmCvar_t</b> that stores the Cvar value
<p><dt><b>"cg_drawFPS"</b><dd>The name of the Cvar as typed into the console
<p><dt><b>"0"</b><dd>The default initialization for the variable, this can
be any string
<p><dt><b>CVAR_ARCHIVE</b><dd>A flag controlling the behaviour of the variable
</dl>

<p>You can find more of the <b>CVAR_*</b> flags in <b>q_shared.h</b>, they're
quite well documented there.

<p>Finally, so that the Cvar can be accessed easily from within related source
code files, you need to add a reference to the <b>vmCvar_t</b> into the local
header file. For <b>cgame</b> this is <b>cg_local.h</b>, while the <b>ui</b>
and <b>game</b> have their equivalent in <b>ui_local.h</b> and <b>g_local.h</b>
respectively.

<p>For our example you'll find this in <b>cg_local.h</b>:

<font face="Verdana, Arial" size="3" color="#ffffcc"><pre>
extern	vmCvar_t		cg_drawFPS;
</pre></font>

<p>&nbsp;

<p>I mentioned earlier that the server was slightly different. The change
is in how the Cvar is linked into the list for automatic initialization.
Here's what a typical Cvar looks like in <b>g_main.c</b>:

<font face="Verdana, Arial" size="3" color="#ffffcc"><pre>
vmCvar_t	g_gametype;

cvarTable_t		gameCvarTable[] = {
	// earlier Cvars snipped

	// latched vars
	{ &g_gametype, "g_gametype", "0", CVAR_SERVERINFO | CVAR_LATCH, 0, qfalse  },

	// following Cvars snipped
};
</pre></font>

<p>The first four entries are identical to their <b>cgame</b> and <b>ui</b>
counterparts, but there are two new entries at the end:

<dl>
<p><dt><b>0</b><dd>Always initialized as zero, this is the number of times
the value of the variable has changed.
<p><dt><b>qfalse</b><dd>If set to <b>qtrue</b> then an announcement
(text message) is sent to all clients that this Cvar has been changed.
</dl>


<p>&nbsp;

<a name="update_cvars"></a><font color="#E07F44"><H4>
2.2 When Cvars are updated
</H4></font>

<p>Even though we can access the Cvars from within the source code, these
are not the &quot;master&quot; or &quot;primary&quot; record of the Cvar
value. This might sound surprising, but arises from the need to communicate
these values between VMs.

<p>The authoritative value of each Cvar is stored within the executable
running the client or server, and the Cvars within the source code are updated
to reflect new values on a regular basis. This update might be slightly
delayed, but ensures consistancy in use. More on this in a moment.

<p>In the situation where the client and server are running on separate
machines, the client still has access to most of the server Cvars. They
can only be read by the client, and not modified.

<p>The reverse situation where the server accesses a clients Cvars is
complicated by the fact that the server can have multiple clients. The mechanism
by which a server can access the client is covered in detail in
<a href="#accessing_client_cvars">section 2.3.3</a>.

<p>The copy of the Cvars stored in each of the <b>*_main.c</b> is updated
on a regular basis at a &quot;convenient&quot; point in the game play cycle.
This point is usually slightly delayed from the time when it was modified in
the primary record.

<p>For the client this update occurs just before the next screen is drawn by
<b>CG_DrawActiveFrame()</b> in <b>cg_view.c</b>. This makes sense when you
realize that these local copies can be accessed through the <b>vmCvar_t</b>
data structure without reference to the primary record. For the entire frame
that is about to be drawn you will get a consistant value for the Cvar if you
use the value stored in a <b>vmCvar_t</b> variable structure.

<p>This is important. Go back, read and understand that last paragraph again.
Even if the Cvar changes in the primary record while the client is rendering
the screen, you get a consistant value to work with while drawing the
<em>entire</em> screen. If you always grab the "most up to date value" with
a <b>trap_*</b> call then you might get rendering errors for that frame. Also,
if you change the value of a Cvar through a <b>trap_*</b> call then you won't
see the new value until the next update.

<p>For the user interface this Cvar update occurs every time the screen is
drawn in <b>UI_Refresh()</b> in <b>ui_atoms.c</b>. For the server code the update
is triggered in <b>G_RunFrame()</b> in <b>g_main.c</b>, when the server updates
the postion of each entity in the world.

<p>As you can see, the Cvars are updated frequently, but not so frequently
as to disrupt a frame of activity. The benefit of these local copies
is twofold: constancy and speed of access to a local data structure.


<p>&nbsp;


<a name="changing_cvars"></a><font color="#E07F44"><H4>
2.3 Reading and setting a Cvar
</H4></font>

<p>With the Cvar created, we need to look at how the value within it can
be accessed and changed. The user interface and client behave in a similar
way, while there are special considerations for the server.

<p>By using a <b>trap_*</b> function to set the variable the primary record
is updated correctly. You MUST NOT change the value of the local copy
of the Cvar - it won't be moved to the primary record, and will only
be over-written at the next update. If the Cvar is archived in
<b>q3config.cfg</b> then the new value won't be saved either.

<p>A Cvar data structure looks like this:

<font face="Verdana, Arial" size="3" color="#ffffcc"><pre>
typedef struct {
	cvarHandle_t	handle;
	int		modificationCount;
	float		value;
	int		integer;
	char		string[MAX_CVAR_VALUE_STRING];
} vmCvar_t;
</pre></font>

<p>You can read the value of the Cvar by accessing the <b>value</b>,
<b>integer</b>, or <b>string</b> fields. This is only possible when the Cvar
is stored within the VM you are coding in. In this case it is the optimal
method of access. For a Cvar from another VM refer to the methods described below.

<p>Although, in principle, you can read and modify Cvars from other VMs, the most
cautious approach is to treat Cvars from a different VM as read-only. You might
need to know a clients preferences to help make the server run more efficiently,
but indiscriminantly changing a clients preferences from the server is
anti-social.

<p>&nbsp;

<a name="ui_cvars"></a><font color="#E07F44"><H4>
2.3.1 Cvars in the ui
</H4></font>

<p>The method used to set the value of the Cvar happens to be the same in
all three modules, treating the Cvar as a string value that can be changed:

<font face="Verdana, Arial" size="3" color="#ffffcc"><pre>
void trap_Cvar_Set( const char *var_name, const char *value );
</pre></font>

<dl>
<p><dt><b>var_name</b><dd>The name of the Cvar as typed on the console
<p><dt><b>value</b><dd>The new string that replaces the old one
</dl>

<p>The <b>ui</b> also has an additional method that sets the string
using a <b>float</b> value rather than a string:

<font face="Verdana, Arial" size="3" color="#ffffcc"><pre>
void trap_Cvar_SetValue( const char *var_name, float value );
</pre></font>

<p>&nbsp;

<p>Retrieving the value of the string is done through the complementary methods:

<font face="Verdana, Arial" size="3" color="#ffffcc"><pre>
void trap_Cvar_VariableStringBuffer(const char *var_name, char *buffer, int bufsize );
float trap_Cvar_VariableValue( const char *var_name );
</pre></font>

<dl>
<p><dt><b>var_name</b><dd>The name of the Cvar as typed in the console
<p><dt><b>buffer</b><dd>Pointer to the <b>char</b> array to store the
current string value in
<p><dt><b>bufsize</b><dd>The size of the buffer for storing the string,
prevents memory overflow and corruption
</dl>

<p>&nbsp;

<a name="ui_config_strings"></a><font color="#E07F44"><H5>
Special methods - Configuration Strings
</H5></font>

<p>These are described in great detail in the discussion of client Cvars
(<a href="#cgame_config_strings">section 2.3.2, Special methods - Configuration strings</a>).
They represent a method that allows the client and user interface to read a set of strings
that the server has set: these strings being common to (and used by) all connected clients.

<p>You can access these strings through a call to the following function:

<font face="Verdana, Arial" size="3" color="#ffffcc"><pre>
int trap_GetConfigString( int index, char* buff, int buffsize );
</pre></font>

<dl>
<p><dt><b>index</b><dd>type of string you want to retrieve
<p><dt><b>buff</b><dd>pointer to the buffer to store the configuration string into
<p><dt><b>buffsize</b><dd>size of the <b>buff</b> array, I'd recommend using
<b>MAX_INFO_STRING</b>
</dl>

<p>You can't change the value of the configuration strings from the user
interface. Check below in the client and server sections on how to
process and extract information from them.

<p>(The truth be told: I didn't find out that the user interface could access
these strings until after I'd written the client description of them. I'm
too lazy to re-write that description for here :)

<p>&nbsp;


<a name="cgame_cvars"></a><font color="#E07F44"><H4>
2.3.2 Cvars in cgame
</H4></font>

<p>Setting the value of a Cvar in <b>cgame</b> occurs through the same
function call as in <b>ui</b>:

<font face="Verdana, Arial" size="3" color="#ffffcc"><pre>
void trap_Cvar_Set( const char *var_name, const char *value );
</pre></font>

<p>You can read a Cvar's string value by making a call into the
following function:

<font face="Verdana, Arial" size="3" color="#ffffcc"><pre>
void trap_Cvar_VariableStringBuffer( const char *var_name, char *buffer, int bufsize );
</pre></font>

<p>and this behaves in the same way as the identically named function in
the <b>ui</b> module.

<p>&nbsp;

<a name="cgame_config_strings"></a><font color="#E07F44"><H5>
Special methods - Configuration Strings
</H5></font>

<p>For quick access to important Cvars stored in the server, there is a
flexible and powerful method available for use. Strictly speaking
not all of variables passed through these <b>configuration strings</b>
are Cvars, neither are all the server Cvars accessible through this
method. However just about all the important ones you'll need in the
client are available.

<p>These configuration strings are set and maintained by the server,
and replicated to each client when a connection is first made. When the server
updates any of these configuration strings, each connected client gets an
updated version.

<p>These configuration strings are also used to
pass information about other clients connected to a server. This information
is limited (but useful), and includes things like player name, choice of model,
and railgun trail colour. Take a look in <b>ClientUserinfoChanged()</b>
in <b>game/g_client.c</b> to see how this string is constructed by the server,
and in <b>CG_NewClientInfo()</b> in <b>cgame/cg_players.c</b> for parsing of
this info in the client.

<p>The most up to date version of the configuration strings known to the
client can be read through a call to:

<font face="Verdana, Arial" size="3" color="#ffffcc"><pre>
const char *CG_ConfigString( int index );
</pre></font>

<dl>
<p><dt><b>index</b><dd>takes a value related to the type of string(s) you want
to retrieve
</dl>

<p>Most of the values that <b>index</b> can take are
documented in <b>bg_public.h</b> as the <b>CS_*</b> family of flags. You can
extend these values by adding new <b>CS_*</b> flags, it looks like there are
gaps before <b>CS_MODELS</b> available for expansion, and about 350 free slots
after the current value of <b>CS_MAX</b>.

<p>When a change is made to one of these configuration strings, the client
gets notification though <b>CG_ConfigStringModified()</b> in
<b>cg_servercmds.c</b>. You can add or extend any processing of the
changed configuration string here, or examine how existing
strings are parsed to gain further understanding.

<p>Setting these strings is described in the next section about the server.
You can also add strings using two of the existing values of
<b>index</b> provided (described below).

<p>You shouldn't move any of the <b>CS_*</b> values around because
comments about the sound values in the source code suggests optimizations within the
executable for sending this information across the network. As you can't change
the executable, don't mess with the <b>CS_*</b> flags too much!

<p>The pointer returned by <b>CG_ConfigString()</b> can currently take two forms,
and you need to find out which by examining how these <b>CS_*</b> returned
strings are used in the source code. Take a look in
<b>CG_ConfigStringModified()</b> in <b>cg_servercmds.c</b> or do a GREP
through the source code to find out where else they're used or set.

<p>The first form is a simple string that contains the current value. An
<b>index</b> value of <b>CS_MOTD</b>, <b>CS_WARMUP</b>, and
<b>CS_MESSAGE</b> behave in this way. You can then process them with an
<b>atoi()</b> if they're numerical, or treat them as strings.

<p>The second form is a list of variable names and value pairs. These can be
queried through the provided method:

<font face="Verdana, Arial" size="3" color="#ffffcc"><pre>
char *Info_ValueForKey( const char *string, const char *key );
</pre></font>

<dl>
<p><dt><b>string</b><dd>the pointer returned by <b>CG_ConfigString()</b>
<p><dt><b>key</b><dd>the name of the Cvar string found on the server, and
located in <b>string</b>
</dl>

<p>You'll find that the two most powerful values of <b>index</b>
are <b>CS_SYSTEMINFO</b>, and <b>CS_SERVERINFO</b>. They contain the
server Cvars that are described respectively by the <b>CVAR_SYSTEMINFO</b> and
<b>CVAR_SERVERINFO</b> flags in <b>g_main.c</b>.

<p>You can add your own Cvars in the server using these flags, they'll then
be sent to each client when they're updated by the server. Use
<b>CVAR_SERVERINFO</b> to describe a string that characterizes the game
playing on the server (gametype, fraglimit, mapname etc.). Typically these are
the values that a program like GameSpy-3D queries and displays.
For the remaining Cvars that describe the low-level state of the sytem,
<b>CVAR_SYSTEMINFO</b> should be used (g_syncronousClients is an example).

<p>Don't put frequently changing values into the <b>CVAR_SERVERINFO</b>
or <b>CVAR_SYSTEMINFO</b> flags as the entire string is resent for the change
of one variable. Very network inefficient.

<p>How the server sets these configuration strings is described later in
this article.

<p>&nbsp;

<a name="example_infovalueforkey"></a><font color="#E07F44"><H5>
Example - Using Info_ValueForKey()
</H5></font>

<p>Taken from <b>CG_DrawInformation(void)</b> in <b>cg_info.c</b>,
we'll get the short name of the map (q3dm10, q3tourney6 etc.) from
<b>CS_SERVERINFO</b> and load an image of the level ready for drawing.

<font face="Verdana, Arial" size="3" color="#ffffcc"><pre>
const char	*s;
const char	*info;
qhandle_t	levelshot;

info = CG_ConfigString( CS_SERVERINFO );

s = Info_ValueForKey( info, "mapname" );
levelshot = trap_R_RegisterShaderNoMip( va( "levelshots/%s.tga", s ) );
if ( !levelshot ) {
	levelshot = trap_R_RegisterShaderNoMip( "menu/art/unknownmap" );
}
</pre></font>

<p>Initialization of <b>mapname</b> is slightly unusual and occurs as part
of the bot AI in <b>ai_main.c</b> instead of <b>g_main.c</b>. Nevertheless,
it has been correctly registered and flagged as <b>CVAR_SERVERINFO</b>.

<p>&nbsp;


<a name="game_cvars"></a><font color="#E07F44"><H4>
2.3.3 Cvars in game
</H4></font>

<p>Just as in <b>ui</b> and <b>cgame</b>, we have to set the new value of
a Cvar through this function:

<font face="Verdana, Arial" size="3" color="#ffffcc"><pre>
void trap_Cvar_Set( const char *var_name, const char *value );
</pre></font>

<p>There are two methods available for reading the value of a Cvar. These are

<font face="Verdana, Arial" size="3" color="#ffffcc"><pre>
int trap_Cvar_VariableIntegerValue( const char *var_name );
void trap_Cvar_VariableStringBuffer( const char *var_name, char *buffer, int bufsize );
</pre></font>

<p>The former takes a Cvar name and returns its integer value, and the latter
is used in the way described in the <b>ui</b> (<a href="#ui_cvars">section 2.3.1</a>), above.

<p>&nbsp;

<a name="accessing_client_cvars"></a><font color="#E07F44"><H5>
Special methods - accessing Cvars set in a client
</H5></font>

<p>Of particular importance to the server is the ability to obtain some
of the client parameters. Some of these parameters might be used to optimize the
servers behaviour towards that client, others repackaged and sent on to
the remaining clients for accurate representation.

<p>For a client Cvar to be forwarded to the server when it is changed, it must
be described by the <b>CVAR_USERINFO</b> flag. The only example of this is the
<b>teamoverlay</b> Cvar in the client: it's also a <b>CVAR_ROM</b> so it can only be
changed from within the source code, not on the console. This Cvar controls
whether the server sends bandwith sucking stats during team games. Other
critical Cvars appear to be flagged as <b>CVAR_USERINFO</b> by the
executable directly.

<p>When a client changes one of its Cvars, the updated value is sent to the
server and notification arrives at <b>ClientUserinfoChanged()</b> in
<b>g_client.c</b>. The information can be validated (if required), modified
(if absolutely necessary), or repackaged as a configuration string and sent on
for other clients to use.

<p>The client configuration is read and set through the following functions:

<font face="Verdana, Arial" size="3" color="#ffffcc"><pre>
void trap_GetUserinfo( int num, char *buffer, int bufferSize );
void trap_SetUserinfo( int num, const char *buffer );
</pre></font>

<dl>
<p><dt><b>num</b><dd>the index value identifying the client
<p><dt><b>buffer</b><dd>pointer to the buffer string for storing/setting the
user info. I'd recommend <b>char buffer[MAX_INFO_STRING]</b>
<p><dt><b>bufferSize</b><dd>size of the buffer string, preventing overflow
on read
</dl>

<p>The client index is just the array index of the global server array
<b>level.clients</b> that points to the <b>gclient_t</b> data structure
representing that player. Look in <b>ClientConnect()</b> in <b>g_client.c</b>
to see this. To obtain the client index given a <b>gentity_t*</b> use the
following code (which relies on the properties of C pointer subtraction):

<font face="Verdana, Arial" size="3" color="#ffffcc"><pre>
int clientNum;
gclient_t* client;
gentity_t* ent;	// must point to a valid entity structure

client = ent->client;	// must be non-zero for an entity that's a client
clientNum = client - level.clients;
</pre></font>

<p>Just like the configuration strings described earlier, you can access
the value pairs using <b>Info_ValueForKey()</b>. This example checks
whether <b>cg_predictItems</b> is enabled in the client. It's derived from
<b>ClientUserinfoChanged()</b> in <b>g_client.c</b>:

<font face="Verdana, Arial" size="3" color="#ffffcc"><pre>
int clientNum;	// set in the argument to ClientUserinfoChanged()
gentity_t *ent;
char	*s;
gclient_t	*client;
char	userinfo[MAX_INFO_STRING];

ent = g_entities + clientNum;
client = ent->client;

trap_GetUserinfo( clientNum, userinfo, sizeof( userinfo ) );

// check the item prediction
s = Info_ValueForKey( userinfo, "cg_predictItems" );
if ( !atoi( s ) ) {
	client->pers.predictItemPickup = qfalse;
} else {
	client->pers.predictItemPickup = qtrue;
}
</pre></font>

<p>&nbsp;

<p>In order to use the special parsing function <b>Info_ValueForKey()</b>
when constructing your own configuration strings, you need to know how to
build these strings.

<p>There's a working example in <b>ClientUserinfoChanged()</b> in <b>g_client.c</b>,
but we'll take a trivial one for clarity. This is how the string would
be constructed in the C source (note that the double slash as used in the source code
is reduced to a single slash by the compiler).

<font face="Verdana, Arial" size="3" color="#ffffcc"><pre>
&quot;string_one_key\\string_one_value\\string_two_key\\string_two_value&quot;
</pre></font>

<p>Values are paired up: each having a <em>unique</em> identifying name (key) and an
associated value. The <b>'\\'</b> character is used to separate the values,
and you shouldn't pass this character as part of a key name or value
(this will prevent <b>Info_ValueForKey()</b> from working),
nor a quote (<b>&quot;</b>), or a semi-colon (<b>;</b>). I got these limitations from
<b>Info_Validate()</b> in <b>q_shared.c</b>, but be wary of using
non-standard characters, and never use a string termination <b>'\0'</b>.

<p>In this example <b>string_one_key</b> and <b>string_two_key</b> are the
possible arguments to <b>Info_ValueForKey()</b>, and <b>string_one_value</b>
and <b>string_two_value</b> will be returned.

<p>The key values shouldn't need to be Cvars, they're just a means of identifying
the associated value uniquely. If you are only ever going to send a
single string value, then you don't need to use this key/value pair system. 

<p>You will almost certainly end up constructing these strings using the <b>va()</b>
variable argument substitution strings, I deliberately avoided them to reduce
the complexity of this explanation.

<p>&nbsp;

<p>Although there are no examples of the server over-riding the client settings
using <b>trap_SetUserinfo()</b>, presumable you just need to send the
variables you want changed using the key/value pairing described
above. The best place for the server to do this is in
<b>ClientUserinfoChanged()</b> in <b>g_client.c</b>

<p>&nbsp;


<a name="game_config_strings"></a><font color="#E07F44"><H5>
Special methods - configuration strings in the server
</H5></font>

<p>As already described earlier from the point of view of the client,
configuration strings contain global information that is maintained by the
server. It is transmitted to all the clients connected to the server,
and updated when changes are made by the server. The client can't modify
these strings, but can (and does) make use of the information.

<p>A configuration string is read or changed using these functions:

<font face="Verdana, Arial" size="3" color="#ffffcc"><pre>
void trap_GetConfigstring( int num, char *buffer, int bufferSize );
void trap_SetConfigstring( int num, const char *string );
</pre></font>

<dl>
<p><dt><b>num</b><dd>the index of the configuration string
<p><dt><b>buffer</b><dd>destination buffer for copying the config stirng to.
Use a char array of size <b>MAX_INFO_STRING</b>
<p><dt><b>bufferSize</b><dd>the size of <b>buffer</b>, prevents overflow
<p><dt><b>string</b><dd>new value for the configuration string
</dl>

<p>Each configuration string is described by an index <b>CS_*</b>, a list of
these values can be found in <b>bg_public.h</b>. Although there's space for
<b>MAX_CONFIGSTRINGS</b> (1024) values, the smallest amount of change that can
be transmitted across a network connection is a single string. This is a
network efficient way of transmitting state changes in the server, and other
global variables maintained by the server.

<p>Two special config strings are <b>CS_SYSTEMINFO</b> and
<b>CS_SERVERINFO</b>. Described in more detail in the client section above,
the Cvars that belong to this group are automatically updated when they're
modified by the server using <b>trap_Cvar_Set()</b>. Try to avoid putting
frequently changing values in here because it's almost certain that all Cvar
strings in this group are transmitted in one go, and this is network
inefficient. You can create your own specific <b>CS_*</b> flags and
groups instead (like <b>CS_FLAGSTATUS</b>).

<p>For an example we'll take a look at how the server updates
<b>CS_FLAGSTATUS</b>, this code is from <b>g_team.c</b>:

<font face="Verdana, Arial" size="3" color="#ffffcc"><pre>
void Team_SetFlagStatus( int team, flagStatus_t status )
{
	qboolean modified = qfalse;

	switch (team) {
	case TEAM_RED :
		if ( teamgame.redStatus != status ) {
			teamgame.redStatus = status;
			modified = qtrue;
		}
		break;
	case TEAM_BLUE :
		if ( teamgame.blueStatus != status ) {
			teamgame.blueStatus = status;
			modified = qtrue;
		}
		break;
	}

	if (modified) {
		char st[4];

		st[0] = '0' + (int)teamgame.redStatus;
		st[1] = '0' + (int)teamgame.blueStatus;
		st[2] = 0;

		trap_SetConfigstring( CS_FLAGSTATUS, st );
	}
}
</pre></font>

<p>The flag status is sent as a two digit pair, one each for the
red and blue flags. Sending the values as a pair of numbers is
a limitation of strings: we must avoid sending anything that might
prematurely terminate the string (a char value of <b>'\0'</b>), so
its encoded based on the ASCII value for the character <b>'0'</b>.

<p>This code fragment shows how its decoded in the client, in the function
<b>CG_ConfigStringModified()</b> in <b>cg_servercmds.c</b>:

<font face="Verdana, Arial" size="3" color="#ffffcc"><pre>
} else if ( num == CS_FLAGSTATUS ) {
	// format is rb where its red/blue, 0 is at base, 1 is taken, 2 is dropped
	cgs.redflag = str[0] - '0';
	cgs.blueflag = str[1] - '0';
}
</pre></font>

<p>and you can see that the binary value of zero, if stored directly in
<b>str[0]</b>, would have prevented the rest of the string from
being transmitted. The status of the blue flag would then be unknown.

<p>&nbsp;


<a name="special_cvars"></a><font color="#E07F44"><H4>
2.4 Some special Cvars
</H4></font>

<p>There are some Cvars that have slightly unusual properties. There are only
a few of these Cvars, and I'll only touch on them briefly.

<p>One reason for these special Cvars is so that one VM can control or influence
another in a transparent manner. The three
Cvars that fall into this category are <b>sv_running</b>, <b>cl_paused</b>,
and <b>g_syncronousClients</b>.

<p>&nbsp;

<p>If <b>sv_running</b> is set then the server is running on your local machine.
This is important as its presence enables some menu items in the <b>ui</b>
that can be used to influence the local server.

<p>You can also check for this in the client code by accessing
<b>cgs.localServer</b> (zero if we're connected to a remote server),
it's set in the following manner:

<font face="Verdana, Arial" size="3" color="#ffffcc"><pre>
char var[MAX_TOKEN_CHARS];
trap_Cvar_VariableStringBuffer( "sv_running", var, sizeof( var ) );
cgs.localServer = atoi( var );
</pre></font>

<p>&nbsp;

<p><b>cl_paused</b> is used to indicate to the client that the user interface
has drawn a menu on screen while the client is running.
Setting this variable to a value of <b>1</b> (one) will pause
the game if the server is local. This appears to be managed by the executable,
stopping the server and client VM's temporarily, rather than in any
of the VM code itself.

<p>&nbsp;

<p>The third variable is <b>g_syncronousClients</b>, this is set if the server
allows demo recording, and it also plays a part in client side prediction.
It is created in the server VM, and replicated to the client VM via
the <b>CS_SYSTEMINFO</b> configuration string. The client
can't modify this value, but it can be read in and acted upon. 

<p>Note that the creation in the client of the <b>vmCvar_t</b> structure
doesn't have any <b>CVAR_*</b> flags associated with it, this is because the
server stored value is the one with the <b>CVAR_ARCHIVE</b> flag set. In other
words, the server has control over the value, while the client contains only
a reference.

<p>&nbsp;

<p>Another variable, apparently set by the executable, is <b>bot_enable</b>.
If this is set to zero then bots aren't loaded onto the system. There is no
corresponding copy stored in a VM, it appears to be managed by the
executable running the server (but is available to the client). Again,
some menu options depend on this value to determine whether they are
enabled or not.

<p>&nbsp;

<a name="console_commands"></a><font color="#E07F44"><H4>
3. Console commands - do this, now!
</H4></font>

<p>With the large amount of ground covered by the Cvars and server
configuration strings, you're going to find console commands has less content.
Unfortunately the picture is made difficult to follow because of the
possibility of confusion between the client and server consoles.
In addition the server can issue commands to the client,
in a way that looks like the console commands, but is in fact separate.
I've tried to give the best description of these as I possibly can below.

<p><em>Client console commands</em>, as their name suggests, can be typed in from the drop
down console. There is also a way of executing these commands from within
the source code. Whether the command originates from the console or code
is irrelevant when it's acted upon. This means that these commands can't
be hidden from the user in the same way as configuration strings can.

<p>A client console command can be handled in either the user interface, client,
or server parts of the code. This makes it a very useful way of asking another
VM to do something for you (for example: displaying a menu system
using the user interface). We'll look at the client console in
<a href="#client_console">section 3.1</a>.

<p>The <em>server console</em> is another matter. These commands control how the
server behaves and they can only be accessed when the server is
running on the same machine, or a particular client has the
administrator privilige to change the setup of the server remotely.
Some commands that fall into this category are <b>addip</b> and <b>addbot</b>,
and we'll cover the server console in <a href="#server_console">section 3.2</a>.

<p>What is potentially confusing is that when the client and server are running on
the same machine, both the <em>client</em> and <em>server</em> console commands
are entered in the same way. The typing of commands through the drop down
console is, at best, a confusing use of terminology.

<p>Apply this rule of thumb: A command typed in by the player is a
<em>client</em> console command if is expected to behave the same whether
the server is local (running on the same machine) or remote (on a LAN
or across the Internet).

<p>&nbsp;

<a name="client_console"></a><font color="#E07F44"><H4>
3.1 Client console commands
</H4></font>

<p>Once a console command has been recognized (Cvars are filtered out first),
it arrives at the handler for each of the VM modules. For the user interface
this handling function is <b>UI_ConsoleCommand()</b> in <b>ui_atoms.c</b>,
the client has <b>CG_ConsoleCommand()</b> in <b>cg_consolecmds.c</b>, while
the server uses <b>ClientCommand()</b> in <b>g_cmds.c</b>.

<p>Some pre-processing has already been done for you, and you can get
at arguments for the command by using <b>trap_Argv(int pos)</b> (the argument at a
given position), and <b>trap_Argc()</b> (the total number of arguments). The
user interface and client have &quot;wrappered&quot; versions that can also be
accessed through <b>UI_Argv()</b> and <b>CG_Argv()</b>. You'll find that
<b>Argv(0)</b> is always the command string itself.

<p>&nbsp;

<a name="ui_client_console"></a><font color="#E07F44"><H4>
3.1.1 Client console commands in the user interface
</H4></font>

<p>There's no rocket science to adding a console command to the user
interface: just add a <b>Q_stricmp( cmd , "yourcmd")==0</b> comparison into
<b>UI_ConsoleCommand()</b> and route it to you handling function.

<p>The most obvious use of a command in the user interface is to pull up a
menu for the user to interact with, and there's an obvious example in the
<b>ui_teamOrders</b> command. One thing to be cautious of if you're
displaying a menu: you'll need to protect against repeatedly adding new menus
until the menu stack is used up.

<p>Surprisingly there's no way of sending out a console command from the
user interface, it has to go through Cvars or server scripting (see
<a href="#server_scripting">section 4</a>).
I would guess that's because it's possible for the user interface to
be running when the client and server code aren't. Any Cvars that are
important and stored outside the user interface are latched anyway - so any
updated value is still passed correctly.

<p>You can get some information about the state of the client through a call
to <b>trap_GetClientState(uiClientState_t*)</b>. This data structure is
described in <b>ui_public.h</b>, and includes (amongst other things) access
to the connection state of the client. This might influence how you draw
the menu: in a connected game you'll want to leave the background "transparent"
so the player can see the game screen. This code fragment
taken from <b>UI_ConfirmMenu()</b> in <b>ui_confirm.c</b> shows how this is
done:

<font face="Verdana, Arial" size="3" color="#ffffcc"><pre>
uiClientState_t	cstate;

trap_GetClientState( &cstate );
if ( cstate.connState >= CA_CONNECTED ) {
	s_confirm.menu.fullscreen = qfalse;	// no black background
}
else {
	s_confirm.menu.fullscreen = qtrue;
}
</pre></font>

<p>See my <a href="article6.shtml">articles on the user interface menu</a> for more information
on how and why ths works.

<p>&nbsp;


<a name="special_game_menu"></a><font color="#E07F44"><H5>
Special treatment - The In Game (ESC) Menu
</H5></font>

<p>When you press the Escape key while playing a game you get the In Game Menu that
allows you to change teams, add bots, change game settings etc. This menu is
unusual: it doesn't use a console command to activate it.

<p>The ESC key is recognized in the executable and passed into
the user interface VM through <b>vmMain()</b> in <b>ui_main.c</b>. Although
several menus are created by this method, and all pass through
<b>UI_SetActiveMenu()</b> in <b>ui_atoms.c</b> I haven't been able to find
a way for the user to extend this and add their own menus.

<p>The good news is that you can use console commands to create your own menus.
Just make sure that the commands in <b>UI_SetActiveMenu()</b> don't overwrite
your menu, and that <b>UIMENU_NONE</b> is always honoured.

<p>&nbsp;

<a name="cgame_client_console"></a><font color="#E07F44"><H4>
3.1.2 Client console commands in cgame
</H4></font>

<p>Once again, adding a client console command is straight forward. It's made even
easier by the use of an array of console commands and associated function
handlers in <b>cg_consolecmds.c</b>.

<p>As the code fragment below shows, just add an new entry into the the
<b>commands[]</b> array, with your command name and your handling function.
This handling function must be of type <b>void function_name(void)</b> for the
array to work.

<font face="Verdana, Arial" size="3" color="#ffffcc"><pre>
typedef struct {
	char	*cmd;
	void	(*function)(void);
} consoleCommand_t;

static consoleCommand_t	commands[] = {
	{ "testgun", CG_TestGun_f },
	{ "testmodel", CG_TestModel_f },

	// code snipped

	{ "tcmd", CG_TargetCommand_f },
	{ "loaddefered", CG_LoadDeferredPlayers }	// spelled wrong, but not changing for demo...
};
</pre></font>

<p>&nbsp;

<p>You can send out a client command to another VM by calling
<b>trap_SendConsoleCommand(const char* cmd_string)</b>. You can add
arguments with additional information so long as you separate each of them with a
space. When they arrive at the VM that handles them they'll already be
processed so each argument is easily accessible.

<p>There is also a similarly named (and possibly confusing) function
called <b>trap_SendClientCommand(const char* cmd_string)</b>. This
sends the command string directly to the server, without a chance being given
to the user interface to act upon it. Use it as part of exclusively client-server
issues.

<p>When the command string arrives at the server, whether it came from
<b>trap_SendConsoleCommand()</b> or <b>trap_SendClientCommand()</b>, it is
handled in <b>ClientCommand()</b> in <b>g_cmds.c</b>.

<p>This example shows how the <b>tell_target</b> client console command is
broken down into a single tell command. Ultimately this will be processed in
the server for distribution to the victim under the crosshair.

<font face="Verdana, Arial" size="3" color="#ffffcc"><pre>
static void CG_TellTarget_f( void ) {
	int		clientNum;
	char	command[128];
	char	message[128];

	clientNum = CG_CrosshairPlayer();
	if ( clientNum == -1 ) {
		return;
	}

	trap_Args( message, 128 );
	Com_sprintf( command, 128, "tell %i %s", clientNum, message );
	trap_SendClientCommand( command );
}
</pre></font>


<p>&nbsp;

<p>If you create a command in the server and you want TAB completion to work
in the client, then you should also register the server command in the client.
This is done in <b>CG_InitConsoleCommands()</b> in <b>cg_consolecmds.c</b>
by adding another <b>trap_AddCommand()</b> to the list.

<p>Why do it this way? Well if the server is running on another machine
then you don't want TAB completion to depend on the availability of
the network connection.

<p>&nbsp;


<a name="game_client_console"></a><font color="#E07F44"><H4>
3.1.3 Client console commands in the server
</H4></font>

<p>There are two types of command that the server can accept, so it's important
to put your command into the right place. Go back and read the start of
<a href="#console_commands">section 3</a> to understand the
difference. We'll look at the client console commands here, while
dealing with the server console in <a href="#server_console">section 3.2</a>.

<p>Since we're looking at client console commands we need to work in
<b>ClientCommand()</b> in <b>g_cmds.c</b>. Each command that you add is just
a straight forward <b>Q_stricmp()</b> comparison that passes control to your
handler if passed.

<p>Note that there is a watershed between commands that can be executed at any
point, and those commands which don't make any sense during the intermission
(when a level is over and the scoreboard is displayed, but before the next level
is loaded).

<p>If you want TAB completion of the command name in the client, then you'll
need to add the name of the command as described at the end of
<a href="#cgame_client_console">section 3.1.2</a>, above.

<p>&nbsp;

<p>I've not found a way for the server to send a client console command to
a particular client (such a command could reach either the <b>ui</b> or
<b>cgame</b>). However, there is a way that the server can send a command
to the client (<b>cgame</b>), and this is covered in
<a href="#servercommands_toclient">section 3.3</a>. Although this seems to
be the reciprocal method for sending a client console command from the server,
the commands it sends can't be typed into the client - they can only be sent
by the server.

<p>&nbsp;


<a name="server_console"></a><font color="#E07F44"><H4>
3.2 Server console commands
</H4></font>

<p>Notice the change of subject!

<p>We're now talking about commands that get to
the server console, described and defined at the start of
<a href="#console_commands">section 3</a>.

<p>These are the commands that can be typed on a client drop down console
when the server is running on the same machine, or if the client has
administrative privilige on a remote machine. Usually these commands have a drastic
effect on gameplay or the behaviour of the server. You want to be careful
who you let use these commands, and many of them might be made available through
the voting system.

<p>All of these commands arrive in <b>ConsoleCommand()</b> in <b>g_svcmds.c</b>
for processing (note that console in this case means <em>server</em> console).
You don't need to do anything special to separate them
from the client console commands, this is done for you automatically
(and is outside your control!)

<p>As this snipped version of <b>ConsoleCommand()</b> shows, you need to
return <b>qtrue</b> if you do handle the server command. Trace through
the code to <b>Svcmd_AddBot_f()</b> in <b>g_bot.c</b> to see how
<b>trap_Argv()</b> is used to grab the arguments to <b>addbot</b>.

<font face="Verdana, Arial" size="3" color="#ffffcc"><pre>
qboolean	ConsoleCommand( void ) {
	char	cmd[MAX_TOKEN_CHARS];

	trap_Argv( 0, cmd, sizeof( cmd ) );

	// code snipped

	if (Q_stricmp (cmd, "addbot") == 0) {
		Svcmd_AddBot_f();
		return qtrue;
	}

	// code snipped

	return qfalse;
}
</pre></font>


<p>&nbsp;


<a name="servercommands_toclient"></a><font color="#E07F44"><H4>
3.3 Commands issued to the client from the server
</H4></font>

<p>When the server needs to send a command to one or all clients then it uses
the following function:

<font face="Verdana, Arial" size="3" color="#ffffcc"><pre>
trap_SendServerCommand(int clientNum, const char* command_string)
</pre></font>

<p>The <b>clientNum</b> is the identifying index of the client,
look in <a href="#accessing_client_cvars">section 2.3.3</a> for an example of how to
get a clientNum if it isn't provided for you. <b>clientNum</b> may
also be <b>-1</b>, in which case the command is broadcast to all connected clients.

<p>The command will arrive in the client in <b>CG_ServerCommand()</b>
in <b>cg_servercmds.c</b>, all ready for the client to deal with.

<p>In an attempt to make this clear to a possibly confused reader, try the following
experiment: start up Q3 and get a map going. Pull down the console and
type in &quot;/cp test&quot; (without the quotes of course!). It will show an
error message.

<p>Now look at <b>CG_ServerCommand()</b> in <b>cg_servercmds.c</b> for
the <b>cp</b> command. It draws some text in the centre of the screen
(cp - center print) and is sent by the server. Can you now see that
commands sent by the server aren't connected to the client console?

<p>&nbsp;


<a name="server_scripting"></a><font color="#E07F44"><H4>
4. Server scripting - play the game
</H4></font>

<p>The last method of control is aimed purely at the server. You can send a
list of commands to the server (to be accurate, the binary executable running
the <b>game</b> VM), that are equivalent to running a script. These commands
remain in memory and are used (for example) to set up a map rotation. Think of
this method as having the same effect as using the <b>/exec</b> command in
the drop down console.

<p>You can add these commands from the user interface part of the
source code, or as part of the <b>game</b> code. You are effectively limited
to setting up and controlling a server on your machine only, or having a
server manipulate its own script. It shouldn't be possible for a local
user interface to manipulate a remote server using these functions.

<p>From within the user interface code:

<font face="Verdana, Arial" size="3" color="#ffffcc"><pre>
void trap_Cmd_ExecuteText( int exec_when, const char *text );
</pre></font>

<p>and from within the server code:

<font face="Verdana, Arial" size="3" color="#ffffcc"><pre>
void trap_SendConsoleCommand( int exec_when, const char *text );
</pre></font>

<p>Don't be confused by the fact it carries the same name as a function
that's used in the client, its behaviour isn't the same.  Think of it
as acting on the <em>server</em> console only.

<p>The <b>text</b> argument is easy enough: it's the text string that contains
a command or sets a variable. You should add a newline character <b>'\n'</b>
when you issue a single command, or you can put a group of commands together
in the same string, separated by a semi-colon, and terminated with a newline.
If you don't put the newline in then you'll get two commands running together
and confusing the executable's script engine.

<p>The other argument, <b>exec_when</b>, is a bit more difficult to understand
from just code reading and without access to the source code for the executable.
Here's the allowed values and what I've been able to glean:

<dl>
<p><dt><b>EXEC_NOW</b><dd>The string is executed immediately and control won't
return to the VM until it's completed. Use with extreme caution in case a
command that you use causes the VM to unload and then reload.

<p><dt><b>EXEC_INSERT</b><dd>This flag causes a command to be
&quot;forgotten&quot; about after it's executed. Control will return
immediately while the command is queued for execution in the immediate future.

<p><dt><b>EXEC_APPEND</b><dd>Think of this as appending text to a script file
that's stored by the server. Control returns immediately, and values will
remain stored for future reference. This is the most commonly used option.
</dl>

<p>Although the <b>EXEC_NOW</b> flag is clear enough, it's possible for the
other two to be confused. If you start with the idea that <b>EXEC_APPEND</b> is
building a script (list of commands) within the executable running the server,
then you can see that this script will always be present until the server is
shut down. Although you can add new commands and have them executed, you would
use the <b>EXEC_INSERT</b> so that it wasn't permanently added to the script
being built by <b>EXEC_APPEND</b>.

<p>It appears that the <b>EXEC_INSERT</b> command isn't used in the
user interface, possibly because the server can't be guaranteed to be
running. If you do try to use <b>EXEC_INSERT</b> in the user interface,
use it with caution.

<p>&nbsp;


<a name="example_server_setup"></a><font color="#E07F44"><H5>
Example - setting up a server from the ui
</H5></font>

<p>Taken from <b>ServerOptions_Start()</b> in <b>ui_startserver.c</b>, this
code fragment shows the bots selected for a map being added to the server
script through the use of <b>EXEC_APPEND</b>. This code is run when you
create a server from the multiplayer menu, or have a skirmish from the single
player menu.

<p>Notice that each string for the <b>addbot</b> command is finished off with
the <b>'\n'</b> character.

<p>The <b>wait</b> command is interesting: some of the server parameters are
set through <b>trap_Cvar_SetValue()</b>, and this allows their value to
propagate through to the binary executable. As this code is run when we set up
a server on our local machine, the time delay only needs to be a short one.

<font face="Verdana, Arial" size="3" color="#ffffcc"><pre>
int		skill;
int		n;
char	buf[64];

// add bots
trap_Cmd_ExecuteText( EXEC_APPEND, "wait 3\n" );
for( n = 1; n < PLAYER_SLOTS; n++ ) {
	if( s_serveroptions.playerType[n].curvalue != 1 ) {
		continue;
	}
	if( s_serveroptions.playerNameBuffers[n][0] == 0 ) {
		continue;
	}
	if( s_serveroptions.playerNameBuffers[n][0] == '-' ) {
		continue;
	}
	if( s_serveroptions.gametype >= GT_TEAM ) {
		Com_sprintf( buf, sizeof(buf), "addbot %s %i %s\n",
			s_serveroptions.playerNameBuffers[n], skill,
			playerTeam_list[s_serveroptions.playerTeam[n].curvalue] );
	}
	else {
		Com_sprintf( buf, sizeof(buf), "addbot %s %i\n",
			s_serveroptions.playerNameBuffers[n], skill );
	}
	trap_Cmd_ExecuteText( EXEC_APPEND, buf );
}
</pre></font>


<p>&nbsp;


<a name="finish"></a><font color="#E07F44"><H4>
5. The end of the road...
</H4></font>

<p>We've come a long way with this article, and covered a lot of ground that
turned out to be more complex that even I'd originally thought. So long as
you keep a clear picture in your mind of the differences and relationships
between the user interface, the client, the server, and the executable, then
you should be able to use this information to the full.

<p>When I originally planned this article I was going to talk about manipulating
information stored in entities too - I'll have to save that for another time
as this article is now far too long to do entities justice.

<p>There are also some bot commands for setting variables, but I've left
them out for reasons of space and specialization. The ideas that govern the
use of these bot commands are going to be very similar to the conventional
methods I've described in this article.

<p>Let me know if there are any problems with the article, and if it's been
of help to you.

<p align=right><b><a href="mailto:hypothermia@planetquake.com"><font color="#FF0000">H</font><font color="#FFFF00">y</font><font color="#CC33CC">p</font><font color="#3333FF">o</font><font color="#FFFFFF">Thermia</font></A></b>  

<p>&nbsp;



	  <p>
	</td>
  </tr>
</table>
	<!-- END MAIN TABLE -->

  </tr>
</table>
<p>

	<!-- BEGIN BOTTOMHEIRARCHY -->
<table width="100%" cellpadding=0 cellspacing=0 border=0 bgcolor="#000000">
  <tr>
	<td><img src="/code3arena/images/ouricon.gif"></td>
	<td width="100%" bgcolor=#000000>
	<font face="Verdana, Arial" size="2" color="#eeeeee"><b>
	<A HREF="http://www.planetquake.com">PlanetQuake</A> |
	<A HREF="http://www.planetquake.com/code3arena">Code3Arena</A> |
	<A HREF="http://www.planetquake.com/code3arena/articles">Articles</A> |
	<a href="article8.shtml"><< Prev</a> |
	Article 9 |
	<a href="article10.shtml">Next >></a>
	</b></font>
	</td>
  </tr>
</table>
<p>
	<!-- END BOTTOM HEIRARCHY -->

</body>
</html>
