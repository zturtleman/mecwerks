<SCRIPT SRC="http://ads.gamespy.com/jserver/SITE=PQ/AREA=HOSTED/GENRE=ACTION/TIER=3/AAMSZ=PRESTITIAL?257900250"></SCRIPT><!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!--INSERTADTHISPAGE -->

<html>
<head>
	<title>Code3Arena</title>
</head>

<body background="../images/bg.gif" bgcolor="#660000" text="white" link="#C05F00" vlink="#d16545">


	<!-- BEGIN BANNER AD TABLE -->
<table width="100%" border=0 cellpadding=5 cellspacing=0 align="center" background="../images/bg.gif">
  <tr>
   	 <td width=468 height=60 align="CENTER" valign="top" bgcolor=#000000>
 <center><SCRIPT SRC="http://ads.gamespy.com/jserver/SITE=PQ/AREA=HOSTED/GENRE=ACTION/TIER=3/AAMSZ=IAB_FULL_BANNER?257900250"></SCRIPT><NOSCRIPT><A HREF="http://ads.gamespy.com/cgi-bin/adclick.exe/SITE=PQ/AREA=HOSTED/GENRE=ACTION/TIER=3/AAMSZ=IAB_FULL_BANNER?257900250"><IMG SRC="http://ads.gamespy.com/cgi-bin/adserver.exe/SITE=PQ/AREA=HOSTED/GENRE=ACTION/TIER=3/AAMSZ=IAB_FULL_BANNER?257900250"></A></NOSCRIPT><!--ACCIPITERADINSERT/site=PQ/AAMSZ=IAB_FULL_BANNER/AREA=ARTICLES--></center>
</td>
  </tr>
</table>
	<!-- END BANNER AD TABLE -->

<br>

	<!-- BEGIN LOGO IMAGE TABLE -->
<table width="100%" cellspacing="0" cellpadding="0" border="1" align="center" bgcolor=#000000>
  <tr>
	 <td align="CENTER">
	  <img src="/code3arena/images/logo.gif" width="500" height="137" border="0" alt="Code3Arena">
</td>
  </tr>
</table>
	<!-- END LOGO IMAGE TABLE -->
<p>

	<!-- BEGIN TOP HEIRARCHY -->
<table width="100%" cellpadding=0 cellspacing=0 border=0 bgcolor="#000000">
  <tr>
	<td><img src="/code3arena/images/ouricon.gif"></td>
	<td width="100%" bgcolor=#000000>
	<font face="Verdana, Arial" size="2" color="#eeeeee"><b>
	<A HREF="http://www.planetquake.com">PlanetQuake</A> |
	<A HREF="http://www.planetquake.com/code3arena">Code3Arena</A> |
	<A HREF="http://www.planetquake.com/code3arena/tutorials">Tutorials</A> |
	<a href="tutorial28.shtml"><< Prev</a> |
	Tutorial 29 |
	<a href="tutorial30.shtml">Next >></a>
	</b></font>
	</td>
  </tr>
</table>
<p>
	<!-- END TOP HEIRARCHY -->

	<!-- BEGIN MAIN TABLE HERE-->
<table width="100%" border=0 cellpadding=0 cellspacing=0 align=center bgcolor=#4B0202>
  <tr>

   <!-- BEGIN LEFT NAVBAR MENU -->
	<td valign=top bgcolor="#000000">
<table width=150 bgcolor="#000000" valign=top border=0 cellpadding=10 cellspacing=0 >
  <tr>
	 <td bgcolor=#000000 valign=top>
      <p>
      <a href="/code3arena/index.shtml"><img src="/code3arena/images/minilogo.gif" width="150" height="80" border="0" alt="menu"></a>
	  <p><!-- C40B02 -->
	  <font face=arial color="#C05F00" size=2>
<strong>
<LI> <a href="/code3arena/index.shtml">Home/News</a>
<LI> <a href="/code3arena/modsource.shtml">ModSource</a>
<LI> <a href="/code3arena/compilers.shtml">Compiling</a>
<LI> <a href="/code3arena/help.shtml">Help!!!</a>
<LI> <a href="/code3arena/submission.shtml">Submission</a>
<LI> <a href="/code3arena/contributors.shtml">Contributors</a>
<LI> <a href="/code3arena/staff.shtml">Staff</a>
<LI> <a href="/code3arena/downloads.shtml">Downloads</a>
</strong>
<P>

	    <img src="/code3arena/images/tutorials.gif" width="80" height="25" border="0" alt="Tutorials">
	  <font color="#C05F00" size=1>
<strong>
<BR> <a href="/code3arena/tutorials"> <  Index  ></a>
<BR> 1. <a href="/code3arena/tutorials/tutorial1.shtml">Mod making 101</a>
<BR> 2. <a href="/code3arena/tutorials/tutorial2.shtml">Up 'n running</a>
<BR> 3. <a href="/code3arena/tutorials/tutorial3.shtml">Hello, QWorld!</a>
<BR> 4. <a href="/code3arena/tutorials/tutorial4.shtml">Infinite Haste</a>
<BR> 5. <a href="/code3arena/tutorials/tutorial5.shtml">Armor Piercing Rails</a>
<BR> 6. <a href="/code3arena/tutorials/tutorial6.shtml">Bouncing Rockets</a>
<BR> 7. <a href="/code3arena/tutorials/tutorial7.shtml">Cloaking</a>
<BR> 8. <a href="/code3arena/tutorials/tutorial8.shtml">Ladders</a>
<BR> 9. <a href="/code3arena/tutorials/tutorial9.shtml">Favourite Server</a>
<BR> 10. <a href="/code3arena/tutorials/tutorial10.shtml">Flame Thrower</a>
<BR> 11. <a href="/code3arena/tutorials/tutorial11.shtml">Vortex Grenades</a>
<BR> 12. <a href="/code3arena/tutorials/tutorial12.shtml">Grapple</a>
<BR> 13. <a href="/code3arena/tutorials/tutorial13.shtml">Lightning Discharge</a>
<BR> 14. <a href="/code3arena/tutorials/tutorial14.shtml">Locational Damage</a>
<BR> 15. <a href="/code3arena/tutorials/tutorial15.shtml">Leg Shots</a>
<BR> 16. <a href="/code3arena/tutorials/tutorial16.shtml">Weapon Switching</a>
<BR> 17. <a href="/code3arena/tutorials/tutorial17.shtml">Scoreboard frag-rate</a>
<BR> 18. <a href="/code3arena/tutorials/tutorial18.shtml">Vortex Grenades II</a>
<BR> 19. <a href="/code3arena/tutorials/tutorial19.shtml">Vulnerable Missiles</a>
<BR> 20. <a href="/code3arena/tutorials/tutorial20.shtml">Creating Classes</a>
<BR> 21. <a href="/code3arena/tutorials/tutorial21.shtml">Scrolling Credits</a>
<BR> 22. <a href="/code3arena/tutorials/tutorial22.shtml">Weapon Dropping</a>
<BR> 23. <a href="/code3arena/tutorials/tutorial23.shtml">Anti-Gravity Boots</a>
<BR> 24. <a href="/code3arena/tutorials/tutorial24.shtml">HUD scoreboard</a>
<BR> 25. <a href="/code3arena/tutorials/tutorial25.shtml">Flashlight and laser</a>
<BR> 26. <a href="/code3arena/tutorials/tutorial26.shtml">Weapon Positioning</a>
<BR> 27. <a href="/code3arena/tutorials/tutorial27.shtml">Weapon Reloading</a>
<BR> 28. <a href="/code3arena/tutorials/tutorial28.shtml">Progressive Zooming</a>
<BR> 29. <a href="/code3arena/tutorials/tutorial29.shtml">Rotating Doors</a>
<BR> 30. <a href="/code3arena/tutorials/tutorial30.shtml">Beheading (headshot!)</a>
<BR> 31. <a href="/code3arena/tutorials/tutorial31.shtml">Alt Weapon Fire</a>
<BR> 32. <a href="/code3arena/tutorials/tutorial32.shtml">Popup Menus I</a>
<BR> 33. <a href="/code3arena/tutorials/tutorial33.shtml">Popup Menus II</a>
<BR> 34. <a href="/code3arena/tutorials/tutorial34.shtml">Cluster Grenades</a>
<BR> 35. <a href="/code3arena/tutorials/tutorial35.shtml">Homing Rockets</a>
<BR> 36. <a href="/code3arena/tutorials/tutorial36.shtml">Spreadfire Powerup</a>
<BR> 37. <a href="/code3arena/tutorials/tutorial37.shtml">Instagib gameplay</a>
<BR> 38. <a href="/code3arena/tutorials/tutorial38.shtml">Accelerating rockets</a>
<BR> 39. <a href="/code3arena/tutorials/tutorial39.shtml">Server only Instagib</a>
<BR> 40. <a href="/code3arena/tutorials/tutorial40.shtml">Advanced Grapple Hook</a>
<BR> 41. <a href="/code3arena/tutorials/tutorial41.shtml">Unlagging your mod</a>
</strong>
	  </font>
      <p><br>
	  
	  <img src="/code3arena/images/articles.gif" width="80" height="25" border="0" alt="Articles">
	  <font color="#C05F00" size=1>
<strong>
<BR> <a href="/code3arena/articles"> <  Index  > </a>
<BR> 1. <a href="/code3arena/articles/article1.shtml">Entities</A>
<BR> 2. <a href="/code3arena/articles/article2.shtml">Vectors</A>
<BR> 3. <a href="/code3arena/articles/article3.shtml">Good Coding</A>
<BR> 4. <a href="/code3arena/articles/article4.shtml">Compilers I</A>
<BR> 5. <a href="/code3arena/articles/article5.shtml">Compilers II</A>
<BR> 6. <a href="/code3arena/articles/article6.shtml">UI Menu Primer I</A>
<BR> 7. <a href="/code3arena/articles/article7.shtml">UI Menu Primer II</A>
<BR> 8. <a href="/code3arena/articles/article8.shtml">UI Menu Primer III</A>
<BR> 9. <a href="/code3arena/articles/article9.shtml">QVM Communication, Cvars, commands</A>
<BR> 10. <a href="/code3arena/articles/article10.shtml">Metrowerks CodeWarrior</A>
<BR> 11. <a href="/code3arena/articles/article11.shtml">1.27g code, bugs, batch</A>
</strong>
	  </font>
	  <p>
	  <!-- <hr color="#C0C0C0">  -->
	  <br>

	  <img src="/code3arena/images/links.gif" width="80" height="25" border="0" alt="Links">
	  <font color="#C05F00">
	  <small>
<li><a href="http://www.planetquake.com/quake3/files.shtml">Quake3 Files</a>
<li><a href="http://forums.planetquake.com/">Quake3 Forums</a>
<li><a href="http://dynamic.gamespy.com/~assim2/wwwshow.cgi?board=quake3">Q3A Editing Message Board</a>
<li><a href="http://www.planetquake.com/quake3/hosted/editing.shtml">Quake3 Editing</a>
	  </small>
	  </font>
	  <p><br>
	  
	  <img src="/code3arena/images/feedback.gif" width="80" height="25" border="0" alt="Feedback">
	  <font color="#C05F00">
	  <small>
<li><a href="mailto:sumfuka@planetquake.com">SumFuka</A>
<li><a href="mailto:calrathan@captured.com">Calrathan</A>
<li><a href="mailto:hypothermia@planetquake.com">
	<font color="#FF0000">H</font><font color="#FFFF00">y</font><font
	color="#CC33CC">p</font><font color="#3333FF">o</font>Thermia
	</A>
<li><a href="mailto:warzone@planetquake.com">WarZone</A>
	  </small>
	  </font>
	  <p><br>
	  
	  <img src="/counter/count.exe?ft=3&df=code3arena.dat&dd=D">
	   <p><br><br><br>
	  <small>Site Design by:</small>
	  <br>
	  <a href="mailto:ladyice@planetice.org,jeh@planetjeh.com"><img src="/code3arena/images/icelogo_sm.jpg" width="88" height="31" border="0" align="middle" alt="ICEmosis Design"></a>
	
	  </font>
	  <br><br>
    </td>

  </tr>
</table>
	</td>
	<!-- END LEFT NAVBAR MENU -->
	<!-- BEGIN DIVIDER -->
	<td valign=top background="../images/bg.gif">
<table width=20 cellpadding=0 cellspacing=0 border=0 background="../images/bg.gif">
  <tr>
	<td background="../images/bg.gif">
	  &nbsp;
	</td>
  </tr>
</table>
	</td>
	<!-- END DIVIDER -->


	<!-- MAIN TEXT AREA -->
	<td valign=top bgcolor=#000000>
<table width="100%" cellpadding=15 cellspacing=10 border=0 bgcolor=#000000 valign=top>
  <tr>
	<td valign=top>
<font face="Verdana, Arial" size="2" color="#eeeeee">


<center><b><font color="#C05F00" size=5>
TUTORIAL 29 - Rotating Doors!
</font></b><br>by <b><a href="mailto:uw.valkyrie@home.com">Valkyrie</A></b></center><p>

Anyone who's played a realism mod knows what it's like to have swinging doors in the maps instead of
your average style sliding door, right? Would it be right if you are trying to invade a large
mansion with big double doors and brass doorknobs that SLIDE open? While at first it might trigger
some humour in the players, it certainly wouldn't look right. Since Quake 3 did not originally have
swinging doors to begin with, we're gonna have to put it in ourselves. Unfortunately, many players
often take rotating doors for granted, but oh, (going opera here!) just how they would feel if they
know the dreaded truth of how the hard-working coders manage to get this
not-so-difficult-but-long-and-tedious task done! =D<P>

To be honest, however, all we have to do is to duplicate each and every little bit of code that
contributes to the sliding door code, with the exception of the function that triggers the door
open, and to also make some new definitions that go along with it. Then we change this new
duplicate so that it manipulates the door's angle instead of the position. This tutorial shows you
the most basic of rotating doors, and they will open the same way as you would a sliding door.
Anyways, enough of my ranting. On with the doors!<P>

This modification is all server side, so that's another good thing to know.
You will be modifying the following files:<P>

<font color="#00FF00">
g_local.h<BR>
g_combat.c<BR>
g_spawn.c<BR>
g_mover.c</font> <font color="#FFFFCC"> - major beyond belief</font>

<P>There's also a sample map (including the un-compiled map source) so you can test
that the code changes work, and see a functional map in Q3Radiant. Download link at the end 
of the tutorial.

<P>&nbsp;

<font color="#E07F44"><H4>
1. SETTING UP
</H4></font>

I'll try to make this as easy as possible. We'll start around line 41 in file
<font color="#00FF00">g_local.h</font>. Add the following code in.<BR>
Be sure to include the comma that is now present after the MOVER_2TO1 enum.

<font face="Verdana, Arial" size="3" color="#ffffcc"><pre>
// movers are things like doors, plats, buttons, etc
typedef enum {
	MOVER_POS1,
	MOVER_POS2,
	MOVER_1TO2,
	MOVER_2TO1<font color="#ff6060">,

	// VALKYRIE: angle movements
	ROTATOR_POS1,
	ROTATOR_POS2,
	ROTATOR_1TO2,
	ROTATOR_2TO1</font>
} moverState_t;
</pre></font><P>

What I did here is make 4 new additions to the moverState_t enumeration so that the game will
recognize this as the new rotating door code, and will treat it accordingly.<P>

Let's go to around line 155, inside the gentity_s structure. Add the following line in.<P>

<font face="Verdana, Arial" size="3" color="#ffffcc"><pre>
	// timing variables
	float		wait;
	float		random;

	gitem_t		*item;			// for bonus items

	qboolean	botDelayBegin;

	<font color="#ff6060">float		distance;		// VALKYRIE: for rotating door</font>
};
</pre></font><P>

What we've done here is setup a new variable for the gentity_s structure that will tell the
game how many degrees the door will open before it is considered fully open.<P>

This finishes <font color="#00FF00">g_local.h</font>, and we are now ready to move into the
other parts of this tutorial.

<P>&nbsp;

<font color="#E07F44"><H4>
2. PREPARING THE SPAWN FUNCTION
</H4></font>

Starting at around line 96 in <font color="#00FF00">g_spawn.c</font>, add the following line of code
to the list.<P>

<font face="Verdana, Arial" size="3" color="#ffffcc"><pre>
field_t fields[] = {
	{"classname", FOFS(classname), F_LSTRING},
	{"origin", FOFS(s.origin), F_VECTOR},
	{"model", FOFS(model), F_LSTRING},
	{"model2", FOFS(model2), F_LSTRING},
	{"spawnflags", FOFS(spawnflags), F_INT},
	{"speed", FOFS(speed), F_FLOAT},
	{"target", FOFS(target), F_LSTRING},
	{"targetname", FOFS(targetname), F_LSTRING},
	{"message", FOFS(message), F_LSTRING},
	{"team", FOFS(team), F_LSTRING},
	{"wait", FOFS(wait), F_FLOAT},
	{"random", FOFS(random), F_FLOAT},
	{"count", FOFS(count), F_INT},
	{"health", FOFS(health), F_INT},
	{"light", 0, F_IGNORE},
	{"dmg", FOFS(damage), F_INT},
	{"angles", FOFS(s.angles), F_VECTOR},
	{"angle", FOFS(s.angles), F_ANGLEHACK},

	<font color="#ff6060">{"distance", FOFS(distance), F_FLOAT},	// VALKYRIE: for rotating doors</font>

	{NULL}
};</pre></font><P>

What we did here is add the previously declared variable <b>distance</b> to the list of fields that will
be initialized by any object that exists in a map. When the mapper creates the door, he will give the
keyword, "<i>distance</i>" a numerical value that will be passed on to <b>distance</b> (I hope you're
still with me). If this is missing, then <b>distance</b> will always be zero, because there's nothing
telling the spawn function (which we will add later) what the value of <b>distance</b> should be. Later, we
will also check that if <b>distance</b> is NULL or zero, we will force a default value of 90 degrees.<P>

Go further down, around line 169, and add the following line in.<P>

<font face="Verdana, Arial" size="3" color="#ffffcc"><pre>
void SP_team_CTF_redplayer( gentity_t *ent );
void SP_team_CTF_blueplayer( gentity_t *ent );

void SP_team_CTF_redspawn( gentity_t *ent );
void SP_team_CTF_bluespawn( gentity_t *ent );

<font color="#ff6060">void SP_func_door_rotating( gentity_t *ent );	// VALKYRIE: for rotating doors</font>
</pre></font><P>

This will allow the function to be called anywhere in the file after it, so that later it can call
the real function that is located in another file. This is the similar to adding a function definition
into <font color="#00FF00">g_local.h</font>, but it is limited only to the file which defined it.<P>

Go further down once more, to around line 242, and add the following line.<P>
<font face="Verdana, Arial" size="3" color="#ffffcc"><pre>
	{"team_CTF_redplayer", SP_team_CTF_redplayer},
	{"team_CTF_blueplayer", SP_team_CTF_blueplayer},

	{"team_CTF_redspawn", SP_team_CTF_redspawn},
	{"team_CTF_bluespawn", SP_team_CTF_bluespawn},

	<font color="#ff6060">{"func_door_rotating", SP_func_door_rotating},	// VALKYRIE: for rotating doors</font>

	{0, 0}
};</pre></font><P>

The above line is what will actually call our rotating door function should the current map contain
<i>func_door_rotating</i> entities. Without this line, our rotating doors would not have a spawn function to call.<P>

Now, at around line 469 in <font color="#00FF00">g_combat.c</font>, inside the <b>G_Damage</b> function
add the following modifications. This will allow us to shoot open rotating doors as well as normal doors.
Notice the extra pair of parentheses I've placed into the condition. This tells the game that in order for
the entire condition to pass, <b>targ->use</b> <u>must</u> be valid, and <b>targ->moverState</b> has to be
either MOVER_POS1, <u>or</u> ROTATOR_POS1.<P>
<font face="Verdana, Arial" size="3" color="#ffffcc"><pre>
	// shootable doors / buttons don't actually have any health
	if ( targ->s.eType == ET_MOVER ) {
		if ( targ->use && <font color="#ff6060">(</font>targ->moverState == MOVER_POS1
			<font color="#ff6060">|| targ->moverState == ROTATOR_POS1)</font> ) {
			targ->use( targ, inflictor, attacker );
		}
		return;
	}</pre></font><P>

This finishes <font color="#00FF00">g_spawn.c</font> and <font color="#00FF00">g_combat.c</font>,
and we are now ready to move into the more difficult parts of this tutorial.

<P>&nbsp;

<font color="#E07F44"><H4>
3. ADDING THE SPAWN FUNCTION
</H4></font>

At around line 869 of <font color="#00FF00">g_mover.c</font>, after the <b>SP_func_door</b> function, add this function in. This is the
function that spawns the door on the map and initializes everything else that pertains to the
door.The commented QUAKED definition is what the mappers will use to create the door in their
maps. More on that at the end.<P>

<font face="Verdana, Arial" size="3" color="#ffffcc"><pre>
<font color="#ff6060">/*QUAKED func_door_rotating (0 .5 .8) START_OPEN CRUSHER REVERSE TOGGLE X_AXIS Y_AXIS
This is the rotating door... just as the name suggests it's a door that rotates
START_OPEN	the door to moves to its destination when spawned, and operate in reverse.
REVERSE		if you want the door to open in the other direction, use this switch.
TOGGLE		wait in both the start and end states for a trigger event.
X_AXIS		open on the X-axis instead of the Z-axis
Y_AXIS		open on the Y-axis instead of the Z-axis
  
You need to have an origin brush as part of this entity.  The center of that brush will be
the point around which it is rotated. It will rotate around the Z axis by default.  You can
check either the X_AXIS or Y_AXIS box to change that.

"model2"	.md3 model to also draw
"distance"	how many degrees the door will open
"speed"	 	how fast the door will open (degrees/second)
"color"		constantLight color
"light"		constantLight radius
*/

void SP_func_door_rotating ( gentity_t *ent ) {
	ent->sound1to2 = ent->sound2to1 = G_SoundIndex("sound/movers/doors/dr1_strt.wav");
	ent->soundPos1 = ent->soundPos2 = G_SoundIndex("sound/movers/doors/dr1_end.wav");

	ent->blocked = Blocked_Door;

	// default speed of 120
	if (!ent->speed)
		ent->speed = 120;

	// if speed is negative, positize it and add reverse flag
	if ( ent->speed < 0 ) {
		ent->speed *= -1;
		ent->spawnflags |= 8;
	}

	// default of 2 seconds
	if (!ent->wait)
		ent->wait = 2;
	ent->wait *= 1000;
	
	// set the axis of rotation
	VectorClear( ent->movedir );
	VectorClear( ent->s.angles );
	
	if ( ent->spawnflags & 32 ) {
		ent->movedir[2] = 1.0;
	} else if ( ent->spawnflags & 64 ) {
		ent->movedir[0] = 1.0;
	} else {
		ent->movedir[1] = 1.0;
	}

	// reverse direction if necessary
	if ( ent->spawnflags & 8 )
		VectorNegate ( ent->movedir, ent->movedir );

	// default distance of 90 degrees. This is something the mapper should not
	// leave out, so we'll tell him if he does.
	if ( !ent->distance ) {
		G_Printf("%s at %s with no distance set.\n",
		ent->classname, vtos(ent->s.origin));
		ent->distance = 90.0;
	}
	
	VectorCopy( ent->s.angles, ent->pos1 );
	trap_SetBrushModel( ent, ent->model );
	VectorMA ( ent->pos1, ent->distance, ent->movedir, ent->pos2 );

	// if "start_open", reverse position 1 and 2
	if ( ent->spawnflags & 1 ) {
		vec3_t	temp;

		VectorCopy( ent->pos2, temp );
		VectorCopy( ent->s.angles, ent->pos2 );
		VectorCopy( temp, ent->pos1 );
		VectorNegate ( ent->movedir, ent->movedir );
	}
	
	// set origin
	VectorCopy( ent->s.origin, ent->s.pos.trBase );
	VectorCopy( ent->s.pos.trBase, ent->r.currentOrigin );

	InitRotator( ent );

	ent->nextthink = level.time + FRAMETIME;

	if ( ! (ent->flags & FL_TEAMSLAVE ) ) {
		int health;

		G_SpawnInt( "health", "0", &health );
		if ( health ) {
			ent->takedamage = qtrue;
		}
		if ( ent->targetname || health ) {
			// non touch/shoot doors
			ent->think = Think_MatchTeam;
		} else {
			ent->think = Think_SpawnNewDoorTrigger;
		}
	}
}</font>
</pre></font>

So... What exactly does this function do? Starting from the top, we have what makes the door sounds.
Followed by that is the function call for a door that is blocked (by another entity, like a foolish player).
Next, we have a condition that sets a default speed of 120 deg/s should the mapper leave "<i>speed</i>" NULL
or zero. Mappers who do not use our QUAKED statement and enter a negative value for <b>speed</b> to state
opposite direction will be in for a surprise. (If you do not understand the following, don't worry about
it.) Since the duration of rotation for the door is the <b>delta</b>*<b>1000</b>/<b>speed</b>, if your
speed is negative, then your duration will be negative. To keep as many values as possible to be positive to avoid
troubles, we'll correct that now by positizing it and also adding our REVERSE <b>spawnflag</b>.
After that we have our usual 2 second delay on the door after it is opened before closing.<P>

Those who think a negative speed will suffice, you are thinking <u>velocity</u>. Don't get them mixed up!<P>

Here, we have our initializations for our new vectors that will be used for our rotating doors.
<b>movedir</b> is the variable which determines the direction in which our door will turn. It will
consist of one of the 3 axes, and will either be moving forward or backward. After that we have our
condition which checks that if the REVERSE flag was true, then it will negate the vector, <b>movedir</b>,
so that the door will move in the opposite direction.<P>

<b>VectorNegate</b> and <b>VectorInverse</b> are entirely different calculations in the real world and
will produce different results! Do not get these two mixed up! Whoever coded <b>VectorInverse</b> for Q3A
never got around to finishing it, and you do not find it called anywhere in the source, so you should not use
it for the rotating doors either. Always use <b>VectorNegate</b> to completely reverse a vector.<P>

Now we have <b>distance</b> check to make sure that the mapper gave "<i>distance</i>" a value and that the
value is not NULL or zero. If the mapper really doesn't want to use the REVERSE flag, you can specify a
negative distance here, although I've not tried the results of doing so, but I assume that it would
work fine anyway. The remaining parts of the function should be self-explainatory, with the exception of
<b>InitRotator</b>, which is our version of <b>InitMover</b>, the former being designed for rotating doors.<P>

Phew... That finishes the function, but you're not done yet! Grab a glass of water and some music to
listen to. You're only halfway. =D

<P>&nbsp;

<font color="#E07F44"><H4>
4. MAKING IT HAPPEN
</H4></font>

From here on, it should be fairly simple. All we're doing now is a full duplicate of everything else that
pertains to the <b>func_door</b> code, except that it will be made to work for rotating doors by manipulating
the <u>angle</u> instead of the <u>position</u> (for sliding doors).<P>

Experienced programmers may find the following excessive and not the most optimal, but I did it this way
so that inexperienced programmers do not get confused. Feel free to optimize the code in anyway you
want if you understand what you are doing.<P>

Around line 638, right after the <b>InitMover</b> function, place our function, the <b>InitRotator</b> in.
This function initializes the entity and sets it up for operation.<P>

<font face="Verdana, Arial" size="3" color="#ffffcc"><pre>
<font color="#ff6060">/*
================
InitRotator

"pos1", "pos2", and "speed" should be set before calling,
so the movement delta can be calculated
================
*/
void InitRotator( gentity_t *ent ) {
	vec3_t		move;
	float		angle;
	float		light;
	vec3_t		color;
	qboolean	lightSet, colorSet;
	char		*sound;

	// if the "model2" key is set, use a seperate model
	// for drawing, but clip against the brushes
	if ( ent->model2 ) {
		ent->s.modelindex2 = G_ModelIndex( ent->model2 );
	}

	// if the "loopsound" key is set, use a constant looping sound when moving
	if ( G_SpawnString( "noise", "100", &sound ) ) {
		ent->s.loopSound = G_SoundIndex( sound );
	}

	// if the "color" or "light" keys are set, setup constantLight
	lightSet = G_SpawnFloat( "light", "100", &light );
	colorSet = G_SpawnVector( "color", "1 1 1", color );
	if ( lightSet || colorSet ) {
		int		r, g, b, i;

		r = color[0] * 255;
		if ( r > 255 ) {
			r = 255;
		}
		g = color[1] * 255;
		if ( g > 255 ) {
			g = 255;
		}
		b = color[2] * 255;
		if ( b > 255 ) {
			b = 255;
		}
		i = light / 4;
		if ( i > 255 ) {
			i = 255;
		}
		ent->s.constantLight = r | ( g << 8 ) | ( b << 16 ) | ( i << 24 );
	}


	ent->use = Use_BinaryMover;
	ent->reached = Reached_BinaryMover;

	ent->moverState = ROTATOR_POS1;
	ent->r.svFlags = SVF_USE_CURRENT_ORIGIN;
	ent->s.eType = ET_MOVER;
	VectorCopy( ent->pos1, ent->r.currentAngles );
	trap_LinkEntity (ent);

	ent->s.apos.trType = TR_STATIONARY;
	VectorCopy( ent->pos1, ent->s.apos.trBase );

	// calculate time to reach second position from speed
	VectorSubtract( ent->pos2, ent->pos1, move );
	angle = VectorLength( move );
	if ( ! ent->speed ) {
		ent->speed = 120;
	}
	VectorScale( move, ent->speed, ent->s.apos.trDelta );
	ent->s.apos.trDuration = angle * 1000 / ent->speed;
	if ( ent->s.apos.trDuration <= 0 ) {
		ent->s.apos.trDuration = 1;
	}
}</font>
</pre></font>

At around line 557, inside the <b>Use_BinaryMover</b> function, add the following.
Depending on the current <B>moverState</b>, this function will set the corresponding
action for our door. It will either start the movement of the door if it is already closed,
or it will delay the door from closing if already opened.<P>

<font face="Verdana, Arial" size="3" color="#ffffcc"><pre>
	// only partway up before reversing
	if ( ent->moverState == MOVER_1TO2 ) {
		total = ent->s.pos.trDuration;
		partial = level.time - ent->s.time;
		if ( partial > total ) {
			partial = total;
		}

		MatchTeam( ent, MOVER_2TO1, level.time - ( total - partial ) );

		if ( ent->sound2to1 ) {
			G_AddEvent( ent, EV_GENERAL_SOUND, ent->sound2to1 );
		}
		return;
	}	

	<font color="#ff6060">if ( ent->moverState == ROTATOR_POS1 ) {
		// start moving 50 msec later, becase if this was player
		// triggered, level.time hasn't been advanced yet
		MatchTeam( ent, ROTATOR_1TO2, level.time + 50 );

		// starting sound
		if ( ent->sound1to2 ) {
			G_AddEvent( ent, EV_GENERAL_SOUND, ent->sound1to2 );
		}

		// looping sound
		ent->s.loopSound = ent->soundLoop;

		// open areaportal
		if ( ent->teammaster == ent || !ent->teammaster ) {
			trap_AdjustAreaPortalState( ent, qtrue );
		}
		return;
	}

	// if all the way up, just delay before coming down
	if ( ent->moverState == ROTATOR_POS2 ) {
		ent->nextthink = level.time + ent->wait;
		return;
	}

	// only partway down before reversing
	if ( ent->moverState == ROTATOR_2TO1 ) {
		total = ent->s.apos.trDuration;
		partial = level.time - ent->s.time;
		if ( partial > total ) {
			partial = total;
		}

		MatchTeam( ent, ROTATOR_1TO2, level.time - ( total - partial ) );

		if ( ent->sound1to2 ) {
			G_AddEvent( ent, EV_GENERAL_SOUND, ent->sound1to2 );
		}
		return;
	}

	// only partway up before reversing
	if ( ent->moverState == ROTATOR_1TO2 ) {
		total = ent->s.apos.trDuration;
		partial = level.time - ent->s.time;
		if ( partial > total ) {
			partial = total;
		}

		MatchTeam( ent, ROTATOR_2TO1, level.time - ( total - partial ) );

		if ( ent->sound2to1 ) {
			G_AddEvent( ent, EV_GENERAL_SOUND, ent->sound2to1 );
		}
		return;
	}</font>
}</pre></font>

At around line 477, inside the function <b>Reached_BinaryMover</b>, add the following.
This function tells the door to stop moving after it has reached its point, and depending on the
current <b>moverState</b>, it will either set the door to <i>fully open</i>, or <i>fully closed</i>.<P>
<font face="Verdana, Arial" size="3" color="#ffffcc"><pre>
	} else if ( ent->moverState == MOVER_2TO1 ) {
		// reached pos1
		SetMoverState( ent, MOVER_POS1, level.time );

		// play sound
		if ( ent->soundPos1 ) {
			G_AddEvent( ent, EV_GENERAL_SOUND, ent->soundPos1 );
		}

		// close areaportals
		if ( ent->teammaster == ent || !ent->teammaster ) {
			trap_AdjustAreaPortalState( ent, qfalse );
		}
	} else<font color="#ff6060"> if ( ent->moverState == ROTATOR_1TO2 ) {
		// reached pos2
		SetMoverState( ent, ROTATOR_POS2, level.time );

		// play sound
		if ( ent->soundPos2 ) {
			G_AddEvent( ent, EV_GENERAL_SOUND, ent->soundPos2 );
		}

		// return to apos1 after a delay
		ent->think = ReturnToApos1;
		ent->nextthink = level.time + ent->wait;

		// fire targets
		if ( !ent->activator ) {
			ent->activator = ent;
		}
		G_UseTargets( ent, ent->activator );
	} else if ( ent->moverState == ROTATOR_2TO1 ) {
		// reached pos1
		SetMoverState( ent, ROTATOR_POS1, level.time );

		// play sound
		if ( ent->soundPos1 ) {
			G_AddEvent( ent, EV_GENERAL_SOUND, ent->soundPos1 );
		}

		// close areaportals
		if ( ent->teammaster == ent || !ent->teammaster ) {
			trap_AdjustAreaPortalState( ent, qfalse );
		}
	} else</font> {
		G_Error( "Reached_BinaryMover: bad moverState" );
	}
}</pre></font>

At line 435, under the <b>ReturnToPos1</b> function, we'll add our version of the that function.
Since the Q3 version will trigger the <i>position</i> of the door instead of the <i>angle</i>, we need to
make one that will trigger our rotating door instead.<P>
<font face="Verdana, Arial" size="3" color="#ffffcc"><pre>
<font color="#ff6060">/*
================
ReturnToApos1
================
*/
void ReturnToApos1( gentity_t *ent ) {
	MatchTeam( ent, ROTATOR_2TO1, level.time );

	// looping sound
	ent->s.loopSound = ent->soundLoop;

	// starting sound
	if ( ent->sound2to1 ) {
		G_AddEvent( ent, EV_GENERAL_SOUND, ent->sound2to1 );
	}
}</font>
</pre></font>

At around line 370, add this piece of code inside the <b>SetMoverState</b> function.
This function handles setting the state of any door in Q3, meaning this is the function
that tells the doors what to actually do. Our version of the code is made for setting the
<i>angle</i> of the door instead of the <i>position</i>.<P>
<font face="Verdana, Arial" size="3" color="#ffffcc"><pre>
	vec3_t			delta;
	float			f;

	ent->moverState = moverState;

	ent->s.pos.trTime = time;
	<font color="#ff6060">ent->s.apos.trTime = time;</font>
	switch( moverState ) {
	case MOVER_POS1:
		VectorCopy( ent->pos1, ent->s.pos.trBase );
		ent->s.pos.trType = TR_STATIONARY;
		break;
</pre></font>

At around line 395, add this piece of code in.<P>
<font face="Verdana, Arial" size="3" color="#ffffcc"><pre>
	case MOVER_2TO1:
		VectorCopy( ent->pos2, ent->s.pos.trBase );
		VectorSubtract( ent->pos1, ent->pos2, delta );
		f = 1000.0 / ent->s.pos.trDuration;
		VectorScale( delta, f, ent->s.pos.trDelta );
		ent->s.pos.trType = TR_LINEAR_STOP;
		break;
<font color="#ff6060">
	case ROTATOR_POS1:
		VectorCopy( ent->pos1, ent->s.apos.trBase );
		ent->s.apos.trType = TR_STATIONARY;
		break;
	case ROTATOR_POS2:
		VectorCopy( ent->pos2, ent->s.apos.trBase );
		ent->s.apos.trType = TR_STATIONARY;
		break;
	case ROTATOR_1TO2:
		VectorCopy( ent->pos1, ent->s.apos.trBase );
		VectorSubtract( ent->pos2, ent->pos1, delta );
		f = 1000.0 / ent->s.apos.trDuration;
		VectorScale( delta, f, ent->s.apos.trDelta );
		ent->s.apos.trType = TR_LINEAR_STOP;
		break;
	case ROTATOR_2TO1:
		VectorCopy( ent->pos2, ent->s.apos.trBase );
		VectorSubtract( ent->pos1, ent->pos2, delta );
		f = 1000.0 / ent->s.apos.trDuration;
		VectorScale( delta, f, ent->s.apos.trDelta );
		ent->s.apos.trType = TR_LINEAR_STOP;
		break;</font>
	}
	BG_EvaluateTrajectory( &ent->s.pos, level.time, ent->r.currentOrigin );
	<font color="#ff6060">BG_EvaluateTrajectory( &ent->s.apos, level.time, ent->r.currentAngles );</font>
	trap_LinkEntity( ent );
}</pre></font>

At around line 325, inside the <b>G_MoverTeam</b> function, add the following condition.
The original condition considers only the <i>position</i> of the door, so we have to make
our own condition that considers only the <i>angle</i> of the door to make it even.<P>
<font face="Verdana, Arial" size="3" color="#ffffcc"><pre>
	// the move succeeded
	for ( part = ent ; part ; part = part->teamchain ) {
		// call the reached function if time is at or past end point
		if ( part->s.pos.trType == TR_LINEAR_STOP ) {
			if ( level.time >= part->s.pos.trTime + part->s.pos.trDuration ) {
				if ( part->reached ) {
					part->reached( part );
				}
			}
		}
		<font color="#ff6060">if ( part->s.apos.trType == TR_LINEAR_STOP ) {
			if ( level.time >= part->s.apos.trTime + part->s.apos.trDuration ) {
				if ( part->reached ) {
					part->reached( part );
				}
			}
		}</font>
	}
}</pre></font>

And finally, at around line 928, inside the <b>Touch_DoorTrigger</b> function, add the following lines in.
This function is the actual function that check whether or not a client is standing within range of the door,
so that it will open. We will simply modify that condition so that it will check for our rotating doors as well
as standard Q3 doors.<P>
<font face="Verdana, Arial" size="3" color="#ffffcc"><pre>
/*
================
Touch_DoorTrigger
================
*/
void Touch_DoorTrigger( gentity_t *ent, gentity_t *other, trace_t *trace ) {
	if ( other->client && other->client->sess.sessionTeam == TEAM_SPECTATOR ) {
		// if the door is not open and not opening
		if ( ent->parent->moverState != MOVER_1TO2 &&
			ent->parent->moverState != MOVER_POS2<font color="#ff6060"> &&
			ent->parent->moverState != ROTATOR_1TO2 &&
			ent->parent->moverState != ROTATOR_POS2</font> ) {
			Touch_DoorTriggerSpectator( ent, other, trace );
		}
	}
	else if ( ent->parent->moverState != MOVER_1TO2<font color="#ff6060"> &&
		ent->parent->moverState != ROTATOR_1TO2</font> ) {
		Use_BinaryMover( ent->parent, ent, other );
	}
}</pre></font>

*Sigh...* Code wise, we're finally done. Just one thing left to explain, and that is the QUAKED statement
for the mappers to use.<P>
<font face="Verdana, Arial" size="3" color="#ccffcc"><pre>
/*QUAKED func_door_rotating (0 .5 .8) START_OPEN CRUSHER REVERSE TOGGLE X_AXIS Y_AXIS
This is the rotating door... just as the name suggests it's a door that rotates
START_OPEN	the door to moves to its destination when spawned, and operate in reverse.
REVERSE		if you want the door to open in the other direction, use this switch.
TOGGLE		wait in both the start and end states for a trigger event.
X_AXIS		open on the X-axis instead of the Z-axis
Y_AXIS		open on the Y-axis instead of the Z-axis
  
You need to have an origin brush as part of this entity.  The center of that brush will be
the point around which it is rotated. It will rotate around the Z axis by default.  You can
check either the X_AXIS or Y_AXIS box to change that.

"model2"	.md3 model to also draw
"distance"	how many degrees the door will open
"speed"	 	how fast the door will open (degrees/second)
"color"		constantLight color
"light"		constantLight radius
*/</pre></font>

Your mapper *should* know how to deal with this, but the programmer should also have a little insight on
this as well. This is an entity definition for Q3Radiant. When added into the file, <b>entities.def</b> (via a text editor)
, this will appear as an option available to the mapper when adding objects into the map, such as spawnpoints,
weapons, and in this case, doors. The first line is very important as that tells the function in our
actual code what spawnflags will be used for this particular object. The order of objects in the first
line must not be altered in anyway, as that will cause instructional problems between the map's options
and the code's functions.<P>

The remaining lines in the statement gives the mapper extra information on what to add to the object
to actually make it work. Should the mapper forget some required values, such as the speed, we have
placed a condition in our code so that a default value is used if this happens.<P>

Well, I guess that's it. Compile this code and use it on a map that has rotating doors!
Thanks to <a href="http://www.quake3mods.net/dog">Ro4dDogG</A>, we have a package containing both
<a href="http://dl.fileplanet.com/dl/dl.asp?code3arena/tutorial29_doortest.zip">compiled and
pre-compiled forms of the test map</a> available for download. Follow the instructions
included in the archive for installing and running the map.<p>

<font color="#ffffcc">
Addendum: The one error I've found is that the rotating doors do not light properly if the mapper does not
use "-light -extra" switches. Please keep that in mind when you are testing your maps.<p>

Doors, when blocked during closing/opening, will start again from the opposite end of its opening direction.
This also applies to sliding doors, and can be noticed if the door is moving slow enough. This is due to miscoding in
original Q3 source. Maybe someday I will work up a solution to this.<p></font>

	  <p>
	</td>
  </tr>
</table>
	<!-- END MAIN TABLE -->

  </tr>
</table>
<p>

	<!-- BEGIN BOTTOM HEIRARCHY -->
<table width="100%" cellpadding=0 cellspacing=0 border=0 bgcolor="#000000">
  <tr>
	<td><img src="/code3arena/images/ouricon.gif"></td>
	<td width="100%" bgcolor=#000000>
	<font face="Verdana, Arial" size="2" color="#eeeeee"><b>
	<A HREF="http://www.planetquake.com">PlanetQuake</A> |
	<A HREF="http://www.planetquake.com/code3arena">Code3Arena</A> |
	<A HREF="http://www.planetquake.com/code3arena/tutorials">Tutorials</A> |
	<a href="tutorial28.shtml"><< Prev</a> |
	Tutorial 29 |
	<a href="tutorial30.shtml">Next >></a>
	</b></font>
	</td>
  </tr>
</table>
<p>
	<!-- END BOTOTM HEIRARCHY -->

</body>
</html>
