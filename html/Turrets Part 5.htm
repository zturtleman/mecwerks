<SCRIPT SRC="http://ads.gamespy.com/jserver/SITE=PQ/AREA=HOSTED/GENRE=ACTION/TIER=3/AAMSZ=PRESTITIAL?304576000"></SCRIPT><!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0052)http://www.quakefiles.com/skunkworks/q3/turret5.html -->
<HTML><HEAD><TITLE>Turrets: Part 5</TITLE>
<META content="text/html; charset=windows-1252" http-equiv=Content-Type><LINK 
href="Turrets Part 5_files/skunk.css" rel=STYLESHEET type=text/css>
<META content="MSHTML 5.00.2614.3500" name=GENERATOR></HEAD>
<BODY text=white bgcolor="#000000">
<SCRIPT language=JavaScript>
<!--
var begin = new Date()
var startYear = new Date("January 1, 1970")
startYear.setYear(begin.getYear())
var random = (begin.getTime() - startYear.getTime())
document.write('<a href="http://ad.doubleclick.net/jump/quakefiles.com/skunkworks;sz=468x60;tile=1;ord=' + random + '">');
document.write('<img src="http://ad.doubleclick.net/ad/quakefiles.com/skunkworks;sz=468x60;tile=1;ord=' + random + '" height=60 width=468>' + '</a>');
document.write(' <A HREF="http://www.gamekey.com"><img src="http://www.gamekey.com/common/swatch.jpg"></a>');
document.write('</iframe>');
// -->
</SCRIPT>
<NOSCRIPT><A 
href="http://ad.doubleclick.net/jump/quakefiles.com/skunkworks;abr=!ie4;abr=!ie5;sz=468x60;tile=1"><IMG 
border=0 height=60 
src="Turrets Part 5_files/skunkworks;abr=!ie4;abr=!ie5;sz=468x60;tile=1.gif" 
width=468></A> <A href="http://www.gamekey.com/"><IMG 
src="Turrets Part 5_files/swatch.jpg"></A> </NOSCRIPT>
<CENTER>
<H1>Turrets:Part 5<BR>Optional extras</H1></CENTER>
<HR width="90%">

<P>Couple of extras here; A shielded turret where the shield recharges slowly, 
and a cloaking turret which uncloaks to fire. They both use a similar method, 
and both require changes to both the cgame module. For now they don't cost 
anything to use, that comes later.</P>
<HR width="100%">

<H2>GAME</H2>
<P>Well, the stuff that goes in the game folder anyway.</P>
<P>Open up <FONT class=file>bg_public.h</FONT>. Scroll down till you find the 
list below</P><PRE class=code>typedef enum {
	ET_GENERAL,
	ET_PLAYER,
	ET_ITEM,
	ET_MISSILE,
	ET_MOVER,
	ET_BEAM,
	ET_PORTAL,
	ET_SPEAKER,
	ET_PUSH_TRIGGER,
	ET_TELEPORT_TRIGGER,
	ET_INVISIBLE,
	ET_GRAPPLE,				// grapple hooked on wall

	ET_EVENTS				// any of the EV_* events can be added freestanding
							// by setting eType to ET_EVENTS + eventNum
							// this avoids having to set eFlags and eventNum
} entityType_t;
</PRE>
<P>We're wanting to add a new type of entity (the turret) so it can get it's own 
special effects. change the list so it looks like the one below (be careful of 
commas)</P><PRE class=code>typedef enum {
	ET_GENERAL,
	ET_PLAYER,
	ET_ITEM,
	ET_MISSILE,
	ET_MOVER,
	ET_BEAM,
	ET_PORTAL,
	ET_SPEAKER,
	ET_PUSH_TRIGGER,
	ET_TELEPORT_TRIGGER,
	ET_INVISIBLE,
	ET_GRAPPLE,				// grapple hooked on wall
	ET_TURRET,				// New type of entity. turrets. FuzzySteve 2000.

	ET_EVENTS				// any of the EV_* events can be added freestanding
							// by setting eType to ET_EVENTS + eventNum
							// this avoids having to set eFlags and eventNum
} entityType_t;
</PRE>
<P>That's us done with this file. This does change the cgame module so make sure 
that you recompile it if you want to test (I would leave it for now)</P>
<P>Next up is <FONT class=file>g_cmds.c</FONT>. The changes here are fairly 
large, as I have to make the turrets be destroyable (give them health and the 
functions so they can be hurt and die) as well as adding the code so they either 
cloak and decloak, or regenerate. I've set the code to work from the base's 
think (as its unused) and the turret's type (normal, shielded, cloaking 
(cloaked) and cloaking(uncloaked)) is stored in s.time2 (an unused field thats 
transmitted to the client)</P>
<P>As the changes are so big, here's all the code. Just replace what you have 
for the turrets with this.</P><PRE class=code>
/*
=======================
Turret code. for spawning and seting the spawn location of turrets
=======================
*/
#define RANGE 500

#define HARC 90
#define DARC 10
#define UARC 45




qboolean checktarget(gentity_t *firer,gentity_t *target){
vec3_t 		distance,forward;
trace_t         trace;
int		angle;

/*
returns qfalse if the target is not valid. returns qtrue if it is
*/

if (!target) // Do we have a target?
	return qfalse;
if (!target-&gt;inuse) // Does the target still exist?
	return qfalse;
if (target==firer) // is the target us?
	return qfalse;
if(!target-&gt;client) // is the target a bot or player?
	return qfalse;
//if (target==firer-&gt;parent) // is the target the person that created the turret?
//	return qfalse;
//if (OnSameTeam(firer-&gt;parent, target)) // is the target one of us?
//	return qfalse;

if (target-&gt;health&lt;0) // is the target still alive?
	return qfalse;

VectorSubtract(target-&gt;r.currentOrigin,firer-&gt;r.currentOrigin,distance);
if (VectorLength(distance)&gt;RANGE) // is the target within range?
	return qfalse;

trap_Trace (&amp;trace, firer-&gt;s.pos.trBase, NULL, NULL, target-&gt;s.pos.trBase, firer-&gt;s.number, MASK_SHOT );
if ( trace.contents &amp; CONTENTS_SOLID ) // can we see the target?
	return qfalse;
/*
The last two checks are done last as they require more processing power than the others.
this order is just better from a proccesing load perspective
*/

	vectoangles (distance,distance);
	VectorSubtract(firer-&gt;centerpoint,distance,distance);
	angle=abs((int)distance[1]);
	while (angle&gt;=360)
	{
	angle-=360;
	}
	if ((angle&gt;=HARC) &amp;&amp; (angle&lt;=(360-HARC)))
		return qfalse;
	angle=abs((int)distance[0]);
	while (angle&gt;=360)
	{
	angle-=360;
	}
	if ((angle&gt;UARC) &amp;&amp; (angle&lt;(360-DARC)))
		return qfalse;

return qtrue;
}




void turret_findenemy( gentity_t *ent){
	gentity_t *target;

	target = g_entities;

	for (; target &lt; &amp;g_entities[level.num_entities]; target++)
	{
		if(!checktarget(ent,target))
			continue;
		ent-&gt;enemy=target;
		return;
	}

	ent-&gt;enemy=NULL;
}



void turret_trackenemy( gentity_t *ent){
vec3_t dir;


VectorSubtract(ent-&gt;enemy-&gt;r.currentOrigin,ent-&gt;r.currentOrigin,dir);
VectorNormalize(dir);
VectorCopy(dir,ent-&gt;turloc);
vectoangles(dir,dir);
VectorCopy(dir,ent-&gt;s.angles);
VectorCopy(dir,ent-&gt;r.currentAngles);
VectorCopy( dir,ent-&gt;s.apos.trBase );
trap_LinkEntity (ent);

}

void turret_fireonenemy( gentity_t *ent){
fire_plasma( ent-&gt;activator, ent-&gt;r.currentOrigin, ent-&gt;turloc );
G_AddEvent( ent, EV_FIRE_WEAPON, 0 );
ent-&gt;count=level.time+200;
// decloaks a cloaked turret when firing.
if (ent-&gt;s.time2==2){
	ent-&gt;s.time2=3;
	ent-&gt;chain-&gt;s.time2=3;
	}
}




void turret_think( gentity_t *ent){

ent-&gt;nextthink=level.time+10;


if (!checktarget(ent,ent-&gt;enemy))
	turret_findenemy(ent);
if(!ent-&gt;enemy)
	return;
turret_trackenemy(ent);
if (ent-&gt;count&lt;level.time)
	turret_fireonenemy(ent);
}

void Base_think(gentity_t *ent){

// for shielded turrets. regenerates health to 400 at 10 health a second
if ((ent-&gt;s.time2==1)&amp;(ent-&gt;health&lt;400)){
	ent-&gt;health+=1;
	ent-&gt;nextthink=level.time+100;
}

// recloaks a turret without a valid target. checks once a second
if ((ent-&gt;s.time2==3)&amp;(!ent-&gt;chain-&gt;enemy))
	{
	ent-&gt;s.time2=2;
	ent-&gt;chain-&gt;s.time2=2;
	ent-&gt;nextthink=level.time+1000;
	}


}

void createturretgun(gentity_t *ent){
	gentity_t *turret; 	// The object to hold the turrets details.
	int			num;
	int			touch[MAX_GENTITIES];

// code to check there is noone within the base before making it solid
	vec3_t		mins, maxs;

	VectorAdd( ent-&gt;r.currentOrigin, ent-&gt;r.mins, mins );
	VectorAdd( ent-&gt;r.currentOrigin, ent-&gt;r.maxs, maxs );
	num = trap_EntitiesInBox( mins, maxs, touch, MAX_GENTITIES );
	if (num&gt;1)
	{
	ent-&gt;nextthink=level.time+1000;
	return;
	}

	ent-&gt;nextthink=level.time+100; // sets up the thinking for the cloaking or regeneration/
	ent-&gt;think=Base_think; // handles cloaking or regeneration
	ent-&gt;clipmask = CONTENTS_SOLID | CONTENTS_PLAYERCLIP;
	ent-&gt;r.contents = CONTENTS_SOLID;
	turret=G_Spawn();
	turret-&gt;parent=ent-&gt;parent;
	turret-&gt;chain=ent;
	ent-&gt;chain=turret;
	turret-&gt;s.eType=ET_TURRET;
	turret-&gt;s.time2=0;
	turret-&gt;eventTime=200;
	turret-&gt;s.number = turret - g_entities;
	turret-&gt;s.weapon=WP_PLASMAGUN;;
	turret-&gt;classname="turret";	
	turret-&gt;s.modelindex = G_ModelIndex("models/objects/turret/gun1.md3");
	turret-&gt;model = "models/objects/turret/gun1.md3";
	turret-&gt;s.modelindex2 = G_ModelIndex("models/objects/turret/gun1.md3");
	turret-&gt;think=turret_think;
	turret-&gt;nextthink=level.time+100;
	G_SetOrigin( turret, ent-&gt;r.currentOrigin );
	VectorCopy(ent-&gt;s.apos.trBase,turret-&gt;s.apos.trBase);
	VectorCopy(turret-&gt;s.apos.trBase,turret-&gt;centerpoint);
	trap_LinkEntity (turret);
}

void turret_retaliate(gentity_t *self, gentity_t *attacker, int damage){
// set the guns enemy to the person that shot it. (does not override targeting rules)
if (self-&gt;chain)
	self-&gt;chain-&gt;enemy=attacker;

// this is here to casue the turret to unshield when its taken a certain amount of damage. (enough to reduce health to below 100)
if (self-&gt;s.time2==1)
{
if (self-&gt;health&lt;100){
	self-&gt;s.time2=0;
	if (self-&gt;chain)
		self-&gt;chain-&gt;s.time2=0;
}
}
}



void turret_explode(gentity_t *self, gentity_t *inflictor, gentity_t *attacker, int damage, int mod){
/* This just blows up the base when its destroyed. took me some time to work it out */
	vec3_t dir; // needed by the event being added

	dir[0] = dir[1] = 0;
	dir[2] = 1;
if (self-&gt;chain)
	G_FreeEntity(self-&gt;chain); // get rid of the gun. // the gun just vanishes
self-&gt;s.weapon=WP_ROCKET_LAUNCHER; // to tell it what kind of explosion to use
G_AddEvent( self, EV_MISSILE_MISS, DirToByte( dir ) ); // to tell it to spawn an explosion here
self-&gt;freeAfterEvent = qtrue; // so the base goes away after the explosion
}



void Cmd_SpawnTurret_f( gentity_t *ent ){


	gentity_t	*base;
	vec3_t 		forward,up;

	base=G_Spawn();
	base-&gt;parent=ent;
	base-&gt;s.modelindex = G_ModelIndex("models/objects/turret/base.md3");
	base-&gt;model = "models/objects/turret/base.md3";
	base-&gt;s.modelindex2 = G_ModelIndex("models/objects/turret/base.md3");
	G_SetOrigin(base,ent-&gt;r.currentOrigin);
	VectorSet(base-&gt;s.apos.trBase,0,ent-&gt;s.apos.trBase[1],0);
	base-&gt;think=createturretgun;
	base-&gt;health=300; // change this to make the turrets tougher or weaker.
	base-&gt;s.eType=ET_TURRET;
	base-&gt;s.time2=0;
	base-&gt;takedamage=qtrue; // so they can be destoryed
	base-&gt;die=turret_explode; // so they actually explode when destroyed
	base-&gt;pain=turret_retaliate; // if they are damaged they switch target to the person attacking (if its a valid target)
	base-&gt;nextthink=level.time+5000;
	VectorSet( base-&gt;r.mins, -15, -15, -20 );
	VectorSet( base-&gt;r.maxs, 35, 15, -5);
	trap_LinkEntity (base);

}
</PRE>
<P>s.time2 stores the type of turret. 0 is a normal turret, 1 is a shielded 
turret, 2 is a cloaked turret, 3 is a cloaked turret thats firing (to let it 
know to recloak).</P>
<P>For now theres no way, other than to change the code and recompile it, to set 
it to spawn a different turret. However all you need to do is add a <A 
href="http://www.quakefiles.com/skunkworks/q3/commands.html">new command</A> and 
a <A href="http://www.quakefiles.com/skunkworks/q3/variables.html">new 
variable</A> that control what type gets spawned. Consider it homework (I'm 
lazy.)</P>
<P>That's us finished with the game module, on to the cgame module</P>
<HR width="90%">

<H2>CGAME</H2>
<P>Our first change to this has already been made as bg_public gets included in 
it.</P>
<P>The changes here are restriced to <FONT class=file>cg_ents.c</FONT>, so 
opening it up is a good pace to start</P>
<P>add the code below to that file, just below the <FONT 
class=code>#include</FONT> line. <PRE class=code>
// fuzzysteve turret effects
static void CG_TURRET(centity_t *cent)
{
	refEntity_t			ent;
	entityState_t		*s1;
	

	s1 = ¢-&gt;currentState;

	memset (&amp;ent, 0, sizeof(ent));

	VectorCopy( cent-&gt;lerpOrigin, ent.origin);
	VectorCopy( cent-&gt;lerpOrigin, ent.oldorigin);


	ent.frame = s1-&gt;frame;
	ent.oldframe = ent.frame;
	ent.backlerp = 0;
	// convert angles to axis
	AnglesToAxis( cent-&gt;lerpAngles, ent.axis );
	
	ent.hModel=cgs.gameModels[s1-&gt;modelindex];
	// add to refresh list
	switch (s1-&gt;time2){
	case 1:
		trap_R_AddRefEntityToScene (&amp;ent); // make the model show up
		ent.customShader=cgs.media.battleSuitShader;
		trap_R_AddRefEntityToScene (&amp;ent); // make the shader show up
		break;	
	case 2:
		ent.customShader=cgs.media.invisShader;
		trap_R_AddRefEntityToScene (&amp;ent); // make the shader show up. no model
		break;
	case 3:
		trap_R_AddRefEntityToScene (&amp;ent); // just add the model (uncloaked cloaking turret)
		break;
	default:
		trap_R_AddRefEntityToScene (&amp;ent); // if something else has happened
	}
}
</PRE>
<P>This is mostly a copy of CG_GENERAL. Its fairly easy to follow</P>
<P>Last change coming up. find the code below</P><PRE class=code>	
	case ET_PORTAL:
		CG_Portal( cent );
		break;
	case ET_SPEAKER:
		CG_Speaker( cent );
		break;
	case ET_GRAPPLE:
		CG_Grapple( cent );
		break;
	}
}
</PRE>
<P>and modify it to </P><PRE class=code>	case ET_PORTAL:
		CG_Portal( cent );
		break;
	case ET_SPEAKER:
		CG_Speaker( cent );
		break;
	case ET_GRAPPLE:
		CG_Grapple( cent );
		break;
	case ET_TURRET:
		CG_TURRET(cent);
		break;
	}
}
</PRE>
<P>That should be us. Compile both and try them out. you may want the shieleded 
turret to be a lot tougher than the normal and cloaked, just set the health 
higher. 
<HR width="50%">
<A href="http://www.quakefiles.com/skunkworks/q3/tutorial.html">Back to the 
tutorials</A><BR>
<ADDRESS><A href="mailto:problems@deathsdoor.com">Mail 
me</A></ADDRESS><BR><BR><BR></BODY></HTML>
