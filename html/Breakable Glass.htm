<SCRIPT SRC="http://ads.gamespy.com/jserver/SITE=PQ/AREA=HOSTED/GENRE=ACTION/TIER=3/AAMSZ=PRESTITIAL?304330078"></SCRIPT><!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0072)http://www.inolen.com/index.phtml?file=./programming/breakableglass.html -->
<HTML><HEAD><TITLE>www.inolen.com</TITLE>
<META content="text/html; charset=windows-1252" http-equiv=Content-Type>
<STYLE>A:link {
	COLOR: #336699; TEXT-DECORATION: none
}
A:visited {
	COLOR: #0000a0; TEXT-DECORATION: none
}
A:hover {
	COLOR: black; TEXT-DECORATION: underline
}
A:hover {
	TEXT-DECORATION: overline
}
</STYLE>

<META content="MSHTML 5.00.2614.3500" name=GENERATOR></HEAD>
<BODY bgColor=#eeeeee leftMargin=0 text=#000000 topMargin=0>
<DIV align=center>
<TABLE align=center border=0 cellPadding=0 cellSpacing=0 hspace="0" 
  vspace="0"><TBODY>
  <TR>
    <TD align=middle bgColor=#eeeeee borderColor=#000000 colSpan=2 
      vAlign=top><IMG height=150 src="Breakable Glass_files/logo.jpg" width=300> 
    </TD></TR></TBODY></TABLE>
<TABLE align=center border=1 borderColorDark=#ffffff borderColorLight=#000000 
cellPadding=0 cellSpacing=0 width="80%" hspace="0" vspace="0">
  <TBODY>
  <TR align=middle vAlign=center>
    <TD bgColor=#ffffff colSpan=2>
      <DIV align=center><FONT face=Tahoma size=1><B><A 
      href="http://www.inolen.com/index.phtml"><FONT face=Tahoma 
      size=2>Main</FONT></A>&nbsp; |&nbsp; <A 
      href="http://www.inolen.com/index.phtml?file=./maps.html"><FONT 
      face=Tahoma size=2>Maps</FONT></A><FONT face=Tahoma size=2>&nbsp; |&nbsp; 
      <A 
      href="http://www.inolen.com/index.phtml?file=./programming.html">Programming</A>&nbsp;|&nbsp;<A 
      href="http://www.inolen.com/index.phtml?file=./links.html">Links</A>&nbsp;|&nbsp; 
      <A 
      href="http://www.inolen.com/index.phtml?file=./files.html">Files</A>&nbsp;|&nbsp; 
      <A 
      href="http://www.inolen.com/index.phtml?file=./demos.html">Demos</A>&nbsp;|&nbsp; 
      <A href="http://www.inolen.com/cgi-bin/Ultimate.cgi?action=intro" 
      target=_blank>Forums</A></FONT></B></FONT> </DIV></TD></TR>
  <TR>
    <TD align=middle background="Breakable Glass_files/side.jpg" vAlign=top 
    width=115>
      <FORM action=http://www.inolen.com/cgi-bin/NewsPro/viewnews.cgi?search 
      method=post><INPUT name=searchstring 
      onblur="if (value == '') {value = 'Search News'}" 
      onfocus="if (value == 'Search News') {value =''}" size=13 
      style="BACKGROUND-COLOR: #ffffff; BORDER-BOTTOM: #336699 1px solid; BORDER-LEFT: #336699 1px solid; BORDER-RIGHT: #336699 1px solid; BORDER-TOP: #336699 1px solid; COLOR: #336699; FONT-FAMILY: Tahoma" 
      value="Search News"> </FORM></TD>
    <TD align=left bgColor=#ffffff vAlign=top>
      <P><FONT color=#000000 face=Tahoma size=2><B>This tut lets your mod have 
      BREAKABLE GLASS! Sweet, eh? OK, this is actually fairly easy. I wanna 
      thank <A href="http://quake3.barrysworld.net/mod_dev">Wang</A> for helping 
      me with the code and <A 
      href="http://www.planetquake.com/annihilation">Kalifa</A> for the glass 
      models. Whoops, I can't forget <A 
      href="http://personal.lig.bellsouth.net/lig/d/f/dfrey/">Mastaba</A> for 
      the help on the random code. You need to grab the <A 
      href="http://www.inolen.com/programming/glassmedia.pk3">media pack</A> for 
      this tut and optionally my <A 
      href="http://www.inolen.com/programming/glassmap.pk3">sample map</A>. 
      Note: Mappers need to first, make it a func_door(anything will do) then 
      press "n" and change the func_door to func_breakable, or optionally edit 
      the "entities.def" file and add in func_breakable, so you can just select 
      it from the normal drop down list in Q3Radiant. They also need to set the 
      life of the glass by pressing "n" while selecting the entity and in the 
      key box type in "health" and in the value box type in whatever NUMBER of 
      life it should have. If you dont it defaults to 5 life. Your mapper needs 
      to add the ifx.shader into their baseq3/scripts directory as well as their 
      mymod/scripts folder. You will want he/she to edit the shaderlist.txt in 
      their baseq3/scripts directory and add at the VERY bottom<BR>ifx<BR>Your 
      mapper needs to have done that so upon compile it does the lightmap and 
      everything correctly. And guess what? I actually commented this tutorial 
      pretty well. </B></FONT></P>
      <P><B><FONT color=#000000 face=Tahoma size=2>OK, first lets add our 
      function for when Quake3 recognizes the glass. Add this to the bottom of 
      g_misc.c:</FONT></B></P><PRE><FONT color=#0000a0 face=Tahoma size=2><B>/*QUAKED func_breakable (1 0 0) (-16 -16 -16) (16 16 16)
 Explodes glass
 */
 void SP_func_breakable( gentity_t *ent ) {
  int health;
  
  // Make it appear as the brush
  trap_SetBrushModel( ent, ent-&gt;model );
  // Lets give it 5 health if the mapper did not set its health
  G_SpawnInt( "health", "0", &amp;health );
  if( health &lt;= 0 )
   health = 5;
 
  ent-&gt;health = health;
  // Let it take damage
  ent-&gt;takedamage = qtrue;
  // Let it know it is a breakable object
  ent-&gt;s.eType = ET_BREAKABLE;
  // If the mapper gave it a model, use it
  if ( ent-&gt;model2 ) {
      ent-&gt;s.modelindex2 = G_ModelIndex( ent-&gt;model2 );
  }
  // Link all ^this^ info into the ent
  trap_LinkEntity (ent);
 }</B></FONT></PRE>
      <P><FONT face=Tahoma size=2><B>Below that code lets add the function that 
      G_Damage calls to see if we can break it yet:</B></FONT></P><PRE><FONT color=#0000a0 face=Tahoma size=2><B>/*
 =================
 G_BreakGlass
 =================
 */
 void G_BreakGlass(gentity_t *ent, vec3_t point, int mod) {
     gentity_t   *tent;
 	vec3_t      size;
     vec3_t      center;
 	qboolean    splashdmg;
 	
 	// Get the center of the glass
     VectorSubtract(ent-&gt;r.maxs, ent-&gt;r.mins, size);
     VectorScale(size, 0.5, size);
     VectorAdd(ent-&gt;r.mins, size, center);
 
 	// If the glass has no more life, BREAK IT
 	if( ent-&gt;health &lt;= 0 ) {
 	G_FreeEntity( ent );
     // Tell the program based on the gun if it has no splash dmg, no reason to ad ones with
 	// splash dmg as qtrue as is that is the default
 	switch( mod ) {
 		case MOD_GAUNTLET:
 		splashdmg = qfalse;
 		break;
 		case MOD_SHOTGUN:
 		splashdmg = qfalse;
 		break;
 		case MOD_MACHINEGUN:
 		splashdmg = qfalse;
 		break;
 		case MOD_RAILGUN:
 		splashdmg = qfalse;
 		break;
 		case MOD_LIGHTNING:
 		splashdmg = qfalse;
 		break;
 		default:
 		splashdmg = qtrue;
 		break;
 	}
 	// Call the function to show the glass shards in cgame
 	// center can be changed to point which will spawn the
 	// where the killing bullet hit but wont work with Splash Damage weapons
 	// so I just use the center of the glass
 	switch( splashdmg ){
 	case qtrue:
     tent = G_TempEntity( center, EV_BREAK_GLASS );
 	break;
 	case qfalse:
     tent = G_TempEntity( point, EV_BREAK_GLASS );
 	break;
 	}
 	tent-&gt;s.eventParm = 0;
 	}
 }</B></FONT>
  </PRE>
      <P><FONT face=Tahoma size=2><B>Now lets let G_BreakGlass be called from 
      g_combat.c. Open up g_local.h and find:</B></FONT></P><PRE><FONT color=#ff0000 face=Tahoma size=2><B>//
 // g_misc.c
 //
 void TeleportPlayer( gentity_t *player, vec3_t origin, vec3_t angles ); </B></FONT></PRE>
      <P><FONT face=Tahoma size=2><B>Below it place:</B></FONT></P><PRE><FONT color=#0000a0 face=Tahoma size=2><B>void G_BreakGlass( gentity_t *ent, vec3_t point, int mod );</B></FONT></PRE>
      <P><FONT face=Tahoma size=2><B>Thats all we got to do with g_misc.c, now 
      lets go to g_spawn.c and find this:</B></FONT></P><PRE><FONT color=#ff0000 face=Tahoma size=2><B>void SP_func_timer (gentity_t *self);</B></FONT></PRE>
      <P><FONT face=Tahoma size=2><B>And below it add:</B></FONT></P>
      <P><FONT color=#0000a0 face=Tahoma size=2><B>void SP_func_breakable 
      (gentity_t *ent);</B></FONT></P>
      <P><FONT face=Tahoma size=2><B>Now find:</B></FONT></P><PRE><FONT color=#ff0000 face=Tahoma size=2><B>	{"func_timer", SP_func_timer},			// rename trigger_timer?</B></FONT></PRE>
      <P><FONT face=Tahoma size=2><B>Below it place:</B></FONT></P><PRE><FONT color=#0000a0 face=Tahoma size=2><B>	{"func_breakable", SP_func_breakable},</B></FONT></PRE>
      <P><FONT face=Tahoma size=2><B>Thats it with g_spawn.c. In case you want 
      to know, that last line we added tells it to call our SP_func_breakable 
      function when it finds a func_breakable in the map. Open up g_combat.c and 
      find:</B></FONT></P><PRE><FONT color=#ff0000 face=Tahoma size=2><B>	// shootable doors / buttons don't actually have any health
 	if ( targ-&gt;s.eType == ET_MOVER ) {
 		if ( targ-&gt;use &amp;&amp; targ-&gt;moverState == MOVER_POS1 ) {
 			targ-&gt;use( targ, inflictor, attacker );
 		}
 		return;
 	}</B></FONT></PRE>
      <P><FONT face=Tahoma size=2><B>Under it add:</B></FONT></P><PRE><FONT color=#0000a0 face=Tahoma size=2><B>	// If we shot a breakable item subtract the damage from its health and try to break it
 	if ( targ-&gt;s.eType == ET_BREAKABLE ) {
         targ-&gt;health -= damage;
 		G_BreakGlass( targ, point, mod );
 		return;
 	}</B></FONT></PRE>
      <P><FONT face=Tahoma size=2><B>OK, we are done with g_combat.c, now we 
      gotta get the bots to shoot the glass! So open up ai_dmq3.c and 
      find:</B></FONT></P><PRE><FONT color=#ff0000 face=Tahoma size=2><B>	//if it is a door
 	if (!strcmp(classname, "func_door")) {
 		if (trap_AAS_FloatForBSPEpairKey(ent, "health", &amp;health)) {
 			//if health the door must be shot to open
 			if (health) return ent;
 		}
 	}</B></FONT></PRE>
      <P><FONT face=Tahoma size=2><B>Below it add:</B></FONT></P><PRE><FONT color=#0000a0 face=Tahoma size=2><B>	//if it is some glass
 	if (!strcmp(classname, "func_breakable")) {
 		return ent;
 	}</B></FONT></PRE>
      <P><FONT face=Tahoma size=2><B>Now the last edit for this file, go 
      find:</B></FONT></P><PRE><FONT color=#ff0000 face=Tahoma size=2><B>		else if (!strcmp(classname, "func_door")) {
 			//shoot at the shootable door
 			trap_AAS_ValueForBSPEpairKey(ent, "model", model, sizeof(model));
 			modelindex = atoi(model+1);
 			//if the model is not loaded
 			if (!modelindex) return;
 			VectorClear(angles);
 			BotModelMinsMaxs(modelindex, ET_MOVER, mins, maxs);
 			//door origin
 			VectorAdd(mins, maxs, origin);
 			VectorScale(origin, 0.5, origin);
 			//
 			VectorSubtract(origin, bs-&gt;eye, movedir);
 			vectoangles(movedir, moveresult-&gt;ideal_viewangles);
 			moveresult-&gt;flags |= MOVERESULT_MOVEMENTVIEW;
 			moveresult-&gt;flags |= MOVERESULT_MOVEMENTWEAPON;
 			//select the machinegun and shoot
 			trap_EA_SelectWeapon(bs-&gt;client, WEAPONINDEX_MACHINEGUN);
 			if (bs-&gt;cur_ps.weapon == WEAPONINDEX_MACHINEGUN) {
 				trap_EA_Attack(bs-&gt;client);
 			}
 			return;
 		}</B></FONT></PRE>
      <P><FONT face=Tahoma size=2><B>Agin, directly below it add:</B></FONT></P><PRE><FONT color=#0000a0 face=Tahoma size=2><B>		else if (!strcmp(classname, "func_breakable")) {
 			//shoot at the shootable door
 			trap_AAS_ValueForBSPEpairKey(ent, "model", model, sizeof(model));
 			modelindex = atoi(model+1);
 			//if the model is not loaded
 			if (!modelindex) return;
 			VectorClear(angles);
 			BotModelMinsMaxs(modelindex, ET_BREAKABLE, mins, maxs);
 			//door origin
 			VectorAdd(mins, maxs, origin);
 			VectorScale(origin, 0.5, origin);
 			//
 			VectorSubtract(origin, bs-&gt;eye, movedir);
 			vectoangles(movedir, moveresult-&gt;ideal_viewangles);
 			moveresult-&gt;flags |= MOVERESULT_MOVEMENTVIEW;
 			moveresult-&gt;flags |= MOVERESULT_MOVEMENTWEAPON;
 			//select the machinegun and shoot
 			trap_EA_SelectWeapon(bs-&gt;client, WEAPONINDEX_MACHINEGUN);
 			if (bs-&gt;cur_ps.weapon == WEAPONINDEX_MACHINEGUN) {
 				trap_EA_Attack(bs-&gt;client);
 			}
 			return;
 		}</B></FONT></PRE>
      <P><FONT face=Tahoma size=2><B>Thats all for ai_dmq3.c! What that does is 
      first is says if there is a func_breakable, it MUST be shot to 
      open/unblock its path/whatever. Then in <FONT 
      color=#ff0000>BotAIBlocked</FONT> it looks for func_breakable and if its 
      there, the bot pulls out his boomstick and shoots it. Now we are nearly 
      done with the game part of this. So lets keep on rolling. All we got left 
      is to open up bg_public.h and add some stuff. So open it up and 
      find:</B></FONT></P><PRE><FONT color=#ff0000 face=Tahoma size=2><B>typedef enum {
 	ET_GENERAL,
 	ET_PLAYER,
 	ET_ITEM,
 	ET_MISSILE,
 	ET_MOVER,</B></FONT></PRE>
      <P><FONT face=Tahoma size=2><B>Add below it:</B></FONT></P><PRE><FONT color=#0000a0 face=Tahoma size=2><B>	ET_BREAKABLE,</B></FONT></PRE>
      <P><FONT face=Tahoma size=2><B>One last thing! Find this:</B></FONT></P><PRE><FONT color=#ff0000 face=Tahoma size=2><B>	EV_GIB_PLAYER,			// gib a previously living player</B></FONT></PRE>
      <P><FONT face=Tahoma size=2><B>And below it add:</B></FONT></P><PRE><FONT color=#0000a0 face=Tahoma size=2><B>	EV_BREAK_GLASS,</B></FONT></PRE>
      <P><FONT face=Tahoma size=2><B>Now, thats it for the game module! So go to 
      cg_local.h and find:</B></FONT></P><PRE><FONT color=#ff0000 face=Tahoma size=2><B>	qhandle_t	gibLeg;
 	qhandle_t	gibSkull;
 	qhandle_t	gibBrain;</B></FONT></PRE>
      <P><FONT face=Tahoma size=2><B>Add below it:</B></FONT></P><PRE><FONT color=#0000a0 face=Tahoma size=2><B>	qhandle_t	glass01;
 	qhandle_t	glass02;
 	qhandle_t	glass03;</B></FONT></PRE>
      <P><FONT face=Tahoma size=2><B>Now find:</B></FONT></P><PRE><FONT color=#ff0000 face=Tahoma size=2><B>void CG_GibPlayer( vec3_t playerOrigin );</B></FONT></PRE>
      <P><FONT face=Tahoma size=2><B>And add below it:</B></FONT></P><PRE><FONT color=#0000a0 face=Tahoma size=2><B>void CG_BreakGlass( vec3_t playerOrigin );</B></FONT></PRE>
      <P><FONT face=Tahoma size=2><B>Thats it for cg_local.h, lets open up 
      cg_main.c and register the models. Find:</B></FONT></P><PRE><FONT color=#ff0000 face=Tahoma size=2><B>	cgs.media.gibLeg = trap_R_RegisterModel( "models/gibs/leg.md3" );
 	cgs.media.gibSkull = trap_R_RegisterModel( "models/gibs/skull.md3" );
 	cgs.media.gibBrain = trap_R_RegisterModel( "models/gibs/brain.md3" );</B></FONT></PRE>
      <P><FONT face=Tahoma size=2><B>Like always, below it add:</B></FONT></P><PRE><FONT color=#0000a0 face=Tahoma size=2><B>	cgs.media.glass01 = trap_R_RegisterModel( "models/breakables/glass01.md3" );
 	cgs.media.glass02 = trap_R_RegisterModel( "models/breakables/glass02.md3" );
 	cgs.media.glass03 = trap_R_RegisterModel( "models/breakables/glass03.md3" );</B></FONT></PRE>
      <P><FONT face=Tahoma size=2><B>Go open up cg_event.c and 
      find:</B></FONT></P><PRE><FONT color=#ff0000 face=Tahoma size=2><B>	case EV_GIB_PLAYER:
 		DEBUGNAME("EV_GIB_PLAYER");
 		trap_S_StartSound( NULL, es-&gt;number, CHAN_BODY, cgs.media.gibSound );
 		CG_GibPlayer( cent-&gt;lerpOrigin );
 		break;</B></FONT></PRE>
      <P><FONT face=Tahoma size=2><B>Below it add:</B></FONT></P><PRE><FONT color=#0000a0 face=Tahoma size=2><B>	case EV_BREAK_GLASS:
 		DEBUGNAME("EV_BREAK_GLASS");
 		// Change cgs.media.gibSound to whatever sound you want it to use
 		// I think the gib sound sounds pretty good
 		trap_S_StartSound( NULL, es-&gt;number, CHAN_BODY, cgs.media.gibSound );
 		CG_BreakGlass( cent-&gt;lerpOrigin );
 		break;</B></FONT></PRE>
      <P><FONT face=Tahoma size=2><B>Now open up cg_effects.c, we need to add 
      the functions that produce the gibs, so at the bottom of the file 
      add:</B></FONT></P><PRE><FONT color=#0000a0 face=Tahoma size=2><B>/*
 ==================
 CG_LaunchGlass
 ==================
 */
 void CG_LaunchGlass( vec3_t origin, vec3_t velocity, qhandle_t hModel ) {
 	localEntity_t	*le;
 	refEntity_t		*re;
 
 	le = CG_AllocLocalEntity();
 	re = &amp;le-&gt;refEntity;
 
 	le-&gt;leType = LE_FRAGMENT;
 	le-&gt;startTime = cg.time;
 	le-&gt;endTime = le-&gt;startTime + 30000 + random() * 3000;
 
 	VectorCopy( origin, re-&gt;origin );
 	AxisCopy( axisDefault, re-&gt;axis );
 	re-&gt;hModel = hModel;
 
 	le-&gt;pos.trType = TR_GRAVITY;
 	VectorCopy( origin, le-&gt;pos.trBase );
 	VectorCopy( velocity, le-&gt;pos.trDelta );
 	le-&gt;pos.trTime = cg.time;
 
 	le-&gt;bounceFactor = 0.3;
 
 	le-&gt;leFlags = LEF_TUMBLE;
 	le-&gt;leBounceSoundType = LEBS_BRASS;
 	le-&gt;leMarkType = LEMT_NONE;
 }
 
 /*
 ===================
 CG_BreakGlass
 
 Generated a bunch of glass shards launching out from the glass location
 ===================
 */
 #define	GLASS_VELOCITY	175
 #define	GLASS_JUMP		125
 void CG_BreakGlass( vec3_t playerOrigin ) {
 	vec3_t	origin, velocity;
     int     value;
 	// How many shards to generate
 	int     count = 50;
 	// The array of possible numbers
 	int     states[] = {1,2,3};
 	// Get the size of the array
     int     numstates = sizeof(states)/sizeof(states[0]);
 
 	// Countdown "count" so this will subtract 1 from the "count"
 	// X many times. X being the "count" value
 	while ( count-- ) {
 	// Generate the random number every count so every shard is a
 	// of the three. If this is placed above it only gets a random
 	// number every time a piece of glass is broken.
 	value = states[rand()%numstates];
 	VectorCopy( playerOrigin, origin );
 	velocity[0] = crandom()*GLASS_VELOCITY;
 	velocity[1] = crandom()*GLASS_VELOCITY;
 	velocity[2] = GLASS_JUMP + crandom()*GLASS_VELOCITY;
 	switch (value) {
 	case 1:
 	// If our random number was 1, generate the 1st shard piece
     CG_LaunchGlass( origin, velocity, cgs.media.glass01 );
     break;
 	case 2:
 	CG_LaunchGlass( origin, velocity, cgs.media.glass02 );
     break;
 	case 3:
 	CG_LaunchGlass( origin, velocity, cgs.media.glass03 );
 	break;
 	}
 	}
 }</B></FONT>
 </PRE>
      <P><FONT face=Tahoma size=2><B>Now the the VERY last step. We gotta let it 
      know how to draw this object. In cg_ents.c, find:</B></FONT></P><PRE><FONT color=#ff0000 face=Tahoma size=2><B>	case ET_MOVER:
 		CG_Mover( cent );
 		break;</B></FONT></PRE>
      <P><FONT face=Tahoma size=2><B>And below it place:</B></FONT></P><PRE><FONT color=#0000a0 face=Tahoma size=2><B>	case ET_BREAKABLE:
 		CG_Mover( cent );
 		break;</B></FONT></PRE>
      <P><FONT face=Tahoma size=2><B>Yes, the ET_BREAKABLE is suppost to call 
      CG_Mover. All that function does is tell the engine how to render it. And 
      CG_Mover is the exact way we want to render our glass. Compile ALL 3 
      projects and enjoy.</B></FONT></P>
      <P><FONT color=#000000 face=Tahoma size=2><B>I spend my time programming 
      and writing these tutorials, so please feel free to use this code in your 
      mod as long as www.inolen.com and the author receive 
    credit.</B></FONT></P></TD></TR>
  <TR>
    <TD align=middle bgColor=#f9f9f9 colSpan=2 vAlign=center><FONT 
      color=#000000 face=Tahoma size=2><B>Design Copyright inolen 
    2000</B></FONT></TD></TR></TBODY></TABLE></DIV></BODY></HTML>
