<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0052)http://www.quakefiles.com/skunkworks/q3/weapons.html -->
<HTML><HEAD><TITLE>Explanation of weapons</TITLE>
<META content="text/html; charset=windows-1252" http-equiv=Content-Type><LINK 
href="Explanation of weapons_files/skunk.css" rel=STYLESHEET type=text/css>
<META content="MSHTML 5.00.2919.6307" name=GENERATOR></HEAD>
<BODY text=white>
<SCRIPT language=JavaScript>
<!--
var begin = new Date()
var startYear = new Date("January 1, 1970")
startYear.setYear(begin.getYear())
var random = (begin.getTime() - startYear.getTime())
document.write('<a href="http://ad.doubleclick.net/jump/quakefiles.com/skunkworks;sz=468x60;tile=1;ord=' + random + '">');
document.write('<img src="http://ad.doubleclick.net/ad/quakefiles.com/skunkworks;sz=468x60;tile=1;ord=' + random + '" height=60 width=468>' + '</a>');
document.write(' <A HREF="http://www.gamekey.com"><img src="http://www.gamekey.com/common/swatch.jpg"></a>');
document.write('</iframe>');
// -->
</SCRIPT>
<NOSCRIPT><A 
href="http://ad.doubleclick.net/jump/quakefiles.com/skunkworks;abr=!ie4;abr=!ie5;sz=468x60;tile=1"><IMG 
border=0 height=60 
src="Explanation of weapons_files/skunkworks;abr=!ie4;abr=!ie5;sz=468x60;tile=1.gif" 
width=468></A> <A href="http://www.gamekey.com/"><IMG 
src="Explanation of weapons_files/swatch.jpg"></A> </NOSCRIPT>
<CENTER>
<H1>Explanation of weapons</H1></CENTER><BR>
<P>Hmmm, I'd say that weapons in q3 are one of the hardest things to modify 
(from what I've seen so far). I got set on this by someone asking how to make 
different weapons use the same kind of ammo. It is doable, but requires a 
rewrite of the ammo handling code. The problem is the weapon firing code is 
actually split into a number of different pieces that stick requests into a 
stack, and these requests get grabbed elsewhere and acted on.</P>
<HR width="50%">

<P>I'll go through this in the order of things that make a weapon fire.</P>
<OL>
  <LI>Weapon definition in bg_misc.c (game) 
  <LI>Ammo definition in bg_misc.c (game) 
  <LI>Pmove (bg_pmove.c game) is called by client or server 
  <LI>Pmovesingle (bg_pmove.c game) is called by pmove 
  <LI>PM_Weapon (bg_pmove.c game) is called by Pmovesingle 
  <LI>PM_Weapon checks for firing, and removes some ammo before firing the 
  weapon 
  <LI>PM_Weapon adds a weapon firing event to the players stack 
  <LI>PM_Weapon adds some time to a counter preventing the user from firing 
  again for a set time 
  <LI>ClientEvents (g_active.c game) checks the stack and finds a weapon firing 
  event. 
  <LI>FireWeapon (g_weapon.c game) is called by ClientEvents 
  <LI>FireWeapon sets up the aiming angles then calls the relevant weapon 
  function (same file) 
  <LI>The weapons do different things dependant on which they are. </LI></OL>
<HR width="100%">

<H2>Weapon definition in bg_misc.c (game)</H2>
<P>Of the form :</P>
<TABLE align=center border=1 width="80%">
  <TBODY>
  <TR>
    <TD>/*QUAKED weapon_shotgun (.3 .3 1) (-16 -16 -16) (16 16 16) 
      suspended<BR>*/</TD>
    <TD>Just a decription. not important to you</TD></TR>
  <TR>
    <TD>{</TD>
    <TD>begining of definition</TD></TR>
  <TR>
    <TD>"weapon_shotgun", </TD>
    <TD>The name of the object in a map file</TD></TR>
  <TR>
    <TD>"sound/misc/w_pkup.wav",</TD>
    <TD>The noise when you pick it up</TD></TR>
  <TR>
    <TD>{ "models/weapons2/shotgun/shotgun.md3", <BR>0, 0, 0},</TD>
    <TD>The model for the weapon, i'm not sure what the coords are for</TD></TR>
  <TR>
    <TD>/* icon */ "icons/iconw_shotgun",</TD>
    <TD>The icon that shows up</TD></TR>
  <TR>
    <TD>/* pickup */ "Shotgun",</TD>
    <TD>The pickup name for the weapon (what shows up when you pick it up) 
  </TD></TR>
  <TR>
    <TD>10,</TD>
    <TD>Default ammo</TD></TR>
  <TR>
    <TD>IT_WEAPON,</TD>
    <TD>Item type</TD></TR>
  <TR>
    <TD>WP_SHOTGUN,</TD>
    <TD>Weapon identifier(from bg_public.h)</TD></TR>
  <TR>
    <TD>/* precache */ "",</TD>
    <TD>Precaches for weapon</TD></TR>
  <TR>
    <TD>/* sounds */ ""</TD>
    <TD>Sound precaches for weapon</TD></TR>
  <TR>
    <TD>},</TD>
    <TD>end of definition</TD></TR></TBODY></TABLE>
<P>I've added comments above</P>
<HR width="100%">

<H2>Ammo definition in bg_misc.c (game)</H2>
<TABLE align=center border=1 width="80%">
  <TBODY>
  <TR>
    <TD>/*QUAKED ammo_shells (.3 .3 1) (-16 -16 -16) (16 16 16) suspended 
      */<BR></TD></TR>
  <TR>
    <TD>{</TD>
    <TD>begining of definition</TD></TR>
  <TR>
    <TD>"ammo_shells",</TD>
    <TD>Map entity name</TD></TR>
  <TR>
    <TD>"sound/misc/am_pkup.wav",</TD>
    <TD>Sound when you pick it up</TD></TR>
  <TR>
    <TD>{ "models/powerups/ammo/shotgunam.md3", <BR>0, 0, 0},</TD>
    <TD>Model for ammo</TD></TR>
  <TR>
    <TD>/* icon */ "icons/icona_shotgun",</TD>
    <TD>Icon for ammo</TD></TR>
  <TR>
    <TD>/* pickup */ "Shells",</TD>
    <TD>Pickup name of ammo</TD></TR>
  <TR>
    <TD>10,</TD>
    <TD>Quantity in box</TD></TR>
  <TR>
    <TD>IT_AMMO,</TD>
    <TD>Item type</TD></TR>
  <TR>
    <TD>WP_SHOTGUN,</TD>
    <TD>Weapon ammo is for</TD></TR>
  <TR>
    <TD>/* precache */ "",</TD>
    <TD>Item precaches</TD></TR>
  <TR>
    <TD>/* sounds */ ""</TD>
    <TD>Sound precaches for weapon</TD></TR>
  <TR>
    <TD>},</TD>
    <TD>end of definition</TD></TR></TBODY></TABLE>
<HR width="100%">

<H2>Pmove (bg_pmove.c game) is called by client or server</H2>
<P>Not much for you to do here</P>
<HR width="100%">

<H2>Pmovesingle (bg_pmove.c game) is called by pmove</H2>
<P>Ditto</P>
<HR width="100%">

<H2>PM_Weapon (bg_pmove.c game) is called by Pmovesingle</H2>
<P>Not much for you here. only bit that might be of interest is</P><PRE class=code>	// set the firing flag for continuous beam weapons
	if ( !(pm-&gt;ps-&gt;pm_flags &amp; PMF_RESPAWNED) &amp;&amp; pm-&gt;ps-&gt;pm_type != PM_INTERMISSION
		&amp;&amp; ( pm-&gt;cmd.buttons &amp; BUTTON_ATTACK ) &amp;&amp; pm-&gt;ps-&gt;ammo[ pm-&gt;ps-&gt;weapon ] ) {
		pm-&gt;ps-&gt;eFlags |= EF_FIRING;
	} else {
		pm-&gt;ps-&gt;eFlags &amp;= ~EF_FIRING;
	}
</PRE>
<HR width="100%">

<H2>PM_Weapon checks for firing, and removes some ammo before firing the 
weapon</H2>
<H2>PM_Weapon adds a weapon firing event to the players stack</H2>
<H2>PM_Weapon adds some time to a counter preventing the user from firing again 
for a set time</H2>
<P>Fair amount here. I've added comments to the code below (marked with 
(FS))</P><PRE class=code>
/*
==============
PM_Weapon

Generates weapon events and modifes the weapon counter
==============
*/
static void PM_Weapon( void ) {
	int		addTime;

/* everything has been defined as global variables here (global withing this file at least) 
 so player is defined in pm as a pmove_t . ps is a player state variable in pm (FS)*/

	// don't allow attack until all buttons are up
	if ( pm-&gt;ps-&gt;pm_flags &amp; PMF_RESPAWNED ) {   // kinda obvious here (FS)
		return;
	}



	// ignore if spectator
	if ( pm-&gt;ps-&gt;persistant[PERS_TEAM] == TEAM_SPECTATOR ) {
		return;
	}

	// check for dead player
	if ( pm-&gt;ps-&gt;stats[STAT_HEALTH] &lt;= 0 ) {
		pm-&gt;ps-&gt;weapon = WP_NONE;
		return;
	}

	// check for item using
	if ( pm-&gt;cmd.buttons &amp; BUTTON_USE_HOLDABLE ) {
		if ( ! ( pm-&gt;ps-&gt;pm_flags &amp; PMF_USE_ITEM_HELD ) ) {
			if ( bg_itemlist[pm-&gt;ps-&gt;stats[STAT_HOLDABLE_ITEM]].giTag == HI_MEDKIT
				&amp;&amp; pm-&gt;ps-&gt;stats[STAT_HEALTH] &gt;= pm-&gt;ps-&gt;stats[STAT_MAX_HEALTH] ) {
				// don't use medkit if at max health
			} else {
				pm-&gt;ps-&gt;pm_flags |= PMF_USE_ITEM_HELD;
				PM_AddEvent( EV_USE_ITEM0 + bg_itemlist[pm-&gt;ps-&gt;stats[STAT_HOLDABLE_ITEM]].giTag );
				pm-&gt;ps-&gt;stats[STAT_HOLDABLE_ITEM] = 0;
			}
			return;
		}
	} else {
		pm-&gt;ps-&gt;pm_flags &amp;= ~PMF_USE_ITEM_HELD;
	}


	// make weapon function
	if ( pm-&gt;ps-&gt;weaponTime &gt; 0 ) {
		pm-&gt;ps-&gt;weaponTime -= pml.msec; // Makes sure the timer between shots is reduced (FS) 
	}

	// check for weapon change
	// can't change if weapon is firing, but can change
	// again if lowering or raising
	if ( pm-&gt;ps-&gt;weaponTime &lt;= 0 || pm-&gt;ps-&gt;weaponstate != WEAPON_FIRING ) {
		if ( pm-&gt;ps-&gt;weapon != pm-&gt;cmd.weapon ) {
			PM_BeginWeaponChange( pm-&gt;cmd.weapon );
		}
	}

	if ( pm-&gt;ps-&gt;weaponTime &gt; 0 ) {
		return;							// If the timer hasn't elasped, there nothing else you can do here (FS)
	}

	// change weapon if time
	if ( pm-&gt;ps-&gt;weaponstate == WEAPON_DROPPING ) {
		PM_FinishWeaponChange();
		return;
	}

	if ( pm-&gt;ps-&gt;weaponstate == WEAPON_RAISING ) {
		pm-&gt;ps-&gt;weaponstate = WEAPON_READY;
		if ( pm-&gt;ps-&gt;weapon == WP_GAUNTLET ) {
			PM_StartTorsoAnim( TORSO_STAND2 );
		} else {
			PM_StartTorsoAnim( TORSO_STAND );
		}
		return;
	}

	// check for fire
	if ( ! (pm-&gt;cmd.buttons &amp; 1) ) {
		pm-&gt;ps-&gt;weaponTime = 0; // by now its either 0 or less but you're not firing so finish (FS)
		pm-&gt;ps-&gt;weaponstate = WEAPON_READY;
		return;
	}



	// start the animation even if out of ammo
	if ( pm-&gt;ps-&gt;weapon == WP_GAUNTLET ) {
		// the guantlet only "fires" when it actually hits something
		if ( !pm-&gt;gauntletHit ) {
			pm-&gt;ps-&gt;weaponTime = 0;
			pm-&gt;ps-&gt;weaponstate = WEAPON_READY;
			return;
		}
		PM_StartTorsoAnim( TORSO_ATTACK2 );
	} else {
		PM_StartTorsoAnim( TORSO_ATTACK );
	}

	pm-&gt;ps-&gt;weaponstate = WEAPON_FIRING;
// as by now the weapon is being fired and the timer has elapsed (FS)

	// check for out of ammo
	if ( ! pm-&gt;ps-&gt;ammo[ pm-&gt;ps-&gt;weapon ] ) {
		PM_AddEvent( EV_NOAMMO );
		pm-&gt;ps-&gt;weaponTime += 500;
		return;
	}
// ^^^^^^^^^you'll have to change this  bit if you are changing the way the ammo is being done ^^^^^^^^^^(FS)


	// take an ammo away if not infinite
	if ( pm-&gt;ps-&gt;ammo[ pm-&gt;ps-&gt;weapon ] != -1 ) {
		pm-&gt;ps-&gt;ammo[ pm-&gt;ps-&gt;weapon ]--;
	}


// and here ^^^^^^^^^^^^^^^^^^^^^^   (I'm not keen how this is done)  (FS)
	// fire weapon
	PM_AddEvent( EV_FIRE_WEAPON );

// Adds a fire event to the players event stack. this is picked up later   (FS)

	switch( pm-&gt;ps-&gt;weapon ) {
	default:
	case WP_GAUNTLET:
		addTime = 400;
		break;
	case WP_LIGHTNING:
		addTime = 50;
		break;
	case WP_SHOTGUN:
		addTime = 1000;
		break;
	case WP_MACHINEGUN:
		addTime = 100;
		break;
	case WP_GRENADE_LAUNCHER:
		addTime = 800;
		break;
	case WP_ROCKET_LAUNCHER:
		addTime = 800;
		break;
	case WP_PLASMAGUN:
		addTime = 100;
		break;
	case WP_RAILGUN:
		addTime = 1500;
		break;
	case WP_BFG:
//		addTime = 100;
		addTime = 200;
		break;
	case WP_GRAPPLING_HOOK:
		addTime = 400;
		break;
	}

	if ( pm-&gt;ps-&gt;powerups[PW_HASTE] ) {
		addTime /= 1.3;
	}

// addtime controls how long between shots in milliseconds. having a haste powerup reduces the wait by 22% (for some reason. I'd change this). modify to change fire rates (FS)


	pm-&gt;ps-&gt;weaponTime += addTime;
/* sets the counter again. (I'm not sure why they use += as = would do the same thing (as by before that line weapontime is 0 )) bizzare coding practices.  (FS) */  

}
</PRE>
<HR width="100%">

<H2>ClientEvents (g_active.c game) checks the stack and finds a weapon firing 
event.</H2>
<H2>FireWeapon (g_weapon.c game) is called by ClientEvents</H2>
<P>Not much here, but its the only link between what comes next and what has 
already been done. Just a for loop to go through all the events and a switch 
statement to do stuff</P>
<HR width="100%">

<H2>FireWeapon sets up the aiming angles then calls the relevant weapon function 
(same file)</H2>
<P>I'll add comments below as I feel fit. (again marked with (FS), okay?) <PRE class=code>void FireWeapon( gentity_t *ent ) {
	if (ent-&gt;client-&gt;ps.powerups[PW_QUAD] ) {
		s_quadFactor = g_quadfactor.value;       // s_quadfactor is a global for this file and is used by all the weapon functions (FS)
	} else {
		s_quadFactor = 1;
	}

	// track shots taken for accuracy tracking.  Grapple is not a weapon and gauntet is just not tracked
	if( ent-&gt;s.weapon != WP_GRAPPLING_HOOK &amp;&amp; ent-&gt;s.weapon != WP_GAUNTLET ) {
		ent-&gt;client-&gt;ps.persistant[PERS_ACCURACY_SHOTS]++;
	}

	// set aiming directions
	AngleVectors (ent-&gt;client-&gt;ps.viewangles, forward, right, up);

	CalcMuzzlePoint ( ent, forward, right, up, muzzle );
// forward, right, and up are vec3_t's holding unit vectors. they are global to this file (FS)
// muzzle is a vec3_t holding the location where the weapon fires from. global to this file. (FS)


	// fire the specific weapon
	switch( ent-&gt;s.weapon ) {
	case WP_GAUNTLET:
		Weapon_Gauntlet( ent );
		break;
	case WP_LIGHTNING:
		Weapon_LightningFire( ent );
		break;
	case WP_SHOTGUN:
		weapon_supershotgun_fire( ent );
		break;
	case WP_MACHINEGUN:
		if ( g_gametype.integer != GT_TEAM ) {
			Bullet_Fire( ent, MACHINEGUN_SPREAD, MACHINEGUN_DAMAGE );
		} else {
			Bullet_Fire( ent, MACHINEGUN_SPREAD, MACHINEGUN_TEAM_DAMAGE );
		}
		break;
	case WP_GRENADE_LAUNCHER:
		weapon_grenadelauncher_fire( ent );
		break;
	case WP_ROCKET_LAUNCHER:
		Weapon_RocketLauncher_Fire( ent );
		break;
	case WP_PLASMAGUN:
		Weapon_Plasmagun_Fire( ent );
		break;
	case WP_RAILGUN:
		weapon_railgun_fire( ent );
		break;
	case WP_BFG:
		BFG_Fire( ent );
		break;
	case WP_GRAPPLING_HOOK:
		Weapon_GrapplingHook_Fire( ent );
		break;
	default:
// FIXME		G_Error( "Bad ent-&gt;s.weapon" );
		break;
// all the above is kinda obvious (FS)

	}
}
</PRE>
<HR width="100%">

<H2>The weapons do different things dependant on which they are.</H2>
<P>Just take a look at the functions. they are fairly easy to understand.</P>
<HR width="50%">
<A href="http://www.quakefiles.com/skunkworks/q3/tutorial.html">Back to the 
tutorials</A><BR>
<ADDRESS><A href="mailto:problems@deathsdoor.com">Mail 
me</A></ADDRESS><BR><BR><BR></BODY></HTML>
