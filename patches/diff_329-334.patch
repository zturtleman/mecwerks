Index: README
===================================================================
--- README	(revision 329)
+++ README	(revision 334)
@@ -296,6 +296,11 @@
   r_zfar							- sets z far for testing global fog
                                       distances, requires cheats to be enabled
 
+
+  cg_teamDmLeadAnnouncements        - set to 0 to disable the team lead change
+                                      announcements in Team Deathmatch.
+
+
 New commands
   video [filename]        - start video capture (use with demo command)
   stopvideo               - stop video capture
Index: code/game/g_combat.c
===================================================================
--- code/game/g_combat.c	(revision 329)
+++ code/game/g_combat.c	(revision 334)
@@ -69,8 +69,9 @@
 	ScorePlum(ent, origin, score);
 	//
 	ent->client->ps.persistant[PERS_SCORE] += score;
-	if ( g_gametype.integer == GT_TEAM )
-		level.teamScores[ ent->client->ps.persistant[PERS_TEAM] ] += score;
+	if ( g_gametype.integer == GT_TEAM ) {
+		AddTeamScore( origin, ent->client->ps.persistant[PERS_TEAM], score );
+	}
 	CalculateRanks();
 }
 
Index: code/game/g_bot.c
===================================================================
--- code/game/g_bot.c	(revision 329)
+++ code/game/g_bot.c	(revision 334)
@@ -238,6 +238,13 @@
 	char	*value;
 	gclient_t	*cl;
 
+	// To improve random bot selection when there are few bot types, duplicate bots are
+	// allowed on separate teams to try to keep each team from having duplicate bots.
+	// If there are enough bot types to fill the server, avoid duplicating bots on any team.
+	if ( g_numBots >= level.maxclients ) {
+		team = -1;
+	}
+
 	num = 0;
 	for ( n = 0; n < g_numBots ; n++ ) {
 		value = Info_ValueForKey( g_botInfos[n], "name" );
Index: code/game/g_team.c
===================================================================
--- code/game/g_team.c	(revision 329)
+++ code/game/g_team.c	(revision 334)
@@ -122,46 +122,54 @@
 ==============
 AddTeamScore
 
- used for gametype > GT_TEAM
- for gametype GT_TEAM the level.teamScores is updated in AddScore in g_combat.c
+ for gametype GT_TEAM this is called in AddScore in g_combat.c (checks fraglimit to win)
+ for gametype > GT_TEAM this is called when gametype-specific scoring happens (checks capturelimit to win)
+        (e.g. capture flag, kill obelisk, return skulls)
 ==============
 */
 void AddTeamScore(vec3_t origin, int team, int score) {
+	int			eventParm;
 	gentity_t	*te;
 
-	te = G_TempEntity(origin, EV_GLOBAL_TEAM_SOUND );
-	te->r.svFlags |= SVF_BROADCAST;
+	eventParm = -1;
 
 	if ( team == TEAM_RED ) {
 		if ( level.teamScores[ TEAM_RED ] + score == level.teamScores[ TEAM_BLUE ] ) {
 			//teams are tied sound
-			te->s.eventParm = GTS_TEAMS_ARE_TIED;
+			eventParm = GTS_TEAMS_ARE_TIED;
 		}
 		else if ( level.teamScores[ TEAM_RED ] <= level.teamScores[ TEAM_BLUE ] &&
 					level.teamScores[ TEAM_RED ] + score > level.teamScores[ TEAM_BLUE ]) {
 			// red took the lead sound
-			te->s.eventParm = GTS_REDTEAM_TOOK_LEAD;
+			eventParm = GTS_REDTEAM_TOOK_LEAD;
 		}
-		else {
+		else if ( score > 0 && g_gametype.integer != GT_TEAM ) {
 			// red scored sound
-			te->s.eventParm = GTS_REDTEAM_SCORED;
+			eventParm = GTS_REDTEAM_SCORED;
 		}
 	}
 	else {
 		if ( level.teamScores[ TEAM_BLUE ] + score == level.teamScores[ TEAM_RED ] ) {
 			//teams are tied sound
-			te->s.eventParm = GTS_TEAMS_ARE_TIED;
+			eventParm = GTS_TEAMS_ARE_TIED;
 		}
 		else if ( level.teamScores[ TEAM_BLUE ] <= level.teamScores[ TEAM_RED ] &&
 					level.teamScores[ TEAM_BLUE ] + score > level.teamScores[ TEAM_RED ]) {
 			// blue took the lead sound
-			te->s.eventParm = GTS_BLUETEAM_TOOK_LEAD;
+			eventParm = GTS_BLUETEAM_TOOK_LEAD;
 		}
-		else {
+		else if ( score > 0 && g_gametype.integer != GT_TEAM ) {
 			// blue scored sound
-			te->s.eventParm = GTS_BLUETEAM_SCORED;
+			eventParm = GTS_BLUETEAM_SCORED;
 		}
 	}
+
+	if ( eventParm != -1 ) {
+		te = G_TempEntity(origin, EV_GLOBAL_TEAM_SOUND );
+		te->r.svFlags |= SVF_BROADCAST;
+		te->s.eventParm = eventParm;
+	}
+
 	level.teamScores[ team ] += score;
 }
 
Index: code/rend2/tr_glsl.c
===================================================================
--- code/rend2/tr_glsl.c	(revision 329)
+++ code/rend2/tr_glsl.c	(revision 334)
@@ -32,859 +32,35 @@
 
 void GLSL_BindNullProgram(void);
 
-// FIXME: Do something that isn't this messy
-static const char *fallbackGenericShader_vp =
-"attribute vec4 attr_Position;\r\nattribute vec3 attr_Normal;\r\n\r\n#if def"
-"ined(USE_VERTEX_ANIMATION)\r\nattribute vec4 attr_Position2;\r\nattribute v"
-"ec3 attr_Normal2;\r\n#endif\r\n\r\nattribute vec4 attr_Color;\r\nattribute "
-"vec4 attr_TexCoord0;\r\n\r\n#if defined(USE_LIGHTMAP) || defined(USE_TCGEN)"
-"\r\nattribute vec4 attr_TexCoord1;\r\n#endif\r\n\r\nuniform vec4   u_Diffus"
-"eTexMatrix;\r\nuniform vec4   u_DiffuseTexOffTurb;\r\n\r\n#if defined(USE_T"
-"CGEN) || defined(USE_RGBAGEN)\r\nuniform vec3   u_ViewOrigin;\r\n#endif\r\n"
-"\r\n#if defined(USE_TCGEN)\r\nuniform int    u_TCGen0;\r\nuniform vec3   u_"
-"TCGen0Vector0;\r\nuniform vec3   u_TCGen0Vector1;\r\n#endif\r\n\r\n#if defi"
-"ned(USE_FOG)\r\nuniform vec4   u_FogDistance;\r\nuniform vec4   u_FogDepth;"
-"\r\nuniform float  u_FogEyeT;\r\nuniform vec4   u_FogColorMask;\r\n#endif\r"
-"\n\r\n#if defined(USE_DEFORM_VERTEXES)\r\nuniform int    u_DeformGen;\r\nun"
-"iform float  u_DeformParams[5];\r\nuniform float  u_Time;\r\n#endif\r\n\r\n"
-"uniform mat4   u_ModelViewProjectionMatrix;\r\nuniform vec4   u_BaseColor;"
-"\r\nuniform vec4   u_VertColor;\r\n\r\n#if defined(USE_RGBAGEN)\r\nuniform "
-"int    u_ColorGen;\r\nuniform int    u_AlphaGen;\r\nuniform vec3   u_Ambien"
-"tLight;\r\nuniform vec3   u_DirectedLight;\r\nuniform vec4   u_LightOrigin;"
-"\r\nuniform float  u_PortalRange;\r\n#endif\r\n\r\n#if defined(USE_VERTEX_A"
-"NIMATION)\r\nuniform float  u_VertexLerp;\r\n#endif\r\n\r\nvarying vec2   v"
-"ar_DiffuseTex;\r\n#if defined(USE_LIGHTMAP)\r\nvarying vec2   var_LightTex;"
-"\r\n#endif\r\nvarying vec4   var_Color;\r\n\r\n#if defined(USE_DEFORM_VERTE"
-"XES)\r\nvec3 DeformPosition(const vec3 pos, const vec3 normal, const vec2 s"
-"t)\r\n{\r\n\tfloat base =      u_DeformParams[0];\r\n\tfloat amplitude = u_"
-"DeformParams[1];\r\n\tfloat phase =     u_DeformParams[2];\r\n\tfloat frequ"
-"ency = u_DeformParams[3];\r\n\tfloat spread =    u_DeformParams[4];\r\n\r\n"
-"\tif (u_DeformGen == DGEN_BULGE)\r\n\t{\r\n\t\tphase *= M_PI * 0.25 * st.x;"
-"\r\n\t}\r\n\telse // if (u_DeformGen <= DGEN_WAVE_INVERSE_SAWTOOTH)\r\n\t{"
-"\r\n\t\tphase += dot(pos.xyz, vec3(spread));\r\n\t}\r\n\r\n\tfloat value = "
-"phase + (u_Time * frequency);\r\n\tfloat func;\r\n\r\n\tif (u_DeformGen == "
-"DGEN_WAVE_SIN)\r\n\t{\r\n\t\tfunc = sin(value * 2.0 * M_PI);\r\n\t}\r\n\tel"
-"se if (u_DeformGen == DGEN_WAVE_SQUARE)\r\n\t{\r\n\t\tfunc = sign(sin(value"
-" * 2.0 * M_PI));\r\n\t}\r\n\telse if (u_DeformGen == DGEN_WAVE_TRIANGLE)\r"
-"\n\t{\r\n\t\tfunc = abs(fract(value + 0.75) - 0.5) * 4.0 - 1.0;\r\n\t}\r\n"
-"\telse if (u_DeformGen == DGEN_WAVE_SAWTOOTH)\r\n\t{\r\n\t\tfunc = fract(va"
-"lue);\r\n\t}\r\n\telse if (u_DeformGen == DGEN_WAVE_INVERSE_SAWTOOTH)\r\n\t"
-"{\r\n\t\tfunc = (1.0 - fract(value));\r\n\t}\r\n\telse if (u_DeformGen == D"
-"GEN_BULGE)\r\n\t{\r\n\t\tfunc = sin(value);\r\n\t}\r\n\r\n\treturn pos + no"
-"rmal * (base + func * amplitude);\r\n}\r\n#endif\r\n\r\n#if defined(USE_TCG"
-"EN)\r\nvec2 GenTexCoords(int TCGen, vec3 position, vec3 normal, vec3 TCGenV"
-"ector0, vec3 TCGenVector1)\r\n{\r\n\tvec2 tex = attr_TexCoord0.st;\r\n\r\n"
-"\tif (TCGen == TCGEN_LIGHTMAP)\r\n\t{\r\n\t\ttex = attr_TexCoord1.st;\r\n\t"
-"}\r\n\telse if (TCGen == TCGEN_ENVIRONMENT_MAPPED)\r\n\t{\r\n\t\tvec3 viewe"
-"r = normalize(u_ViewOrigin - position);\r\n\t\ttex = -reflect(viewer, norma"
-"l).yz * vec2(0.5, -0.5) + 0.5;\r\n\t}\r\n\telse if (TCGen == TCGEN_VECTOR)"
-"\r\n\t{\r\n\t\ttex = vec2(dot(position, TCGenVector0), dot(position, TCGenV"
-"ector1));\r\n\t}\r\n\t\r\n\treturn tex;\r\n}\r\n#endif\r\n\r\n#if defined(U"
-"SE_TCMOD)\r\nvec2 ModTexCoords(vec2 st, vec3 position, vec4 texMatrix, vec4"
-" offTurb)\r\n{\r\n\tfloat amplitude = offTurb.z;\r\n\tfloat phase = offTurb"
-".w;\r\n\tvec2 st2 = vec2(dot(st, texMatrix.xz), dot(st, texMatrix.yw)) + of"
-"fTurb.xy;\r\n\r\n\tvec3 offsetPos = position / 1024.0;\r\n\toffsetPos.x += "
-"offsetPos.z;\r\n\t\r\n\tvec2 texOffset = sin((offsetPos.xy + vec2(phase)) *"
-" 2.0 * M_PI);\r\n\t\r\n\treturn st2 + texOffset * amplitude;\t\r\n}\r\n#end"
-"if\r\n\r\n#if defined(USE_RGBAGEN)\r\nvec4 CalcColor(vec3 position, vec3 no"
-"rmal)\r\n{\r\n\tvec4 color = u_VertColor * attr_Color + u_BaseColor;\r\n\t"
-"\r\n\tif (u_ColorGen == CGEN_LIGHTING_DIFFUSE)\r\n\t{\r\n\t\tfloat incoming"
-" = clamp(dot(normal, u_LightOrigin.xyz), 0.0, 1.0);\r\n\r\n\t\tcolor.rgb = "
-"clamp(u_DirectedLight * incoming + u_AmbientLight, 0.0, 1.0);\r\n\t}\r\n\t"
-"\r\n\tvec3 toView = u_ViewOrigin - position;\r\n\tvec3 viewer = normalize(u"
-"_ViewOrigin - position);\r\n\r\n\tif (u_AlphaGen == AGEN_LIGHTING_SPECULAR)"
-"\r\n\t{\r\n\t\tvec3 lightDir = normalize(vec3(-960.0, -1980.0, 96.0) - posi"
-"tion.xyz);\r\n\t\tvec3 halfangle = normalize(lightDir + viewer);\r\n\t\t\r"
-"\n\t\tcolor.a = pow(max(dot(normal, halfangle), 0.0), 8.0);\r\n\t}\r\n\tels"
-"e if (u_AlphaGen == AGEN_PORTAL)\r\n\t{\r\n\t\tfloat alpha = length(toView)"
-" / u_PortalRange;\r\n\r\n\t\tcolor.a = clamp(alpha, 0.0, 1.0);\r\n\t}\r\n\t"
-"else if (u_AlphaGen == AGEN_FRESNEL)\r\n\t{\r\n\t\tcolor.a = 0.10 + 0.90 * "
-"pow(1.0 - dot(normal, viewer), 5);\r\n\t}\r\n\t\r\n\treturn color;\r\n}\r\n"
-"#endif\r\n\r\n#if defined(USE_FOG)\r\nfloat CalcFog(vec4 position)\r\n{\r\n"
-"\tfloat s = dot(position, u_FogDistance) * 8.0;\r\n\tfloat t = dot(position"
-", u_FogDepth);\r\n\r\n\tif (t < 1.0)\r\n\t{\r\n\t\tt = step(step(0.0, -u_Fo"
-"gEyeT), t);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tt /= t - min(u_FogEyeT, 0.0);\r"
-"\n\t}\r\n\r\n\treturn s * t;\r\n}\r\n#endif\r\n\r\nvoid main()\r\n{\r\n#if "
-"defined(USE_VERTEX_ANIMATION)\r\n\tvec4 position = mix(attr_Position, attr_"
-"Position2, u_VertexLerp);\r\n\tvec3 normal = normalize(mix(attr_Normal, att"
-"r_Normal2, u_VertexLerp));\r\n#else\r\n\tvec4 position = attr_Position;\r\n"
-"\tvec3 normal = attr_Normal;\r\n#endif\r\n\r\n#if defined(USE_DEFORM_VERTEX"
-"ES)\r\n\tposition.xyz = DeformPosition(position.xyz, normal, attr_TexCoord0"
-".st);\r\n#endif\r\n\r\n\tgl_Position = u_ModelViewProjectionMatrix * positi"
-"on;\r\n\r\n#if defined(USE_TCGEN)\r\n\tvec2 tex = GenTexCoords(u_TCGen0, po"
-"sition.xyz, normal, u_TCGen0Vector0, u_TCGen0Vector1);\r\n#else\r\n\tvec2 t"
-"ex = attr_TexCoord0.st;\r\n#endif\r\n\r\n#if defined(USE_TCMOD)\r\n\tvar_Di"
-"ffuseTex = ModTexCoords(tex, position.xyz, u_DiffuseTexMatrix, u_DiffuseTex"
-"OffTurb);\r\n#else\r\n    var_DiffuseTex = tex;\r\n#endif\r\n\r\n#if define"
-"d(USE_LIGHTMAP)\r\n\tvar_LightTex = attr_TexCoord1.st;\r\n#endif\r\n\r\n#if"
-" defined(USE_RGBAGEN)\r\n\tvar_Color = CalcColor(position.xyz, normal);\r\n"
-"#else\r\n\tvar_Color = u_VertColor * attr_Color + u_BaseColor;\r\n#endif\r"
-"\n\r\n#if defined(USE_FOG)\r\n\tvar_Color *= vec4(1.0) - u_FogColorMask * s"
-"qrt(clamp(CalcFog(position), 0.0, 1.0));\r\n#endif\r\n}\r\n";
+extern const char *fallbackShader_bokeh_vp;
+extern const char *fallbackShader_bokeh_fp;
+extern const char *fallbackShader_calclevels4x_vp;
+extern const char *fallbackShader_calclevels4x_fp;
+extern const char *fallbackShader_depthblur_vp;
+extern const char *fallbackShader_depthblur_fp;
+extern const char *fallbackShader_dlight_vp;
+extern const char *fallbackShader_dlight_fp;
+extern const char *fallbackShader_down4x_vp;
+extern const char *fallbackShader_down4x_fp;
+extern const char *fallbackShader_fogpass_vp;
+extern const char *fallbackShader_fogpass_fp;
+extern const char *fallbackShader_generic_vp;
+extern const char *fallbackShader_generic_fp;
+extern const char *fallbackShader_lightall_vp;
+extern const char *fallbackShader_lightall_fp;
+extern const char *fallbackShader_pshadow_vp;
+extern const char *fallbackShader_pshadow_fp;
+extern const char *fallbackShader_shadowfill_vp;
+extern const char *fallbackShader_shadowfill_fp;
+extern const char *fallbackShader_shadowmask_vp;
+extern const char *fallbackShader_shadowmask_fp;
+extern const char *fallbackShader_ssao_vp;
+extern const char *fallbackShader_ssao_fp;
+extern const char *fallbackShader_texturecolor_vp;
+extern const char *fallbackShader_texturecolor_fp;
+extern const char *fallbackShader_tonemap_vp;
+extern const char *fallbackShader_tonemap_fp;
 
-static const char *fallbackGenericShader_fp =
-"uniform sampler2D u_DiffuseMap;\r\n\r\n#if defined(USE_LIGHTMAP)\r\nuniform"
-" sampler2D u_LightMap;\r\n\r\nuniform int       u_Texture1Env;\r\n#endif\r"
-"\n\r\nvarying vec2      var_DiffuseTex;\r\n\r\n#if defined(USE_LIGHTMAP)\r"
-"\nvarying vec2      var_LightTex;\r\n#endif\r\n\r\nvarying vec4      var_Co"
-"lor;\r\n\r\n\r\nvoid main()\r\n{\r\n\tvec4 color  = texture2D(u_DiffuseMap,"
-" var_DiffuseTex);\r\n#if defined(USE_LIGHTMAP)\r\n\tvec4 color2 = texture2D"
-"(u_LightMap, var_LightTex);\r\n  #if defined(RGBE_LIGHTMAP)\r\n\tcolor2.rgb"
-" *= exp2(color2.a * 255.0 - 128.0);\r\n\tcolor2.a = 1.0;\r\n  #endif\r\n\r"
-"\n\tif (u_Texture1Env == TEXENV_MODULATE)\r\n\t{\r\n\t\tcolor *= color2;\r"
-"\n\t}\r\n\telse if (u_Texture1Env == TEXENV_ADD)\r\n\t{\r\n\t\tcolor += col"
-"or2;\r\n\t}\r\n\telse if (u_Texture1Env == TEXENV_REPLACE)\r\n\t{\r\n\t\tco"
-"lor = color2;\r\n\t}\r\n#endif\r\n\r\n\tgl_FragColor = color * var_Color;\r"
-"\n}\r\n";
-
-static const char *fallbackTextureColorShader_vp =
-"#version 120\r\n\r\nattribute vec4 attr_Position;\r\nattribute vec4 attr_Te"
-"xCoord0;\r\n\r\nuniform mat4   u_ModelViewProjectionMatrix;\r\n\r\nvarying "
-"vec2   var_Tex1;\r\n\r\n\r\nvoid main()\r\n{\r\n\tgl_Position = u_ModelView"
-"ProjectionMatrix * attr_Position;\r\n\tvar_Tex1 = attr_TexCoord0.st;\r\n}\r"
-"\n";
-
-static const char *fallbackTextureColorShader_fp =
-"#version 120\r\n\r\nuniform sampler2D u_DiffuseMap;\r\nuniform vec4      u_"
-"Color;\r\n\r\nvarying vec2         var_Tex1;\r\n\r\n\r\nvoid main()\r\n{\r"
-"\n\tgl_FragColor = texture2D(u_DiffuseMap, var_Tex1) * u_Color;\r\n}\r\n";
-
-static const char *fallbackFogPassShader_vp =
-"attribute vec4  attr_Position;\r\nattribute vec3  attr_Normal;\r\nattribute"
-" vec4  attr_TexCoord0;\r\n\r\n//#if defined(USE_VERTEX_ANIMATION)\r\nattrib"
-"ute vec4  attr_Position2;\r\nattribute vec3  attr_Normal2;\r\n//#endif\r\n"
-"\r\nuniform vec4    u_FogDistance;\r\nuniform vec4    u_FogDepth;\r\nunifor"
-"m float   u_FogEyeT;\r\n\r\n//#if defined(USE_DEFORM_VERTEXES)\r\nuniform i"
-"nt     u_DeformGen;\r\nuniform float   u_DeformParams[5];\r\n//#endif\r\n\r"
-"\nuniform float   u_Time;\r\nuniform mat4    u_ModelViewProjectionMatrix;\r"
-"\n\r\n//#if defined(USE_VERTEX_ANIMATION)\r\nuniform float   u_VertexLerp;"
-"\r\n//#endif\r\n\r\nvarying float   var_Scale;\r\n\r\n#if defined(USE_DEFOR"
-"M_VERTEXES)\r\nvec3 DeformPosition(const vec3 pos, const vec3 normal, const"
-" vec2 st)\r\n{\r\n\tif (u_DeformGen == 0)\r\n\t{\r\n\t\treturn pos;\r\n\t}"
-"\r\n\r\n\tfloat base =      u_DeformParams[0];\r\n\tfloat amplitude = u_Def"
-"ormParams[1];\r\n\tfloat phase =     u_DeformParams[2];\r\n\tfloat frequenc"
-"y = u_DeformParams[3];\r\n\tfloat spread =    u_DeformParams[4];\r\n\r\n\ti"
-"f (u_DeformGen == DGEN_BULGE)\r\n\t{\r\n\t\tphase *= M_PI * 0.25 * st.x;\r"
-"\n\t}\r\n\telse // if (u_DeformGen <= DGEN_WAVE_INVERSE_SAWTOOTH)\r\n\t{\r"
-"\n\t\tphase += dot(pos.xyz, vec3(spread));\r\n\t}\r\n\r\n\tfloat value = ph"
-"ase + (u_Time * frequency);\r\n\tfloat func;\r\n\r\n\tif (u_DeformGen == DG"
-"EN_WAVE_SIN)\r\n\t{\r\n\t\tfunc = sin(value * 2.0 * M_PI);\r\n\t}\r\n\telse"
-" if (u_DeformGen == DGEN_WAVE_SQUARE)\r\n\t{\r\n\t\tfunc = sign(sin(value *"
-" 2.0 * M_PI));\r\n\t}\r\n\telse if (u_DeformGen == DGEN_WAVE_TRIANGLE)\r\n"
-"\t{\r\n\t\tfunc = abs(fract(value + 0.75) - 0.5) * 4.0 - 1.0;\r\n\t}\r\n\te"
-"lse if (u_DeformGen == DGEN_WAVE_SAWTOOTH)\r\n\t{\r\n\t\tfunc = fract(value"
-");\r\n\t}\r\n\telse if (u_DeformGen == DGEN_WAVE_INVERSE_SAWTOOTH)\r\n\t{\r"
-"\n\t\tfunc = (1.0 - fract(value));\r\n\t}\r\n\telse if (u_DeformGen == DGEN"
-"_BULGE)\r\n\t{\r\n\t\tfunc = sin(value);\r\n\t}\r\n\r\n\treturn pos + norma"
-"l * (base + func * amplitude);\r\n}\r\n#endif\r\n\r\nfloat CalcFog(vec4 pos"
-"ition)\r\n{\r\n\tfloat s = dot(position, u_FogDistance) * 8.0;\r\n\tfloat t"
-" = dot(position, u_FogDepth);\r\n\r\n\tif (t < 1.0)\r\n\t{\r\n\t\tt = step("
-"step(0.0, -u_FogEyeT), t);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tt /= t - min(u_Fo"
-"gEyeT, 0.0);\r\n\t}\r\n\t\r\n\treturn s * t;\r\n}\r\n\r\nvoid main()\r\n{\r"
-"\n#if defined(USE_VERTEX_ANIMATION)\r\n\tvec4 position = mix(attr_Position,"
-" attr_Position2, u_VertexLerp);\r\n\tvec3 normal = normalize(mix(attr_Norma"
-"l, attr_Normal2, u_VertexLerp));\r\n#else\r\n\tvec4 position = attr_Positio"
-"n;\r\n\tvec3 normal = attr_Normal;\r\n#endif\r\n\r\n#if defined(USE_DEFORM_"
-"VERTEXES)\r\n\tposition.xyz = DeformPosition(position.xyz, normal, attr_Tex"
-"Coord0.st);\r\n#endif\r\n\r\n\tgl_Position = u_ModelViewProjectionMatrix * "
-"position;\r\n\r\n\tvar_Scale = CalcFog(position);\r\n}\r\n";
-
-static const char *fallbackFogPassShader_fp =
-"uniform vec4  u_Color;\r\n\r\nvarying float var_Scale;\r\n\r\nvoid main()\r"
-"\n{\r\n\tgl_FragColor = u_Color;\r\n\tgl_FragColor.a *= sqrt(clamp(var_Scal"
-"e, 0.0, 1.0));\r\n}\r\n";
-
-static const char *fallbackDlightShader_vp =
-"attribute vec4 attr_Position;\r\nattribute vec4 attr_TexCoord0;\r\nattribut"
-"e vec3 attr_Normal;\r\n\r\nuniform vec4   u_DlightInfo;\r\n\r\n#if defined("
-"USE_DEFORM_VERTEXES)\r\nuniform int    u_DeformGen;\r\nuniform float  u_Def"
-"ormParams[5];\r\nuniform float  u_Time;\r\n#endif\r\n\r\nuniform vec4   u_C"
-"olor;\r\nuniform mat4   u_ModelViewProjectionMatrix;\r\n\r\nvarying vec2   "
-"var_Tex1;\r\nvarying vec4   var_Color;\r\n\r\n#if defined(USE_DEFORM_VERTEX"
-"ES)\r\nvec3 DeformPosition(const vec3 pos, const vec3 normal, const vec2 st"
-")\r\n{\r\n\tif (u_DeformGen == 0)\r\n\t{\r\n\t\treturn pos;\r\n\t}\r\n\r\n"
-"\tfloat base =      u_DeformParams[0];\r\n\tfloat amplitude = u_DeformParam"
-"s[1];\r\n\tfloat phase =     u_DeformParams[2];\r\n\tfloat frequency = u_De"
-"formParams[3];\r\n\tfloat spread =    u_DeformParams[4];\r\n\r\n\tif (u_Def"
-"ormGen == DGEN_BULGE)\r\n\t{\r\n\t\tphase *= M_PI * 0.25 * st.x;\r\n\t}\r\n"
-"\telse // if (u_DeformGen <= DGEN_WAVE_INVERSE_SAWTOOTH)\r\n\t{\r\n\t\tphas"
-"e += dot(pos.xyz, vec3(spread));\r\n\t}\r\n\r\n\tfloat value = phase + (u_T"
-"ime * frequency);\r\n\tfloat func;\r\n\r\n\tif (u_DeformGen == DGEN_WAVE_SI"
-"N)\r\n\t{\r\n\t\tfunc = sin(value * 2.0 * M_PI);\r\n\t}\r\n\telse if (u_Def"
-"ormGen == DGEN_WAVE_SQUARE)\r\n\t{\r\n\t\tfunc = sign(sin(value * 2.0 * M_P"
-"I));\r\n\t}\r\n\telse if (u_DeformGen == DGEN_WAVE_TRIANGLE)\r\n\t{\r\n\t\t"
-"func = abs(fract(value + 0.75) - 0.5) * 4.0 - 1.0;\r\n\t}\r\n\telse if (u_D"
-"eformGen == DGEN_WAVE_SAWTOOTH)\r\n\t{\r\n\t\tfunc = fract(value);\r\n\t}\r"
-"\n\telse if (u_DeformGen == DGEN_WAVE_INVERSE_SAWTOOTH)\r\n\t{\r\n\t\tfunc "
-"= (1.0 - fract(value));\r\n\t}\r\n\telse if (u_DeformGen == DGEN_BULGE)\r\n"
-"\t{\r\n\t\tfunc = sin(value);\r\n\t}\r\n\r\n\treturn pos + normal * (base +"
-" func * amplitude);\r\n}\r\n#endif\r\n\r\nvoid main()\r\n{\r\n\tvec4 positi"
-"on = attr_Position;\r\n\tvec3 normal = attr_Normal;\r\n\r\n#if defined(USE_"
-"DEFORM_VERTEXES)\r\n\tposition.xyz = DeformPosition(position.xyz, normal, a"
-"ttr_TexCoord0.st);\r\n#endif\r\n\r\n\tgl_Position = u_ModelViewProjectionMa"
-"trix * position;\r\n\t\t\r\n\tvec3 dist = u_DlightInfo.xyz - position.xyz;"
-"\t\r\n\r\n\tvar_Tex1 = dist.xy * u_DlightInfo.a + vec2(0.5);\r\n\tfloat dli"
-"ghtmod = step(0.0, dot(dist, normal));\r\n\tdlightmod *= clamp(2.0 * (1.0 -"
-" abs(dist.z) * u_DlightInfo.a), 0.0, 1.0);\r\n\t\r\n\tvar_Color = u_Color *"
-" dlightmod;\r\n}\r\n";
-
-static const char *fallbackDlightShader_fp =
-"uniform sampler2D u_DiffuseMap;\r\n\r\nvarying vec2      var_Tex1;\r\nvaryi"
-"ng vec4      var_Color;\r\n\r\n\r\nvoid main()\r\n{\r\n\tvec4 color = textu"
-"re2D(u_DiffuseMap, var_Tex1);\r\n\r\n\tgl_FragColor = color * var_Color;\r"
-"\n}\r\n";
-
-static const char *fallbackLightallShader_vp =
-"attribute vec4 attr_TexCoord0;\r\n#if defined(USE_LIGHTMAP)\r\nattribute ve"
-"c4 attr_TexCoord1;\r\n#endif\r\nattribute vec4 attr_Color;\r\n\r\nattribute"
-" vec4 attr_Position;\r\nattribute vec3 attr_Normal;\r\n\r\n#if defined(USE_"
-"VERT_TANGENT_SPACE)\r\nattribute vec3 attr_Tangent;\r\nattribute vec3 attr_"
-"Bitangent;\r\n#endif\r\n\r\n#if defined(USE_VERTEX_ANIMATION)\r\nattribute "
-"vec4 attr_Position2;\r\nattribute vec3 attr_Normal2;\r\n  #if defined(USE_V"
-"ERT_TANGENT_SPACE)\r\nattribute vec3 attr_Tangent2;\r\nattribute vec3 attr_"
-"Bitangent2;\r\n  #endif\r\n#endif\r\n\r\n#if defined(USE_LIGHT) && !defined"
-"(USE_LIGHT_VECTOR)\r\nattribute vec3 attr_LightDirection;\r\n#endif\r\n\r\n"
-"#if defined(USE_TCGEN) || defined(USE_NORMALMAP) || defined(USE_LIGHT) && !"
-"defined(USE_FAST_LIGHT)\r\nuniform vec3   u_ViewOrigin;\r\n#endif\r\n\r\n#i"
-"f defined(USE_TCGEN)\r\nuniform int    u_TCGen0;\r\n#endif\r\n\r\n#if defin"
-"ed(USE_TCMOD)\r\nuniform vec4   u_DiffuseTexMatrix;\r\nuniform vec4   u_Dif"
-"fuseTexOffTurb;\r\n#endif\r\n\r\nuniform mat4   u_ModelViewProjectionMatrix"
-";\r\nuniform vec4   u_BaseColor;\r\nuniform vec4   u_VertColor;\r\n\r\n#if "
-"defined(USE_MODELMATRIX)\r\nuniform mat4   u_ModelMatrix;\r\n#endif\r\n\r\n"
-"#if defined(USE_VERTEX_ANIMATION)\r\nuniform float  u_VertexLerp;\r\n#endif"
-"\r\n\r\n#if defined(USE_LIGHT_VECTOR)\r\nuniform vec4   u_LightOrigin;\r\n "
-" #if defined(USE_FAST_LIGHT)\r\nuniform vec3   u_DirectedLight;\r\nuniform "
-"vec3   u_AmbientLight;\r\nuniform float  u_LightRadius;\r\n  #endif\r\n#end"
-"if\r\n\r\nvarying vec2   var_DiffuseTex;\r\n\r\n#if defined(USE_LIGHTMAP)\r"
-"\nvarying vec2   var_LightTex;\r\n#endif\r\n\r\n#if defined(USE_NORMALMAP) "
-"|| defined(USE_LIGHT) && !defined(USE_FAST_LIGHT)\r\nvarying vec3   var_Sam"
-"pleToView;\r\n#endif\r\n\r\nvarying vec4   var_Color;\r\n\r\n#if defined(US"
-"E_NORMALMAP) && !defined(USE_VERT_TANGENT_SPACE)\r\nvarying vec3   var_Posi"
-"tion;\r\n#endif\r\n\r\n\r\n#if !defined(USE_FAST_LIGHT)\r\nvarying vec3   v"
-"ar_Normal;\r\n  #if defined(USE_VERT_TANGENT_SPACE)\r\nvarying vec3   var_T"
-"angent;\r\nvarying vec3   var_Bitangent;\r\n  #endif\r\n#endif\r\n\r\n#if d"
-"efined(USE_LIGHT_VERTEX) && !defined(USE_FAST_LIGHT)\r\nvarying vec3   var_"
-"VertLight;\r\n#endif\r\n\r\n#if defined(USE_LIGHT) && !defined(USE_DELUXEMA"
-"P) && !defined(USE_FAST_LIGHT)\r\nvarying vec3   var_WorldLight;\r\n#endif"
-"\r\n\r\n#if defined(USE_LIGHT_VECTOR) && !defined(USE_FAST_LIGHT) && define"
-"d(USE_SHADOWMAP)\r\nvarying vec4   var_ScreenPos;\r\n#endif\r\n\r\n#if defi"
-"ned(USE_TCMOD)\r\nvec2 ModTexCoords(vec2 st, vec3 position, vec4 texMatrix,"
-" vec4 offTurb)\r\n{\r\n\tfloat amplitude = offTurb.z;\r\n\tfloat phase = of"
-"fTurb.w;\r\n\tvec2 st2 = vec2(dot(st, texMatrix.xz), dot(st, texMatrix.yw))"
-" + offTurb.xy;\r\n\r\n\tvec3 offsetPos = position / 1024.0;\r\n\toffsetPos."
-"x += offsetPos.z;\r\n\t\r\n\tvec2 texOffset = sin((offsetPos.xy + vec2(phas"
-"e)) * 2.0 * M_PI);\r\n\t\r\n\treturn st2 + texOffset * amplitude;\t\r\n}\r"
-"\n#endif\r\n\r\n\r\nvoid main()\r\n{\r\n#if defined(USE_VERTEX_ANIMATION)\r"
-"\n\tvec4 position  = mix(attr_Position, attr_Position2, u_VertexLerp);\r\n"
-"\tvec3 normal    = normalize(mix(attr_Normal,    attr_Normal2,    u_VertexL"
-"erp));\r\n  #if defined(USE_VERT_TANGENT_SPACE)\r\n\tvec3 tangent   = norma"
-"lize(mix(attr_Tangent,   attr_Tangent2,   u_VertexLerp));\r\n\tvec3 bitange"
-"nt = normalize(mix(attr_Bitangent, attr_Bitangent2, u_VertexLerp));\r\n  #e"
-"ndif\r\n#else\r\n\tvec4 position  = attr_Position;\r\n\tvec3 normal    = at"
-"tr_Normal;\r\n  #if defined(USE_VERT_TANGENT_SPACE)\r\n\tvec3 tangent   = a"
-"ttr_Tangent;\r\n\tvec3 bitangent = attr_Bitangent;\r\n  #endif\r\n#endif\r"
-"\n\r\n\tgl_Position = u_ModelViewProjectionMatrix * position;\r\n\r\n#if de"
-"fined(USE_LIGHT_VECTOR) && !defined(USE_FAST_LIGHT) && defined(USE_SHADOWMA"
-"P)\r\n\tvar_ScreenPos = gl_Position + vec2(1.0, 0.0).xxyx * gl_Position.w;"
-"\r\n#endif\r\n\r\n#if (defined(USE_LIGHTMAP) || defined(USE_LIGHT_VERTEX)) "
-"&& !defined(USE_DELUXEMAP) && !defined(USE_FAST_LIGHT)\r\n\tvec3 worldLight"
-" = attr_LightDirection;\r\n#endif\r\n\t\r\n#if defined(USE_MODELMATRIX)\r\n"
-"\tposition  = u_ModelMatrix * position;\r\n\tnormal    = (u_ModelMatrix * v"
-"ec4(normal, 0.0)).xyz;\r\n  #if defined(USE_VERT_TANGENT_SPACE)\r\n\ttangen"
-"t   = (u_ModelMatrix * vec4(tangent, 0.0)).xyz;\r\n\tbitangent = (u_ModelMa"
-"trix * vec4(bitangent, 0.0)).xyz;\r\n  #endif\r\n\r\n  #if defined(USE_LIGH"
-"TMAP) && !defined(USE_DELUXEMAP) && !defined(USE_FAST_LIGHT)\r\n\tworldLigh"
-"t = (u_ModelMatrix * vec4(worldLight, 0.0)).xyz;\r\n  #endif\r\n#endif\r\n"
-"\r\n#if defined(USE_NORMALMAP) && !defined(USE_VERT_TANGENT_SPACE)\r\n\tvar"
-"_Position = position.xyz;\r\n#endif\r\n\r\n#if defined(USE_TCGEN) || define"
-"d(USE_NORMALMAP) || defined(USE_LIGHT) && !defined(USE_FAST_LIGHT)\r\n\tvec"
-"3 SampleToView = u_ViewOrigin - position.xyz;\r\n#endif\r\n\r\n#if defined("
-"USE_NORMALMAP) || defined(USE_LIGHT) && !defined(USE_FAST_LIGHT)\r\n\tvar_S"
-"ampleToView = SampleToView;\r\n#endif\r\n\r\n\tvec2 tex;\r\n\r\n#if defined"
-"(USE_TCGEN)\r\n\tif (u_TCGen0 == TCGEN_ENVIRONMENT_MAPPED)\r\n\t{\r\n\t\tte"
-"x = -reflect(normalize(SampleToView), normal).yz * vec2(0.5, -0.5) + 0.5;\r"
-"\n\t}\r\n\telse\r\n#endif\r\n\t{\r\n\t\ttex = attr_TexCoord0.st;\r\n\t}\r\n"
-"\r\n#if defined(USE_TCMOD)\r\n\tvar_DiffuseTex = ModTexCoords(tex, position"
-".xyz, u_DiffuseTexMatrix, u_DiffuseTexOffTurb);\r\n#else\r\n\tvar_DiffuseTe"
-"x = tex;\r\n#endif\r\n\r\n#if defined(USE_LIGHTMAP)\r\n\tvar_LightTex = att"
-"r_TexCoord1.st;\r\n#endif\r\n\r\n#if !defined(USE_FAST_LIGHT)\r\n\tvar_Norm"
-"al = normal;\r\n  #if defined(USE_VERT_TANGENT_SPACE)\r\n\tvar_Tangent = ta"
-"ngent;\r\n\tvar_Bitangent = bitangent;\r\n  #endif\r\n#endif\r\n\r\n#if def"
-"ined(USE_LIGHT) && !defined(USE_DELUXEMAP)\r\n  #if defined(USE_LIGHT_VECTO"
-"R)\r\n\tvec3 worldLight = u_LightOrigin.xyz - (position.xyz * u_LightOrigin"
-".w);\r\n  #endif\r\n  #if !defined(USE_FAST_LIGHT)\r\n\tvar_WorldLight = wo"
-"rldLight;\r\n  #endif\r\n#endif\r\n\t\r\n#if defined(USE_LIGHT_VERTEX) && !"
-"defined(USE_FAST_LIGHT)\r\n\tvar_VertLight = u_VertColor.rgb * attr_Color.r"
-"gb;\r\n\tvar_Color.rgb = vec3(1.0);\r\n\tvar_Color.a = u_VertColor.a * attr"
-"_Color.a + u_BaseColor.a;\r\n#else\r\n\tvar_Color = u_VertColor * attr_Colo"
-"r + u_BaseColor;\r\n#endif\r\n\r\n#if defined(USE_LIGHT_VECTOR) && defined("
-"USE_FAST_LIGHT)\r\n  #if defined(USE_INVSQRLIGHT)\r\n\tfloat intensity = 1."
-"0 / dot(worldLight, worldLight);\r\n  #else\r\n\tfloat intensity = clamp((1"
-".0 - dot(worldLight, worldLight) / (u_LightRadius * u_LightRadius)) * 1.07,"
-" 0.0, 1.0);\r\n  #endif\r\n\tfloat NL = clamp(dot(normal, normalize(worldLi"
-"ght)), 0.0, 1.0);\r\n\r\n\tvar_Color.rgb *= u_DirectedLight * intensity * N"
-"L + u_AmbientLight;\r\n#endif\r\n}\r\n";
-
-static const char *fallbackLightallShader_fp =
-"uniform sampler2D u_DiffuseMap;\r\n\r\n#if defined(USE_LIGHTMAP)\r\nuniform"
-" sampler2D u_LightMap;\r\n#endif\r\n\r\n#if defined(USE_NORMALMAP)\r\nunifo"
-"rm sampler2D u_NormalMap;\r\n#endif\r\n\r\n#if defined(USE_DELUXEMAP)\r\nun"
-"iform sampler2D u_DeluxeMap;\r\n#endif\r\n\r\n#if defined(USE_SPECULARMAP)"
-"\r\nuniform sampler2D u_SpecularMap;\r\n#endif\r\n\r\n#if defined(USE_SHADO"
-"WMAP)\r\nuniform sampler2D u_ShadowMap;\r\n#endif\r\n\r\nuniform vec3      "
-"u_ViewOrigin;\r\n\r\n#if defined(USE_TCGEN)\r\nuniform int    u_TCGen0;\r\n"
-"#endif\r\n\r\n#if defined(USE_LIGHT_VECTOR)\r\nuniform vec3      u_Directed"
-"Light;\r\nuniform vec3      u_AmbientLight;\r\nuniform float     u_LightRad"
-"ius;\r\n#endif\r\n\r\n#if defined(USE_LIGHT)\r\nuniform vec2      u_Materia"
-"lInfo;\r\n#endif\r\n\r\nvarying vec2      var_DiffuseTex;\r\n#if defined(US"
-"E_LIGHTMAP)\r\nvarying vec2      var_LightTex;\r\n#endif\r\nvarying vec4   "
-"   var_Color;\r\n\r\n#if defined(USE_NORMALMAP) && !defined(USE_VERT_TANGEN"
-"T_SPACE)\r\nvarying vec3      var_Position;\r\n#endif\r\n\r\nvarying vec3  "
-"    var_SampleToView;\r\n\r\n#if !defined(USE_FAST_LIGHT)\r\nvarying vec3  "
-"    var_Normal;\r\n#endif\r\n\r\n#if defined(USE_VERT_TANGENT_SPACE)\r\nvar"
-"ying vec3      var_Tangent;\r\nvarying vec3      var_Bitangent;\r\n#endif\r"
-"\n\r\nvarying vec3      var_VertLight;\r\n\r\n#if defined(USE_LIGHT) && !de"
-"fined(USE_DELUXEMAP)\r\nvarying vec3      var_WorldLight;\r\n#endif\r\n\r\n"
-"#if defined(USE_LIGHT_VECTOR) && !defined(USE_FAST_LIGHT) && defined(USE_SH"
-"ADOWMAP)\r\nvarying vec4   var_ScreenPos;\r\n#endif\r\n\r\n#define EPSILON "
-"0.00000001\r\n\r\n#if defined(USE_PARALLAXMAP)\r\nfloat SampleHeight(sample"
-"r2D normalMap, vec2 t)\r\n{\r\n  #if defined(SWIZZLE_NORMALMAP)\r\n\treturn"
-" texture2D(normalMap, t).r;\r\n  #else\r\n\treturn texture2D(normalMap, t)."
-"a;\r\n  #endif\r\n}\r\n\r\nfloat RayIntersectDisplaceMap(vec2 dp, vec2 ds, "
-"sampler2D normalMap)\r\n{\r\n\tconst int linearSearchSteps = 16;\r\n\tconst"
-" int binarySearchSteps = 6;\r\n\r\n\tfloat depthStep = 1.0 / float(linearSe"
-"archSteps);\r\n\r\n\t// current size of search window\r\n\tfloat size = dep"
-"thStep;\r\n\r\n\t// current depth position\r\n\tfloat depth = 0.0;\r\n\r\n"
-"\t// best match found (starts with last position 1.0)\r\n\tfloat bestDepth "
-"= 1.0;\r\n\r\n\t// search front to back for first point inside object\r\n\t"
-"for(int i = 0; i < linearSearchSteps - 1; ++i)\r\n\t{\r\n\t\tdepth += size;"
-"\r\n\t\t\r\n\t\tfloat t = 1.0 - SampleHeight(normalMap, dp + ds * depth);\r"
-"\n\t\t\r\n\t\tif(bestDepth > 0.996)\t\t// if no depth found yet\r\n\t\t\tif"
-"(depth >= t)\r\n\t\t\t\tbestDepth = depth;\t// store best depth\r\n\t}\r\n"
-"\r\n\tdepth = bestDepth;\r\n\t\r\n\t// recurse around first point (depth) f"
-"or closest match\r\n\tfor(int i = 0; i < binarySearchSteps; ++i)\r\n\t{\r\n"
-"\t\tsize *= 0.5;\r\n\r\n\t\tfloat t = 1.0 - SampleHeight(normalMap, dp + ds"
-" * depth);\r\n\t\t\r\n\t\tif(depth >= t)\r\n\t\t{\r\n\t\t\tbestDepth = dept"
-"h;\r\n\t\t\tdepth -= 2.0 * size;\r\n\t\t}\r\n\r\n\t\tdepth += size;\r\n\t}"
-"\r\n\r\n\treturn bestDepth;\r\n}\r\n#endif\r\n\r\nfloat CalcDiffuse(vec3 N,"
-" vec3 L, vec3 E, float NE, float NL, float fzero, float shininess)\r\n{\r\n"
-"  #if defined(USE_OREN_NAYAR) || defined(USE_TRIACE_OREN_NAYAR)\r\n\tfloat "
-"gamma = dot(E, L) - NE * NL;\r\n\tfloat B = 2.22222 + 0.1 * shininess;\r\n"
-"\t\t\r\n\t#if defined(USE_OREN_NAYAR)\r\n\tfloat A = 1.0 - 1.0 / (2.0 + 0.3"
-"3 * shininess);\r\n\tgamma = clamp(gamma, 0.0, 1.0);\r\n\t#endif\r\n\t\r\n"
-"\t#if defined(USE_TRIACE_OREN_NAYAR)\r\n\tfloat A = 1.0 - 1.0 / (2.0 + 0.65"
-" * shininess);\r\n\r\n\tif (gamma >= 0.0)\r\n\t#endif\r\n\t{\r\n\t\tB *= ma"
-"x(max(NL, NE), EPSILON);\r\n\t}\r\n\r\n\treturn (A + gamma / B) * (1.0 - fz"
-"ero);\r\n  #else\r\n\treturn 1.0 - fzero;\r\n  #endif\r\n}\r\n\r\n#if defin"
-"ed(USE_SPECULARMAP)\r\nfloat CalcSpecular(float NH, float NL, float NE, flo"
-"at EH, float fzero, float shininess)\r\n{\r\n  #if defined(USE_BLINN) || de"
-"fined(USE_TRIACE) || defined(USE_TORRANCE_SPARROW)\r\n\tfloat blinn = pow(N"
-"H, shininess);\r\n  #endif\r\n\r\n  #if defined(USE_BLINN)\r\n\treturn blin"
-"n;\r\n  #endif\r\n\r\n  #if defined(USE_COOK_TORRANCE) || defined (USE_TRIA"
-"CE) || defined (USE_TORRANCE_SPARROW)\r\n\tfloat fresnel = fzero + (1.0 - f"
-"zero) * pow(1.0 - EH, 5);\r\n  #endif\r\n\r\n  #if defined(USE_COOK_TORRANC"
-"E) || defined(USE_TORRANCE_SPARROW)\r\n\tfloat geo = 2.0 * NH * min(NE, NL)"
-";\r\n\tgeo /= max(EH, geo);\r\n  #endif  \r\n\r\n  #if defined(USE_COOK_TOR"
-"RANCE)\r\n\tfloat m_sq = 2.0 / max(shininess, EPSILON);\r\n\tfloat NH_sq = "
-"NH * NH;\r\n\tfloat m_NH_sq = m_sq * NH_sq;\r\n\tfloat beckmann = exp((NH_s"
-"q - 1.0) / max(m_NH_sq, EPSILON)) / max(4.0 * m_NH_sq * NH_sq, EPSILON);\r"
-"\n\r\n\treturn fresnel * geo * beckmann / max(NE, EPSILON);\r\n  #endif\r\n"
-"\r\n  #if defined(USE_TRIACE)\r\n\tfloat scale = 0.1248582 * shininess + 0."
-"2691817;\r\n\r\n\treturn fresnel * scale * blinn / max(max(NL, NE), EPSILON"
-");\r\n  #endif\r\n  \r\n  #if defined(USE_TORRANCE_SPARROW)\r\n\tfloat scal"
-"e = 0.125 * shininess + 1.0;\r\n\r\n\treturn fresnel * geo * scale * blinn "
-"/ max(NE, EPSILON);\r\n  #endif\r\n}\r\n#endif\r\n\r\nvoid main()\r\n{\r\n#"
-"if !defined(USE_FAST_LIGHT) && (defined(USE_LIGHT) || defined(USE_NORMALMAP"
-"))\r\n\tvec3 surfNormal = normalize(var_Normal);\r\n#endif\r\n\r\n#if defin"
-"ed(USE_DELUXEMAP)\r\n\tvec3 worldLight = 2.0 * texture2D(u_DeluxeMap, var_L"
-"ightTex).xyz - vec3(1.0);\r\n\t//worldLight += var_WorldLight * 0.0001;\r\n"
-"#elif defined(USE_LIGHT)\r\n\tvec3 worldLight = var_WorldLight;\r\n#endif\r"
-"\n\r\n#if defined(USE_LIGHTMAP)\r\n\tvec4 lightSample = texture2D(u_LightMa"
-"p, var_LightTex).rgba;\r\n  #if defined(RGBE_LIGHTMAP)\r\n\tlightSample.rgb"
-" *= exp2(lightSample.a * 255.0 - 128.0);\r\n  #endif\r\n\tvec3 directedLigh"
-"t = lightSample.rgb;\r\n#elif defined(USE_LIGHT_VECTOR) && !defined(USE_FAS"
-"T_LIGHT)\r\n  #if defined(USE_INVSQRLIGHT)\r\n\tfloat intensity = 1.0 / dot"
-"(worldLight, worldLight);\r\n  #else\r\n\tfloat intensity = clamp((1.0 - do"
-"t(worldLight, worldLight) / (u_LightRadius * u_LightRadius)) * 1.07, 0.0, 1"
-".0);\r\n  #endif\r\n\r\n\tvec3 directedLight = u_DirectedLight * intensity;"
-"\r\n\tvec3 ambientLight  = u_AmbientLight;\r\n\r\n  #if defined(USE_SHADOWM"
-"AP)\r\n\t//vec2 shadowTex = gl_FragCoord.xy * r_FBufScale;\r\n\tvec2 shadow"
-"Tex = var_ScreenPos.xy / var_ScreenPos.w;\r\n\tdirectedLight *= texture2D(u"
-"_ShadowMap, shadowTex).r;\r\n  #endif\r\n#elif defined(USE_LIGHT_VERTEX) &&"
-" !defined(USE_FAST_LIGHT)\r\n\tvec3 directedLight = var_VertLight;\r\n#endi"
-"f\r\n\t\r\n#if defined(USE_TCGEN) || defined(USE_NORMALMAP) || (defined(USE"
-"_LIGHT) && !defined(USE_FAST_LIGHT))\r\n\tvec3 SampleToView = normalize(var"
-"_SampleToView);\r\n#endif\r\n\tvec2 tex = var_DiffuseTex;\r\n\r\n\tfloat am"
-"bientDiff = 1.0;\r\n\r\n#if defined(USE_NORMALMAP)\r\n  #if defined(USE_VER"
-"T_TANGENT_SPACE)\r\n    vec3   tangent = var_Tangent;\r\n\tvec3 bitangent ="
-" var_Bitangent;\r\n  #else\r\n\tvec3 q0  = dFdx(var_Position);\r\n\tvec3 q1"
-"  = dFdy(var_Position);\r\n\tvec2 st0 = dFdx(tex);\r\n\tvec2 st1 = dFdy(tex"
-");\r\n\tfloat dir = sign(st1.t * st0.s - st0.t * st1.s);\r\n\r\n\tvec3   ta"
-"ngent = normalize( q0 * st1.t - q1 * st0.t) * dir;\r\n\tvec3 bitangent = -n"
-"ormalize( q0 * st1.s - q1 * st0.s) * dir;\r\n  #endif\r\n\r\n\tmat3 tangent"
-"ToWorld = mat3(tangent, bitangent, var_Normal);\r\n\r\n  #if defined(USE_PA"
-"RALLAXMAP)\r\n\tvec3 offsetDir = normalize(SampleToView * tangentToWorld);"
-"\r\n    #if 0\r\n    float height = SampleHeight(u_NormalMap, tex);\r\n\tfl"
-"oat pdist = 0.05 * height - (0.05 / 2.0);\r\n    #else\r\n\toffsetDir.xy *="
-" -0.05 / offsetDir.z;\r\n\tfloat pdist = RayIntersectDisplaceMap(tex, offse"
-"tDir.xy, u_NormalMap);\r\n    #endif\t\r\n\ttex += offsetDir.xy * pdist;\r"
-"\n  #endif\r\n  #if defined(SWIZZLE_NORMALMAP)\r\n\tvec3 normal = 2.0 * tex"
-"ture2D(u_NormalMap, tex).agb - 1.0;\r\n  #else\r\n\tvec3 normal = 2.0 * tex"
-"ture2D(u_NormalMap, tex).rgb - 1.0;\r\n  #endif\r\n\tnormal.z = sqrt(clamp("
-"1.0 - dot(normal.xy, normal.xy), 0.0, 1.0));\r\n\tvec3 worldNormal = tangen"
-"tToWorld * normal;\r\n  #if defined(r_normalAmbient)\r\n\tambientDiff = 0.7"
-"81341 * normal.z + 0.218659;\r\n  #endif\r\n#elif defined(USE_LIGHT) && !de"
-"fined(USE_FAST_LIGHT)\r\n\tvec3 worldNormal = surfNormal;\r\n#endif\r\n\r\n"
-"#if (defined(USE_LIGHT) && !defined(USE_FAST_LIGHT)) || (defined(USE_TCGEN)"
-" && defined(USE_NORMALMAP))\r\n\tworldNormal = normalize(worldNormal);\r\n#"
-"endif\r\n\r\n#if defined(USE_TCGEN) && defined(USE_NORMALMAP)\r\n\tif (u_TC"
-"Gen0 == TCGEN_ENVIRONMENT_MAPPED)\r\n\t{\r\n\t\ttex = -reflect(normalize(Sa"
-"mpleToView), worldNormal).yz * vec2(0.5, -0.5) + 0.5;\r\n\t}\r\n#endif\r\n"
-"\r\n\tvec4 diffuse = texture2D(u_DiffuseMap, tex);\r\n\r\n#if defined(USE_L"
-"IGHT) && defined(USE_FAST_LIGHT)\r\n  #if defined(USE_LIGHTMAP)\r\n\tdiffus"
-"e.rgb *= directedLight;\r\n  #endif\r\n#elif defined(USE_LIGHT)\r\n\tworldL"
-"ight = normalize(worldLight);\r\n\r\n  #if defined(USE_LIGHTMAP) || defined"
-"(USE_LIGHT_VERTEX)\r\n\t#if defined(r_normalAmbient)\r\n\tvec3 ambientLight"
-" = directedLight * r_normalAmbient;\r\n\tdirectedLight -= ambientLight;\r\n"
-"    #else\r\n\tvec3 ambientLight = vec3(0.0);\r\n    #endif\r\n\tdirectedLi"
-"ght /= max(dot(surfNormal, worldLight), 0.004);\r\n  #endif\r\n\r\n\tfloat "
-"NL = clamp(dot(worldNormal,  worldLight),   0.0, 1.0);\r\n\tfloat surfNL = "
-"clamp(dot(surfNormal,  worldLight),   0.0, 1.0);\r\n\tNL = min(NL, surfNL *"
-" 2.0);\r\n\tfloat NE = clamp(dot(worldNormal,  SampleToView), 0.0, 1.0);\r"
-"\n\t\r\n\tfloat fzero = u_MaterialInfo.x;\r\n\tfloat shininess = u_Material"
-"Info.y;\r\n  #if defined(USE_SPECULARMAP)\r\n\tvec4 specular = texture2D(u_"
-"SpecularMap, tex);\r\n\t//specular.rgb = clamp(specular.rgb - diffuse.rgb, "
-"0.0, 1.0);\r\n\tshininess *= specular.a;\r\n  #endif\r\n\tfloat directedDif"
-"f = NL * CalcDiffuse(worldNormal, worldLight, SampleToView, NE, NL, fzero, "
-"shininess);\r\n\tdiffuse.rgb *= directedLight * directedDiff + ambientDiff "
-"* ambientLight;\r\n  \r\n  #if defined(USE_SPECULARMAP)\r\n\tvec3 halfAngle"
-" = normalize(worldLight + SampleToView);\r\n\r\n\tfloat EH = clamp(dot(Samp"
-"leToView, halfAngle), 0.0, 1.0);\r\n\tfloat NH = clamp(dot(worldNormal,  ha"
-"lfAngle), 0.0, 1.0);\r\n\r\n\tfloat directedSpec = NL * CalcSpecular(NH, NL"
-", NE, EH, fzero, shininess);\r\n  \r\n    #if defined(r_normalAmbient)\r\n"
-"\tvec3 ambientHalf = normalize(surfNormal + SampleToView);\r\n\tfloat ambie"
-"ntSpec = max(dot(ambientHalf, worldNormal) + 0.5, 0.0);\r\n\tambientSpec *="
-" ambientSpec * 0.44;\r\n\tambientSpec = pow(ambientSpec, shininess) * fzero"
-";\r\n\tspecular.rgb *= directedSpec * directedLight + ambientSpec * ambient"
-"Light;\r\n    #else\r\n\tspecular.rgb *= directedSpec * directedLight;\r\n "
-"   #endif\r\n  #endif\r\n#endif\r\n\r\n\tgl_FragColor = diffuse;\r\n\r\n#if"
-" defined(USE_SPECULARMAP) && defined(USE_LIGHT) && !defined(USE_FAST_LIGHT)"
-"\r\n\tgl_FragColor.rgb += specular.rgb;\r\n#endif\r\n\r\n\tgl_FragColor *= "
-"var_Color;\r\n}\r\n";
-
-static const char *fallbackShadowfillShader_vp =
-"attribute vec4  attr_Position;\r\nattribute vec3  attr_Normal;\r\nattribute"
-" vec4  attr_TexCoord0;\r\n\r\n//#if defined(USE_VERTEX_ANIMATION)\r\nattrib"
-"ute vec4  attr_Position2;\r\nattribute vec3  attr_Normal2;\r\n//#endif\r\n"
-"\r\n//#if defined(USE_DEFORM_VERTEXES)\r\nuniform int     u_DeformGen;\r\nu"
-"niform float    u_DeformParams[5];\r\n//#endif\r\n\r\nuniform float   u_Tim"
-"e;\r\nuniform mat4    u_ModelViewProjectionMatrix;\r\n\r\nuniform mat4   u_"
-"ModelMatrix;\r\n\r\n//#if defined(USE_VERTEX_ANIMATION)\r\nuniform float   "
-"u_VertexLerp;\r\n//#endif\r\n\r\nvarying vec3    var_Position;\r\n\r\nvec3 "
-"DeformPosition(const vec3 pos, const vec3 normal, const vec2 st)\r\n{\r\n\t"
-"if (u_DeformGen == 0)\r\n\t{\r\n\t\treturn pos;\r\n\t}\r\n\r\n\tfloat base "
-"=      u_DeformParams[0];\r\n\tfloat amplitude = u_DeformParams[1];\r\n\tfl"
-"oat phase =     u_DeformParams[2];\r\n\tfloat frequency = u_DeformParams[3]"
-";\r\n\tfloat spread =    u_DeformParams[4];\r\n\r\n\tif (u_DeformGen == DGE"
-"N_BULGE)\r\n\t{\r\n\t\tphase *= M_PI * 0.25 * st.x;\r\n\t}\r\n\telse // if "
-"(u_DeformGen <= DGEN_WAVE_INVERSE_SAWTOOTH)\r\n\t{\r\n\t\tphase += dot(pos."
-"xyz, vec3(spread));\r\n\t}\r\n\r\n\tfloat value = phase + (u_Time * frequen"
-"cy);\r\n\tfloat func;\r\n\r\n\tif (u_DeformGen == DGEN_WAVE_SIN)\r\n\t{\r\n"
-"\t\tfunc = sin(value * 2.0 * M_PI);\r\n\t}\r\n\telse if (u_DeformGen == DGE"
-"N_WAVE_SQUARE)\r\n\t{\r\n\t\tfunc = sign(sin(value * 2.0 * M_PI));\r\n\t}\r"
-"\n\telse if (u_DeformGen == DGEN_WAVE_TRIANGLE)\r\n\t{\r\n\t\tfunc = abs(fr"
-"act(value + 0.75) - 0.5) * 4.0 - 1.0;\r\n\t}\r\n\telse if (u_DeformGen == D"
-"GEN_WAVE_SAWTOOTH)\r\n\t{\r\n\t\tfunc = fract(value);\r\n\t}\r\n\telse if ("
-"u_DeformGen == DGEN_WAVE_INVERSE_SAWTOOTH)\r\n\t{\r\n\t\tfunc = (1.0 - frac"
-"t(value));\r\n\t}\r\n\telse if (u_DeformGen == DGEN_BULGE)\r\n\t{\r\n\t\tfu"
-"nc = sin(value);\r\n\t}\r\n\r\n\treturn pos + normal * (base + func * ampli"
-"tude);\r\n}\r\n\r\nvoid main()\r\n{\r\n\tvec4 position = mix(attr_Position,"
-" attr_Position2, u_VertexLerp);\r\n\tvec3 normal = normalize(mix(attr_Norma"
-"l, attr_Normal2, u_VertexLerp));\r\n\r\n\tposition.xyz = DeformPosition(pos"
-"ition.xyz, normal, attr_TexCoord0.st);\r\n\r\n\tgl_Position = u_ModelViewPr"
-"ojectionMatrix * position;\r\n\t\r\n\tvar_Position  = (u_ModelMatrix * posi"
-"tion).xyz;\r\n}\r\n";
-
-static const char *fallbackShadowfillShader_fp =
-"uniform vec4  u_LightOrigin;\r\nuniform float u_LightRadius;\r\n\r\nvarying"
-" vec3  var_Position;\r\n\r\nvoid main()\r\n{\r\n#if defined(USE_DEPTH)\r\n"
-"\tfloat depth = length(u_LightOrigin.xyz - var_Position) / u_LightRadius;\r"
-"\n #if 0\r\n\t// 32 bit precision\r\n\tconst vec4 bitSh = vec4( 256 * 256 *"
-" 256,   256 * 256,         256,           1);\r\n\tconst vec4 bitMsk = vec4"
-"(              0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0);\r\n\t\r\n\tvec4 c"
-"omp;\r\n\tcomp = depth * bitSh;\r\n\tcomp.xyz = fract(comp.xyz);\r\n\tcomp "
-"-= comp.xxyz * bitMsk;\r\n\tgl_FragColor = comp;\r\n #endif\r\n\r\n #if 1\r"
-"\n\t// 24 bit precision\r\n\tconst vec3 bitSh = vec3( 256 * 256,         25"
-"6,           1);\r\n\tconst vec3 bitMsk = vec3(        0, 1.0 / 256.0, 1.0 "
-"/ 256.0);\r\n\t\r\n\tvec3 comp;\r\n\tcomp = depth * bitSh;\r\n\tcomp.xy = f"
-"ract(comp.xy);\r\n\tcomp -= comp.xxy * bitMsk;\r\n\tgl_FragColor = vec4(com"
-"p, 1.0);\r\n #endif\r\n\r\n #if 0\r\n\t// 8 bit precision\r\n\tgl_FragColor"
-" = vec4(depth, depth, depth, 1);\r\n #endif\r\n#else\r\n\tgl_FragColor = ve"
-"c4(0, 0, 0, 1);\r\n#endif\r\n}\r\n";
-
-static const char *fallbackPshadowShader_vp =
-"attribute vec4 attr_Position;\r\nattribute vec3 attr_Normal;\r\n\r\nuniform"
-" mat4   u_ModelViewProjectionMatrix;\r\nvarying vec3   var_Position;\r\nvar"
-"ying vec3   var_Normal;\r\n\r\n\r\nvoid main()\r\n{\r\n\tvec4 position  = a"
-"ttr_Position;\r\n\r\n\tgl_Position = u_ModelViewProjectionMatrix * position"
-";\r\n\r\n\tvar_Position  = position.xyz;\r\n\tvar_Normal    = attr_Normal;"
-"\r\n}\r\n";
-
-static const char *fallbackPshadowShader_fp =
-"uniform sampler2D u_ShadowMap;\r\n\r\nuniform vec3      u_LightForward;\r\n"
-"uniform vec3      u_LightUp;\r\nuniform vec3      u_LightRight;\r\nuniform "
-"vec4      u_LightOrigin;\r\nuniform float     u_LightRadius;\r\nvarying vec"
-"3      var_Position;\r\nvarying vec3      var_Normal;\r\n\r\nfloat sampleDi"
-"stMap(sampler2D texMap, vec2 uv, float scale)\r\n{\r\n\tvec3 distv = textur"
-"e2D(texMap, uv).xyz;\r\n\treturn dot(distv, vec3(1.0 / (256.0 * 256.0), 1.0"
-" / 256.0, 1.0)) * scale;\r\n}\r\n\r\nvoid main()\r\n{\r\n\tvec3 lightToPos "
-"= var_Position - u_LightOrigin.xyz;\r\n\tvec2 st = vec2(-dot(u_LightRight, "
-"lightToPos), dot(u_LightUp, lightToPos));\r\n\t\r\n\tfloat fade = length(st"
-");\r\n\t\r\n#if defined(USE_DISCARD)\r\n\tif (fade >= 1.0)\r\n\t{\r\n\t\tdi"
-"scard;\r\n\t}\r\n#endif\r\n\r\n\tfade = clamp(8.0 - fade * 8.0, 0.0, 1.0);"
-"\r\n\t\r\n\tst = st * 0.5 + vec2(0.5);\r\n\r\n#if defined(USE_SOLID_PSHADOW"
-"S)\r\n\tfloat intensity = max(sign(u_LightRadius - length(lightToPos)), 0.0"
-");\r\n#else\r\n\tfloat intensity = clamp((1.0 - dot(lightToPos, lightToPos)"
-" / (u_LightRadius * u_LightRadius)) * 2.0, 0.0, 1.0);\r\n#endif\r\n\t\r\n\t"
-"float lightDist = length(lightToPos);\r\n\tfloat dist;\r\n\r\n#if defined(U"
-"SE_DISCARD)\r\n\tif (dot(u_LightForward, lightToPos) <= 0.0)\r\n\t{\r\n\t\t"
-"discard;\r\n\t}\r\n\r\n\tif (dot(var_Normal, lightToPos) > 0.0)\r\n\t{\r\n"
-"\t\tdiscard;\r\n\t}\r\n#else\r\n\tintensity *= max(sign(dot(u_LightForward,"
-" lightToPos)), 0.0);\r\n\tintensity *= max(sign(-dot(var_Normal, lightToPos"
-")), 0.0);\r\n#endif\r\n\r\n\tintensity *= fade;\r\n#if defined(USE_PCF)\r\n"
-"\tfloat part;\r\n\t\r\n\tdist = sampleDistMap(u_ShadowMap, st + vec2(-1.0/5"
-"12.0, -1.0/512.0), u_LightRadius);\r\n\tpart =  max(sign(lightDist - dist),"
-" 0.0);\r\n\r\n\tdist = sampleDistMap(u_ShadowMap, st + vec2( 1.0/512.0, -1."
-"0/512.0), u_LightRadius);\r\n\tpart += max(sign(lightDist - dist), 0.0);\r"
-"\n\r\n\tdist = sampleDistMap(u_ShadowMap, st + vec2(-1.0/512.0,  1.0/512.0)"
-", u_LightRadius);\r\n\tpart += max(sign(lightDist - dist), 0.0);\r\n\r\n\td"
-"ist = sampleDistMap(u_ShadowMap, st + vec2( 1.0/512.0,  1.0/512.0), u_Light"
-"Radius);\r\n\tpart += max(sign(lightDist - dist), 0.0);\r\n\r\n  #if define"
-"d(USE_DISCARD)\r\n\tif (part <= 0.0)\r\n\t{\r\n\t\tdiscard;\r\n\t}\r\n  #en"
-"dif\r\n\r\n\tintensity *= part * 0.25;\r\n#else\r\n\tdist = sampleDistMap(u"
-"_ShadowMap, st, u_LightRadius);\r\n\r\n  #if defined(USE_DISCARD)\r\n\tif ("
-"lightDist - dist <= 0.0)\r\n\t{\r\n\t\tdiscard;\r\n\t}\r\n  #endif\r\n\t\t"
-"\t\r\n\tintensity *= max(sign(lightDist - dist), 0.0);\r\n#endif\r\n\t\t\r"
-"\n\tgl_FragColor.rgb = vec3(0);\r\n\tgl_FragColor.a = clamp(intensity, 0.0,"
-" 0.75);\r\n}\r\n";
-
-static const char *fallbackDown4xShader_vp =
-"attribute vec4 attr_Position;\r\nattribute vec4 attr_TexCoord0;\r\n\r\nunif"
-"orm mat4   u_ModelViewProjectionMatrix;\r\n\r\nvarying vec2   var_TexCoords"
-";\r\n\r\n\r\nvoid main()\r\n{\r\n\tgl_Position = u_ModelViewProjectionMatri"
-"x * attr_Position;\r\n\tvar_TexCoords = attr_TexCoord0.st;\r\n}\r\n";
-
-static const char *fallbackDown4xShader_fp =
-"uniform sampler2D u_TextureMap;\r\n\r\nuniform vec2      u_InvTexRes;\r\nva"
-"rying vec2      var_TexCoords;\r\n\r\nvoid main()\r\n{\r\n\tvec4 color;\r\n"
-"\tvec2 tc;\r\n\t\r\n\ttc = var_TexCoords + u_InvTexRes * vec2(-1.5, -1.5); "
-" color  = texture2D(u_TextureMap, tc);\r\n\ttc = var_TexCoords + u_InvTexRe"
-"s * vec2(-0.5, -1.5);  color += texture2D(u_TextureMap, tc);\r\n\ttc = var_"
-"TexCoords + u_InvTexRes * vec2( 0.5, -1.5);  color += texture2D(u_TextureMa"
-"p, tc);\r\n\ttc = var_TexCoords + u_InvTexRes * vec2( 1.5, -1.5);  color +="
-" texture2D(u_TextureMap, tc);\r\n\r\n\ttc = var_TexCoords + u_InvTexRes * v"
-"ec2(-1.5, -0.5); color += texture2D(u_TextureMap, tc);\r\n\ttc = var_TexCoo"
-"rds + u_InvTexRes * vec2(-0.5, -0.5); color += texture2D(u_TextureMap, tc);"
-"\r\n\ttc = var_TexCoords + u_InvTexRes * vec2( 0.5, -0.5); color += texture"
-"2D(u_TextureMap, tc);\r\n\ttc = var_TexCoords + u_InvTexRes * vec2( 1.5, -0"
-".5); color += texture2D(u_TextureMap, tc);\r\n\r\n\ttc = var_TexCoords + u_"
-"InvTexRes * vec2(-1.5,  0.5); color += texture2D(u_TextureMap, tc);\r\n\ttc"
-" = var_TexCoords + u_InvTexRes * vec2(-0.5,  0.5); color += texture2D(u_Tex"
-"tureMap, tc);\r\n\ttc = var_TexCoords + u_InvTexRes * vec2( 0.5,  0.5); col"
-"or += texture2D(u_TextureMap, tc);\r\n\ttc = var_TexCoords + u_InvTexRes * "
-"vec2( 1.5,  0.5); color += texture2D(u_TextureMap, tc);\r\n\r\n\ttc = var_T"
-"exCoords + u_InvTexRes * vec2(-1.5,  1.5);  color += texture2D(u_TextureMap"
-", tc);\r\n\ttc = var_TexCoords + u_InvTexRes * vec2(-0.5,  1.5);  color += "
-"texture2D(u_TextureMap, tc);\r\n\ttc = var_TexCoords + u_InvTexRes * vec2( "
-"0.5,  1.5);  color += texture2D(u_TextureMap, tc);\r\n\ttc = var_TexCoords "
-"+ u_InvTexRes * vec2( 1.5,  1.5);  color += texture2D(u_TextureMap, tc);\r"
-"\n\t\r\n\tcolor *= 0.0625;\r\n\t\r\n\tgl_FragColor = color;\r\n}\r\n";
-
-static const char *fallbackBokehShader_vp =
-"attribute vec4 attr_Position;\r\nattribute vec4 attr_TexCoord0;\r\n\r\nunif"
-"orm mat4   u_ModelViewProjectionMatrix;\r\n\r\nvarying vec2   var_TexCoords"
-";\r\n\r\n\r\nvoid main()\r\n{\r\n\tgl_Position = u_ModelViewProjectionMatri"
-"x * attr_Position;\r\n\tvar_TexCoords = attr_TexCoord0.st;\r\n}\r\n";
-
-static const char *fallbackBokehShader_fp =
-"uniform sampler2D u_TextureMap;\r\n\r\nuniform vec4      u_Color;\r\n\r\nun"
-"iform vec2      u_InvTexRes;\r\nvarying vec2      var_TexCoords;\r\n\r\nvoi"
-"d main()\r\n{\r\n\tvec4 color;\r\n\tvec2 tc;\r\n\r\n#if 0\r\n\tfloat c[7] ="
-" float[7](1.0, 0.9659258263, 0.8660254038, 0.7071067812, 0.5, 0.2588190451,"
-" 0.0);\r\n\r\n\ttc = var_TexCoords + u_InvTexRes * vec2(  c[0],  c[6]);  co"
-"lor =  texture2D(u_TextureMap, tc);\r\n\ttc = var_TexCoords + u_InvTexRes *"
-" vec2(  c[1],  c[5]);  color += texture2D(u_TextureMap, tc);\r\n\ttc = var_"
-"TexCoords + u_InvTexRes * vec2(  c[2],  c[4]);  color += texture2D(u_Textur"
-"eMap, tc);\r\n\ttc = var_TexCoords + u_InvTexRes * vec2(  c[3],  c[3]);  co"
-"lor += texture2D(u_TextureMap, tc);\r\n\ttc = var_TexCoords + u_InvTexRes *"
-" vec2(  c[4],  c[2]);  color += texture2D(u_TextureMap, tc);\r\n\ttc = var_"
-"TexCoords + u_InvTexRes * vec2(  c[5],  c[1]);  color += texture2D(u_Textur"
-"eMap, tc);\r\n\ttc = var_TexCoords + u_InvTexRes * vec2(  c[6],  c[0]);  co"
-"lor += texture2D(u_TextureMap, tc);\r\n\r\n\ttc = var_TexCoords + u_InvTexR"
-"es * vec2(  c[1], -c[5]);  color += texture2D(u_TextureMap, tc);\r\n\ttc = "
-"var_TexCoords + u_InvTexRes * vec2(  c[2], -c[4]);  color += texture2D(u_Te"
-"xtureMap, tc);\r\n\ttc = var_TexCoords + u_InvTexRes * vec2(  c[3], -c[3]);"
-"  color += texture2D(u_TextureMap, tc);\r\n\ttc = var_TexCoords + u_InvTexR"
-"es * vec2(  c[4], -c[2]);  color += texture2D(u_TextureMap, tc);\r\n\ttc = "
-"var_TexCoords + u_InvTexRes * vec2(  c[5], -c[1]);  color += texture2D(u_Te"
-"xtureMap, tc);\r\n\ttc = var_TexCoords + u_InvTexRes * vec2(  c[6], -c[0]);"
-"  color += texture2D(u_TextureMap, tc);\r\n\r\n\ttc = var_TexCoords + u_Inv"
-"TexRes * vec2( -c[0],  c[6]);  color += texture2D(u_TextureMap, tc);\r\n\tt"
-"c = var_TexCoords + u_InvTexRes * vec2( -c[1],  c[5]);  color += texture2D("
-"u_TextureMap, tc);\r\n\ttc = var_TexCoords + u_InvTexRes * vec2( -c[2],  c["
-"4]);  color += texture2D(u_TextureMap, tc);\r\n\ttc = var_TexCoords + u_Inv"
-"TexRes * vec2( -c[3],  c[3]);  color += texture2D(u_TextureMap, tc);\r\n\tt"
-"c = var_TexCoords + u_InvTexRes * vec2( -c[4],  c[2]);  color += texture2D("
-"u_TextureMap, tc);\r\n\ttc = var_TexCoords + u_InvTexRes * vec2( -c[5],  c["
-"1]);  color += texture2D(u_TextureMap, tc);\r\n\r\n\ttc = var_TexCoords + u"
-"_InvTexRes * vec2( -c[1], -c[5]);  color += texture2D(u_TextureMap, tc);\r"
-"\n\ttc = var_TexCoords + u_InvTexRes * vec2( -c[2], -c[4]);  color += textu"
-"re2D(u_TextureMap, tc);\r\n\ttc = var_TexCoords + u_InvTexRes * vec2( -c[3]"
-", -c[3]);  color += texture2D(u_TextureMap, tc);\r\n\ttc = var_TexCoords + "
-"u_InvTexRes * vec2( -c[4], -c[2]);  color += texture2D(u_TextureMap, tc);\r"
-"\n\ttc = var_TexCoords + u_InvTexRes * vec2( -c[5], -c[1]);  color += textu"
-"re2D(u_TextureMap, tc);\r\n\t\r\n\tgl_FragColor = color * 0.04166667 * u_Co"
-"lor;\r\n#endif\r\n\r\n\tfloat c[5] = float[5](1.0, 0.9238795325, 0.70710678"
-"12, 0.3826834324, 0.0);\r\n\r\n\ttc = var_TexCoords + u_InvTexRes * vec2(  "
-"c[0],  c[4]);  color =  texture2D(u_TextureMap, tc);\r\n\ttc = var_TexCoord"
-"s + u_InvTexRes * vec2(  c[1],  c[3]);  color += texture2D(u_TextureMap, tc"
-");\r\n\ttc = var_TexCoords + u_InvTexRes * vec2(  c[2],  c[2]);  color += t"
-"exture2D(u_TextureMap, tc);\r\n\ttc = var_TexCoords + u_InvTexRes * vec2(  "
-"c[3],  c[1]);  color += texture2D(u_TextureMap, tc);\r\n\ttc = var_TexCoord"
-"s + u_InvTexRes * vec2(  c[4],  c[0]);  color += texture2D(u_TextureMap, tc"
-");\r\n\r\n\ttc = var_TexCoords + u_InvTexRes * vec2(  c[1], -c[3]);  color "
-"+= texture2D(u_TextureMap, tc);\r\n\ttc = var_TexCoords + u_InvTexRes * vec"
-"2(  c[2], -c[2]);  color += texture2D(u_TextureMap, tc);\r\n\ttc = var_TexC"
-"oords + u_InvTexRes * vec2(  c[3], -c[1]);  color += texture2D(u_TextureMap"
-", tc);\r\n\ttc = var_TexCoords + u_InvTexRes * vec2(  c[4], -c[0]);  color "
-"+= texture2D(u_TextureMap, tc);\r\n\r\n\ttc = var_TexCoords + u_InvTexRes *"
-" vec2( -c[0],  c[4]);  color += texture2D(u_TextureMap, tc);\r\n\ttc = var_"
-"TexCoords + u_InvTexRes * vec2( -c[1],  c[3]);  color += texture2D(u_Textur"
-"eMap, tc);\r\n\ttc = var_TexCoords + u_InvTexRes * vec2( -c[2],  c[2]);  co"
-"lor += texture2D(u_TextureMap, tc);\r\n\ttc = var_TexCoords + u_InvTexRes *"
-" vec2( -c[3],  c[1]);  color += texture2D(u_TextureMap, tc);\r\n\r\n\ttc = "
-"var_TexCoords + u_InvTexRes * vec2( -c[1], -c[3]);  color += texture2D(u_Te"
-"xtureMap, tc);\r\n\ttc = var_TexCoords + u_InvTexRes * vec2( -c[2], -c[2]);"
-"  color += texture2D(u_TextureMap, tc);\r\n\ttc = var_TexCoords + u_InvTexR"
-"es * vec2( -c[3], -c[1]);  color += texture2D(u_TextureMap, tc);\r\n\t\r\n"
-"\tgl_FragColor = color * 0.0625 * u_Color;\r\n}\r\n";
-
-static const char *fallbackToneMapShader_vp =
-"attribute vec4 attr_Position;\r\nattribute vec4 attr_TexCoord0;\r\n\r\nunif"
-"orm mat4   u_ModelViewProjectionMatrix;\r\n\r\nvarying vec2   var_TexCoords"
-";\r\n\r\n\r\nvoid main()\r\n{\r\n\tgl_Position = u_ModelViewProjectionMatri"
-"x * attr_Position;\r\n\tvar_TexCoords = attr_TexCoord0.st;\r\n}\r\n";
-
-static const char *fallbackToneMapShader_fp =
-"uniform sampler2D u_TextureMap;\r\nuniform sampler2D u_LevelsMap;\r\n\r\nun"
-"iform vec4      u_Color;\r\n\r\nuniform vec2      u_AutoExposureMinMax;\r\n"
-"uniform vec3      u_ToneMinAvgMaxLinear;\r\n\r\nvarying vec2      var_TexCo"
-"ords;\r\n\r\nconst vec3  LUMINANCE_VECTOR =   vec3(0.2125, 0.7154, 0.0721);"
-" //vec3(0.299, 0.587, 0.114);\r\n\r\nvec3 FilmicTonemap(vec3 x)\r\n{\r\n\tc"
-"onst float SS  = 0.22; // Shoulder Strength\r\n\tconst float LS  = 0.30; //"
-" Linear Strength\r\n\tconst float LA  = 0.10; // Linear Angle\r\n\tconst fl"
-"oat TS  = 0.20; // Toe Strength\r\n\tconst float TAN = 0.01; // Toe Angle N"
-"umerator\r\n\tconst float TAD = 0.30; // Toe Angle Denominator\r\n\t\r\n\tv"
-"ec3 SSxx = SS * x * x;\r\n\tvec3 LSx = LS * x;\r\n\tvec3 LALSx = LSx * LA;"
-"\r\n\t\r\n\treturn ((SSxx + LALSx + TS * TAN) / (SSxx + LSx + TS * TAD)) - "
-"TAN / TAD;\r\n\r\n\t//return ((x*(SS*x+LA*LS)+TS*TAN)/(x*(SS*x+LS)+TS*TAD))"
-" - TAN/TAD;\r\n\r\n}\r\n\r\nvoid main()\r\n{\r\n\tvec4 color = texture2D(u_"
-"TextureMap, var_TexCoords) * u_Color;\r\n\tvec3 minAvgMax = texture2D(u_Lev"
-"elsMap, var_TexCoords).rgb;\r\n\tvec3 logMinAvgMaxLum = clamp(minAvgMax * 2"
-"0.0 - 10.0, -u_AutoExposureMinMax.y, -u_AutoExposureMinMax.x);\r\n\t\t\r\n"
-"\tfloat avgLum = exp2(logMinAvgMaxLum.y);\r\n\t//float maxLum = exp2(logMin"
-"AvgMaxLum.z);\r\n\r\n\tcolor.rgb *= u_ToneMinAvgMaxLinear.y / avgLum;\r\n\t"
-"color.rgb = max(vec3(0.0), color.rgb - vec3(u_ToneMinAvgMaxLinear.x));\r\n"
-"\r\n\tvec3 fWhite = 1.0 / FilmicTonemap(vec3(u_ToneMinAvgMaxLinear.z - u_To"
-"neMinAvgMaxLinear.x));\r\n\tcolor.rgb = FilmicTonemap(color.rgb) * fWhite;"
-"\r\n\t\r\n\tgl_FragColor = clamp(color, 0.0, 1.0);\r\n}\r\n";
-
-static const char *fallbackCalcLevels4xShader_vp =
-"attribute vec4 attr_Position;\r\nattribute vec4 attr_TexCoord0;\r\n\r\nunif"
-"orm mat4   u_ModelViewProjectionMatrix;\r\n\r\nvarying vec2   var_TexCoords"
-";\r\n\r\n\r\nvoid main()\r\n{\r\n\tgl_Position = u_ModelViewProjectionMatri"
-"x * attr_Position;\r\n\tvar_TexCoords = attr_TexCoord0.st;\r\n}\r\n";
-
-static const char *fallbackCalcLevels4xShader_fp =
-"uniform sampler2D u_TextureMap;\r\n\r\nuniform vec4      u_Color;\r\n\r\nun"
-"iform vec2      u_InvTexRes;\r\nvarying vec2      var_TexCoords;\r\n\r\ncon"
-"st vec3  LUMINANCE_VECTOR =   vec3(0.2125, 0.7154, 0.0721); //vec3(0.299, 0"
-".587, 0.114);\r\n\r\nvec3 GetValues(vec2 offset, vec3 current)\r\n{\r\n\tve"
-"c3 minAvgMax;\r\n\tvec2 tc = var_TexCoords + u_InvTexRes * offset; minAvgMa"
-"x = texture2D(u_TextureMap, tc).rgb;\r\n\r\n#ifdef FIRST_PASS\r\n\tfloat lu"
-"mi = max(dot(LUMINANCE_VECTOR, minAvgMax), 0.000001);\r\n\tfloat loglumi = "
-"clamp(log2(lumi), -10.0, 10.0);\r\n\tminAvgMax = vec3(loglumi * 0.05 + 0.5)"
-";\r\n#endif\r\n\r\n\treturn vec3(min(current.x, minAvgMax.x), current.y + m"
-"inAvgMax.y, max(current.z, minAvgMax.z));\r\n}\r\n\r\nvoid main()\r\n{\r\n"
-"\tvec3 current = vec3(1.0, 0.0, 0.0);\r\n\r\n#ifdef FIRST_PASS\r\n\tcurrent"
-" = GetValues(vec2( 0.0,  0.0), current);\r\n#else\r\n\tcurrent = GetValues("
-"vec2(-1.5, -1.5), current);\r\n\tcurrent = GetValues(vec2(-0.5, -1.5), curr"
-"ent);\r\n\tcurrent = GetValues(vec2( 0.5, -1.5), current);\r\n\tcurrent = G"
-"etValues(vec2( 1.5, -1.5), current);\r\n\t\r\n\tcurrent = GetValues(vec2(-1"
-".5, -0.5), current);\r\n\tcurrent = GetValues(vec2(-0.5, -0.5), current);\r"
-"\n\tcurrent = GetValues(vec2( 0.5, -0.5), current);\r\n\tcurrent = GetValue"
-"s(vec2( 1.5, -0.5), current);\r\n\t\r\n\tcurrent = GetValues(vec2(-1.5,  0."
-"5), current);\r\n\tcurrent = GetValues(vec2(-0.5,  0.5), current);\r\n\tcur"
-"rent = GetValues(vec2( 0.5,  0.5), current);\r\n\tcurrent = GetValues(vec2("
-" 1.5,  0.5), current);\r\n\r\n\tcurrent = GetValues(vec2(-1.5,  1.5), curre"
-"nt);\r\n\tcurrent = GetValues(vec2(-0.5,  1.5), current);\r\n\tcurrent = Ge"
-"tValues(vec2( 0.5,  1.5), current);\r\n\tcurrent = GetValues(vec2( 1.5,  1."
-"5), current);\r\n\r\n\tcurrent.y *= 0.0625;\r\n#endif\r\n\r\n\tgl_FragColor"
-" = vec4(current, 1.0f);\r\n}\r\n";
-
-static const char *fallbackShadowmaskShader_vp =
-"attribute vec4 attr_Position;\r\nattribute vec4 attr_TexCoord0;\r\n\r\nunif"
-"orm vec3   u_ViewForward;\r\nuniform vec3   u_ViewLeft;\r\nuniform vec3   u"
-"_ViewUp;\r\nuniform vec4   u_ViewInfo; // zfar / znear\r\n\r\nvarying vec2 "
-"  var_ScreenTex;\r\nvarying vec3   var_ViewDir;\r\n\r\nvoid main()\r\n{\r\n"
-"\tgl_Position = attr_Position;\r\n\t//vec2 screenCoords = gl_Position.xy / "
-"gl_Position.w;\r\n\t//var_ScreenTex = screenCoords * 0.5 + 0.5;\r\n\tvar_Sc"
-"reenTex = attr_TexCoord0.xy;\r\n\tvec2 screenCoords = attr_TexCoord0.xy * 2"
-".0 - 1.0;\r\n\tvar_ViewDir = u_ViewForward + u_ViewLeft * -screenCoords.x +"
-" u_ViewUp * screenCoords.y;\r\n}\r\n";
-
-static const char *fallbackShadowmaskShader_fp =
-"uniform sampler2D u_ScreenDepthMap;\r\n\r\nuniform sampler2D u_ShadowMap;\r"
-"\n#if defined(USE_SHADOW_CASCADE)\r\nuniform sampler2D u_ShadowMap2;\r\nuni"
-"form sampler2D u_ShadowMap3;\r\n#endif\r\n\r\nuniform mat4      u_ShadowMvp"
-";\r\n#if defined(USE_SHADOW_CASCADE)\r\nuniform mat4      u_ShadowMvp2;\r\n"
-"uniform mat4      u_ShadowMvp3;\r\n#endif\r\n\r\nuniform vec3   u_ViewOrigi"
-"n;\r\nuniform vec4   u_ViewInfo; // zfar / znear, zfar\r\n\r\nvarying vec2 "
-"  var_ScreenTex;\r\nvarying vec3   var_ViewDir;\r\n\r\n// Input: It uses te"
-"xture coords as the random number seed.\r\n// Output: Random number: [0,1),"
-" that is between 0.0 and 0.999999... inclusive.\r\n// Author: Michael Pohor"
-"eski\r\n// Copyright: Copyleft 2012 :-)\r\n// Source: http://stackoverflow."
-"com/questions/5149544/can-i-generate-a-random-number-inside-a-pixel-shader"
-"\r\n\r\nfloat random( const vec2 p )\r\n{\r\n  // We need irrationals for p"
-"seudo randomness.\r\n  // Most (all?) known transcendental numbers will (ge"
-"nerally) work.\r\n  const vec2 r = vec2(\r\n    23.1406926327792690,  // e^"
-"pi (Gelfond's constant)\r\n     2.6651441426902251); // 2^sqrt(2) (Gelfond-"
-"Schneider constant)\r\n  //return fract( cos( mod( 123456789., 1e-7 + 256. "
-"* dot(p,r) ) ) );\r\n  return mod( 123456789., 1e-7 + 256. * dot(p,r) );  "
-"\r\n}\r\n\r\nfloat PCF(const sampler2D shadowmap, const vec2 st, const floa"
-"t dist)\r\n{\r\n\tfloat mult;\r\n\tfloat scale = 2.0 / r_shadowMapSize;\r\n"
-"\t\t\r\n#if defined(USE_SHADOW_FILTER)\r\n\tfloat r = random(var_ScreenTex."
-"xy);\r\n\tfloat sinr = sin(r) * scale;\r\n\tfloat cosr = cos(r) * scale;\r"
-"\n\tmat2 rmat = mat2(cosr, sinr, -sinr, cosr);\r\n\r\n\tmult =  step(dist, "
-"texture2D(shadowmap, st + rmat * vec2(-0.7055767, 0.196515)).r);\r\n\tmult "
-"+= step(dist, texture2D(shadowmap, st + rmat * vec2(0.3524343, -0.7791386))"
-".r);\r\n\tmult += step(dist, texture2D(shadowmap, st + rmat * vec2(0.239105"
-"6, 0.9189604)).r);\r\n  #if defined(USE_SHADOW_FILTER2)\r\n\tmult += step(d"
-"ist, texture2D(shadowmap, st + rmat * vec2(-0.07580382, -0.09224417)).r);\r"
-"\n\tmult += step(dist, texture2D(shadowmap, st + rmat * vec2(0.5784913, -0."
-"002528916)).r);\r\n\tmult += step(dist, texture2D(shadowmap, st + rmat * ve"
-"c2(0.192888, 0.4064181)).r);\r\n\tmult += step(dist, texture2D(shadowmap, s"
-"t + rmat * vec2(-0.6335801, -0.5247476)).r);\r\n\tmult += step(dist, textur"
-"e2D(shadowmap, st + rmat * vec2(-0.5579782, 0.7491854)).r);\r\n\tmult += st"
-"ep(dist, texture2D(shadowmap, st + rmat * vec2(0.7320465, 0.6317794)).r);\r"
-"\n\r\n\tmult *= 0.11111;\r\n  #else\r\n    mult *= 0.33333;\r\n  #endif\r\n"
-"#else\r\n\tmult = step(dist, texture2D(shadowmap, st).r);\r\n#endif\r\n\t\t"
-"\r\n\treturn mult;\r\n}\r\n\r\nfloat getLinearDepth(sampler2D depthMap, vec"
-"2 tex, float zFarDivZNear)\r\n{\r\n\t\tfloat sampleZDivW = texture2D(depthM"
-"ap, tex).r;\r\n\t\treturn 1.0 / mix(zFarDivZNear, 1.0, sampleZDivW);\r\n}\r"
-"\n\r\nvoid main()\r\n{\r\n\tfloat result;\r\n\t\r\n\tfloat depth = getLinea"
-"rDepth(u_ScreenDepthMap, var_ScreenTex, u_ViewInfo.x);\r\n\tfloat sampleZ ="
-" u_ViewInfo.y * depth;\r\n\r\n\tvec4 biasPos = vec4(u_ViewOrigin + var_View"
-"Dir * depth * 0.99, 1.0);\r\n\t\r\n\tvec4 shadowpos = u_ShadowMvp * biasPos"
-";\r\n\t\r\n#if defined(USE_SHADOW_CASCADE)\r\n\tconst float fadeTo = 0.5;\r"
-"\n\tresult = fadeTo;\r\n#else\r\n\tresult = 0.0;\r\n#endif\r\n\r\n\tif (all"
-"(lessThanEqual(abs(shadowpos.xyz), vec3(abs(shadowpos.w)))))\r\n\t{\r\n\t\t"
-"shadowpos.xyz = shadowpos.xyz / shadowpos.w * 0.5 + 0.5;\r\n\t\tresult = PC"
-"F(u_ShadowMap, shadowpos.xy, shadowpos.z);\r\n\t}\r\n#if defined(USE_SHADOW"
-"_CASCADE)\r\n\telse\r\n\t{\r\n\t\tshadowpos = u_ShadowMvp2 * biasPos;\r\n\r"
-"\n\t\tif (all(lessThanEqual(abs(shadowpos.xyz), vec3(abs(shadowpos.w)))))\r"
-"\n\t\t{\r\n\t\t\tshadowpos.xyz = shadowpos.xyz / shadowpos.w * 0.5 + 0.5;\r"
-"\n\t\t\tresult = PCF(u_ShadowMap2, shadowpos.xy, shadowpos.z);\r\n\t\t}\r\n"
-"\t\telse\r\n\t\t{\r\n\t\t\tshadowpos = u_ShadowMvp3 * biasPos;\r\n\r\n\t\t"
-"\tif (all(lessThanEqual(abs(shadowpos.xyz), vec3(abs(shadowpos.w)))))\r\n\t"
-"\t\t{\r\n\t\t\t\tshadowpos.xyz = shadowpos.xyz / shadowpos.w * 0.5 + 0.5;\r"
-"\n\t\t\t\tresult = PCF(u_ShadowMap3, shadowpos.xy, shadowpos.z);\r\n\r\n\t"
-"\t\t\tfloat fade = clamp(sampleZ / r_shadowCascadeZFar * 10.0 - 9.0, 0.0, 1"
-".0);\r\n\t\t\t\tresult = mix(result, fadeTo, fade);\r\n\t\t\t}\r\n\t\t}\r\n"
-"\t}\r\n#endif\r\n\t\t\r\n\tgl_FragColor = vec4(vec3(result), 1.0);\r\n}\r\n";
-
-static const char *fallbackSsaoShader_vp =
-"attribute vec4 attr_Position;\r\nattribute vec4 attr_TexCoord0;\r\n\r\nvary"
-"ing vec2   var_ScreenTex;\r\n\r\nvoid main()\r\n{\r\n\tgl_Position = attr_P"
-"osition;\r\n\tvar_ScreenTex = attr_TexCoord0.xy;\r\n\t//vec2 screenCoords ="
-" gl_Position.xy / gl_Position.w;\r\n\t//var_ScreenTex = screenCoords * 0.5 "
-"+ 0.5;\r\n}\r\n";
-
-static const char *fallbackSsaoShader_fp =
-"uniform sampler2D u_ScreenDepthMap;\r\n\r\nuniform vec4   u_ViewInfo; // zf"
-"ar / znear, zfar\r\n\r\nvarying vec2   var_ScreenTex;\r\n\r\nvec2 poissonDi"
-"sc[9] = vec2[9](\r\nvec2(-0.7055767, 0.196515),    vec2(0.3524343, -0.77913"
-"86),\r\nvec2(0.2391056, 0.9189604),    vec2(-0.07580382, -0.09224417),\r\nv"
-"ec2(0.5784913, -0.002528916), vec2(0.192888, 0.4064181),\r\nvec2(-0.6335801"
-", -0.5247476),  vec2(-0.5579782, 0.7491854),\r\nvec2(0.7320465, 0.6317794)"
-"\r\n);\r\n\r\n// Input: It uses texture coords as the random number seed.\r"
-"\n// Output: Random number: [0,1), that is between 0.0 and 0.999999... incl"
-"usive.\r\n// Author: Michael Pohoreski\r\n// Copyright: Copyleft 2012 :-)\r"
-"\n// Source: http://stackoverflow.com/questions/5149544/can-i-generate-a-ra"
-"ndom-number-inside-a-pixel-shader\r\n\r\nfloat random( const vec2 p )\r\n{"
-"\r\n  // We need irrationals for pseudo randomness.\r\n  // Most (all?) kno"
-"wn transcendental numbers will (generally) work.\r\n  const vec2 r = vec2("
-"\r\n    23.1406926327792690,  // e^pi (Gelfond's constant)\r\n     2.665144"
-"1426902251); // 2^sqrt(2) (Gelfond-Schneider constant)\r\n  //return fract("
-" cos( mod( 123456789., 1e-7 + 256. * dot(p,r) ) ) );\r\n  return mod( 12345"
-"6789., 1e-7 + 256. * dot(p,r) );  \r\n}\r\n\r\nmat2 randomRotation( const v"
-"ec2 p )\r\n{\r\n\tfloat r = random(p);\r\n\tfloat sinr = sin(r);\r\n\tfloat"
-" cosr = cos(r);\r\n\treturn mat2(cosr, sinr, -sinr, cosr);\r\n}\r\n\r\nfloa"
-"t getLinearDepth(sampler2D depthMap, const vec2 tex, const float zFarDivZNe"
-"ar)\r\n{\r\n\t\tfloat sampleZDivW = texture2D(depthMap, tex).r;\r\n\t\tretu"
-"rn 1.0 / mix(zFarDivZNear, 1.0, sampleZDivW);\r\n}\r\n\r\nfloat ambientOccl"
-"usion(sampler2D depthMap, const vec2 tex, const float zFarDivZNear, const f"
-"loat zFar)\r\n{\r\n\tfloat result = 0;\r\n\r\n\tfloat sampleZ = zFar * getL"
-"inearDepth(depthMap, tex, zFarDivZNear);\r\n\r\n\tvec2 expectedSlope = vec2"
-"(dFdx(sampleZ), dFdy(sampleZ)) / vec2(dFdx(tex.x), dFdy(tex.y));\r\n\t\r\n"
-"\tif (length(expectedSlope) > 5000.0)\r\n\t\treturn 1.0;\r\n\t\r\n\tvec2 of"
-"fsetScale = vec2(3.0 / sampleZ);\r\n\t\r\n\tmat2 rmat = randomRotation(tex)"
-";\r\n\t\t\r\n\tint i;\r\n\tfor (i = 0; i < 3; i++)\r\n\t{\r\n\t\tvec2 offse"
-"t = rmat * poissonDisc[i] * offsetScale;\r\n\t\tfloat sampleZ2 = zFar * get"
-"LinearDepth(depthMap, tex + offset, zFarDivZNear);\r\n\r\n\t\tif (abs(sampl"
-"eZ - sampleZ2) > 20.0)\r\n\t\t\tresult += 1.0;\r\n\t\telse\r\n\t\t{\r\n\t\t"
-"\tfloat expectedZ = sampleZ + dot(expectedSlope, offset);\r\n\t\t\tresult +"
-"= step(expectedZ - 1.0, sampleZ2);\r\n\t\t}\r\n\t}\r\n\t\r\n\tresult *= 0.3"
-"3333;\r\n\t\r\n\treturn result;\r\n}\r\n\r\nvoid main()\r\n{\r\n\tfloat res"
-"ult = ambientOcclusion(u_ScreenDepthMap, var_ScreenTex, u_ViewInfo.x, u_Vie"
-"wInfo.y);\r\n\t\t\t\r\n\tgl_FragColor = vec4(vec3(result), 1.0);\r\n}\r\n";
-
-static const char *fallbackDepthBlurShader_vp =
-"attribute vec4 attr_Position;\r\nattribute vec4 attr_TexCoord0;\r\n\r\nvary"
-"ing vec2   var_ScreenTex;\r\n\r\nvoid main()\r\n{\r\n\tgl_Position = attr_P"
-"osition;\r\n\tvar_ScreenTex = attr_TexCoord0.xy;\r\n\t//vec2 screenCoords ="
-" gl_Position.xy / gl_Position.w;\r\n\t//var_ScreenTex = screenCoords * 0.5 "
-"+ 0.5;\r\n}\r\n";
-
-static const char *fallbackDepthBlurShader_fp =
-"uniform sampler2D u_ScreenImageMap;\r\nuniform sampler2D u_ScreenDepthMap;"
-"\r\n\r\nuniform vec4   u_ViewInfo; // zfar / znear, zfar\r\nvarying vec2   "
-"var_ScreenTex;\r\n\r\n//float gauss[5] = float[5](0.30, 0.23, 0.097, 0.024,"
-" 0.0033);\r\nfloat gauss[4] = float[4](0.40, 0.24, 0.054, 0.0044);\r\n//flo"
-"at gauss[3] = float[3](0.60, 0.19, 0.0066);\r\n#define GAUSS_SIZE 4\r\n\r\n"
-"float getLinearDepth(sampler2D depthMap, const vec2 tex, const float zFarDi"
-"vZNear)\r\n{\r\n\t\tfloat sampleZDivW = texture2D(depthMap, tex).r;\r\n\t\t"
-"return 1.0 / mix(zFarDivZNear, 1.0, sampleZDivW);\r\n}\r\n\r\nvec4 depthGau"
-"ssian1D(sampler2D imageMap, sampler2D depthMap, vec2 tex, float zFarDivZNea"
-"r, float zFar)\r\n{\r\n\tfloat scale = 1.0 / 256.0;\r\n\r\n#if defined(USE_"
-"HORIZONTAL_BLUR)\r\n    vec2 direction = vec2(1.0, 0.0) * scale;\r\n#else /"
-"/ if defined(USE_VERTICAL_BLUR)\r\n\tvec2 direction = vec2(0.0, 1.0) * scal"
-"e;\r\n#endif\r\n\t\r\n\tfloat depthCenter = zFar * getLinearDepth(depthMap,"
-" tex, zFarDivZNear);\r\n\tvec2 centerSlope = vec2(dFdx(depthCenter), dFdy(d"
-"epthCenter)) / vec2(dFdx(tex.x), dFdy(tex.y));\r\n\t\t\r\n\tvec4 result = t"
-"exture2D(imageMap, tex) * gauss[0];\r\n\tfloat total = gauss[0];\r\n\r\n\ti"
-"nt i, j;\r\n\tfor (i = 0; i < 2; i++)\r\n\t{\r\n\t\tfor (j = 1; j < GAUSS_S"
-"IZE; j++)\r\n\t\t{\r\n\t\t\tvec2 offset = direction * j;\r\n\t\t\tfloat dep"
-"thSample = zFar * getLinearDepth(depthMap, tex + offset, zFarDivZNear);\r\n"
-"\t\t\tfloat depthExpected = depthCenter + dot(centerSlope, offset);\r\n\t\t"
-"\tif(abs(depthSample - depthExpected) < 5.0)\r\n\t\t\t{\r\n\t\t\t\tresult +"
-"= texture2D(imageMap, tex + offset) * gauss[j];\r\n\t\t\t\ttotal += gauss[j"
-"];\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tdirection = -direction;\r\n\t}\t\r\n"
-"\t\t\r\n\treturn result / total;\r\n}\r\n\r\nvoid main()\r\n{\t\t\r\n\tgl_F"
-"ragColor = depthGaussian1D(u_ScreenImageMap, u_ScreenDepthMap, var_ScreenTe"
-"x, u_ViewInfo.x, u_ViewInfo.y);\r\n}\r\n";
-
-
 static void GLSL_PrintInfoLog(GLhandleARB object, qboolean developerOnly)
 {
 	char           *msg;
@@ -1109,80 +285,8 @@
 	return 1;
 }
 
-
-static void GLSL_DumpText(const char *shaderText, int size, const char *name, GLenum shaderType)
-{
-	int i, l, inc;
-	ri.Printf(PRINT_ALL, "static const char *fallback%sShader_%s =\n\"", name, shaderType == GL_VERTEX_SHADER_ARB ? "vp" : "fp");
-	l = 0;
-
-	for (i = 0; i < size; i++)
-	{
-		switch (shaderText[i])
-		{
-			case '\a':
-			case '\b':
-			case '\f':
-			case '\n':
-			case '\r':
-			case '\t':
-			case '\v':
-			case '"':
-			case '\\':
-				inc = 2;
-				break;
-			default:
-				inc = 1;
-				break;
-		}
-
-		l += inc;
-
-		if (l >= 76)
-		{
-			ri.Printf(PRINT_ALL, "\"\n\"");
-			l = inc;
-		}
-
-		switch (shaderText[i])
-		{
-			case '\a':
-				ri.Printf(PRINT_ALL, "\\a");
-				break;
-			case '\b':
-				ri.Printf(PRINT_ALL, "\\b");
-				break;
-			case '\f':
-				ri.Printf(PRINT_ALL, "\\f");
-				break;
-			case '\n':
-				ri.Printf(PRINT_ALL, "\\n");
-				break;
-			case '\r':
-				ri.Printf(PRINT_ALL, "\\r");
-				break;
-			case '\t':
-				ri.Printf(PRINT_ALL, "\\t");
-				break;
-			case '\v':
-				ri.Printf(PRINT_ALL, "\\v");
-				break;
-			case '"':
-				ri.Printf(PRINT_ALL, "\\\"");
-				break;
-			case '\\':
-				ri.Printf(PRINT_ALL, "\\\\");
-				break;
-			default:
-				ri.Printf(PRINT_ALL, "%c", shaderText[i]);
-				break;
-		}
-	}
-	ri.Printf(PRINT_ALL, "\";\n\n");
-}
-
 static int GLSL_LoadGPUShaderText(const char *name, const char *fallback,
-	GLenum shaderType, char *dest, int destSize, qboolean dump)
+	GLenum shaderType, char *dest, int destSize)
 {
 	char            filename[MAX_QPATH];
 	GLcharARB      *buffer = NULL;
@@ -1220,9 +324,6 @@
 		shaderText = buffer;
 	}
 
-	if (dump)
-		GLSL_DumpText(shaderText, size, name, shaderType);
-
 	if (size > destSize)
 	{
 		result = 0;
@@ -1422,7 +523,7 @@
 		postHeader = &vpCode[0];
 	}
 
-	if (!GLSL_LoadGPUShaderText(name, fallback_vp, GL_VERTEX_SHADER_ARB, postHeader, size, qfalse))
+	if (!GLSL_LoadGPUShaderText(name, fallback_vp, GL_VERTEX_SHADER_ARB, postHeader, size))
 	{
 		return 0;
 	}
@@ -1441,7 +542,7 @@
 			postHeader = &fpCode[0];
 		}
 
-		if (!GLSL_LoadGPUShaderText(name, fallback_fp, GL_FRAGMENT_SHADER_ARB, postHeader, size, qfalse))
+		if (!GLSL_LoadGPUShaderText(name, fallback_fp, GL_FRAGMENT_SHADER_ARB, postHeader, size))
 		{
 			return 0;
 		}
@@ -1773,7 +874,7 @@
 		if (r_hdr->integer && !(glRefConfig.textureFloat && glRefConfig.halfFloatPixel))
 			Q_strcat(extradefines, 1024, "#define RGBE_LIGHTMAP\n");
 
-		if (!GLSL_InitGPUShader(&tr.genericShader[i], "generic", attribs, qtrue, extradefines, qtrue, fallbackGenericShader_vp, fallbackGenericShader_fp, GENERIC_UNIFORM_COUNT))
+		if (!GLSL_InitGPUShader(&tr.genericShader[i], "generic", attribs, qtrue, extradefines, qtrue, fallbackShader_generic_vp, fallbackShader_generic_fp, GENERIC_UNIFORM_COUNT))
 		{
 			ri.Error(ERR_FATAL, "Could not load generic shader!\n");
 		}
@@ -1847,7 +948,7 @@
 
 	attribs = ATTR_POSITION | ATTR_TEXCOORD;
 
-	if (!GLSL_InitGPUShader(&tr.textureColorShader, "texturecolor", attribs, qtrue, NULL, qfalse, fallbackTextureColorShader_vp, fallbackTextureColorShader_fp, TEXTURECOLOR_UNIFORM_COUNT))
+	if (!GLSL_InitGPUShader(&tr.textureColorShader, "texturecolor", attribs, qtrue, NULL, qfalse, fallbackShader_texturecolor_vp, fallbackShader_texturecolor_fp, TEXTURECOLOR_UNIFORM_COUNT))
 	{
 		ri.Error(ERR_FATAL, "Could not load texturecolor shader!\n");
 	}
@@ -1877,7 +978,7 @@
 		if (i & FOGDEF_USE_VERTEX_ANIMATION)
 			Q_strcat(extradefines, 1024, "#define USE_VERTEX_ANIMATION\n");
 
-		if (!GLSL_InitGPUShader(&tr.fogShader[i], "fogpass", attribs, qtrue, extradefines, qtrue, fallbackFogPassShader_vp, fallbackFogPassShader_fp, FOGPASS_UNIFORM_COUNT))
+		if (!GLSL_InitGPUShader(&tr.fogShader[i], "fogpass", attribs, qtrue, extradefines, qtrue, fallbackShader_fogpass_vp, fallbackShader_fogpass_fp, FOGPASS_UNIFORM_COUNT))
 		{
 			ri.Error(ERR_FATAL, "Could not load fogpass shader!\n");
 		}
@@ -1909,7 +1010,7 @@
 			Q_strcat(extradefines, 1024, "#define USE_DEFORM_VERTEXES\n");
 		}
 
-		if (!GLSL_InitGPUShader(&tr.dlightShader[i], "dlight", attribs, qtrue, extradefines, qtrue, fallbackDlightShader_vp, fallbackDlightShader_fp, DLIGHT_UNIFORM_COUNT))
+		if (!GLSL_InitGPUShader(&tr.dlightShader[i], "dlight", attribs, qtrue, extradefines, qtrue, fallbackShader_dlight_vp, fallbackShader_dlight_fp, DLIGHT_UNIFORM_COUNT))
 		{
 			ri.Error(ERR_FATAL, "Could not load dlight shader!\n");
 		}
@@ -2072,7 +1173,7 @@
 #endif
 		}
 
-		if (!GLSL_InitGPUShader(&tr.lightallShader[i], "lightall", attribs, qtrue, extradefines, qtrue, fallbackLightallShader_vp, fallbackLightallShader_fp, GENERIC_UNIFORM_COUNT))
+		if (!GLSL_InitGPUShader(&tr.lightallShader[i], "lightall", attribs, qtrue, extradefines, qtrue, fallbackShader_lightall_vp, fallbackShader_lightall_fp, GENERIC_UNIFORM_COUNT))
 		{
 			ri.Error(ERR_FATAL, "Could not load lightall shader!\n");
 		}
@@ -2125,7 +1226,7 @@
 
 	extradefines[0] = '\0';
 
-	if (!GLSL_InitGPUShader(&tr.shadowmapShader, "shadowfill", attribs, qtrue, extradefines, qtrue, fallbackShadowfillShader_vp, fallbackShadowfillShader_fp, GENERIC_UNIFORM_COUNT))
+	if (!GLSL_InitGPUShader(&tr.shadowmapShader, "shadowfill", attribs, qtrue, extradefines, qtrue, fallbackShader_shadowfill_vp, fallbackShader_shadowfill_fp, GENERIC_UNIFORM_COUNT))
 	{
 		ri.Error(ERR_FATAL, "Could not load shadowfill shader!\n");
 	}
@@ -2150,7 +1251,7 @@
 
 	Q_strcat(extradefines, 1024, "#define USE_PCF\n#define USE_DISCARD\n");
 
-	if (!GLSL_InitGPUShader(&tr.pshadowShader, "pshadow", attribs, qtrue, extradefines, qtrue, fallbackPshadowShader_vp, fallbackPshadowShader_fp, PSHADOW_UNIFORM_COUNT))
+	if (!GLSL_InitGPUShader(&tr.pshadowShader, "pshadow", attribs, qtrue, extradefines, qtrue, fallbackShader_pshadow_vp, fallbackShader_pshadow_fp, PSHADOW_UNIFORM_COUNT))
 	{
 		ri.Error(ERR_FATAL, "Could not load pshadow shader!\n");
 	}
@@ -2176,7 +1277,7 @@
 	attribs = ATTR_POSITION | ATTR_TEXCOORD;
 	extradefines[0] = '\0';
 
-	if (!GLSL_InitGPUShader(&tr.down4xShader, "down4x", attribs, qtrue, extradefines, qtrue, fallbackDown4xShader_vp, fallbackDown4xShader_fp, TEXTURECOLOR_UNIFORM_COUNT))
+	if (!GLSL_InitGPUShader(&tr.down4xShader, "down4x", attribs, qtrue, extradefines, qtrue, fallbackShader_down4x_vp, fallbackShader_down4x_fp, TEXTURECOLOR_UNIFORM_COUNT))
 	{
 		ri.Error(ERR_FATAL, "Could not load down4x shader!\n");
 	}
@@ -2200,7 +1301,7 @@
 	attribs = ATTR_POSITION | ATTR_TEXCOORD;
 	extradefines[0] = '\0';
 
-	if (!GLSL_InitGPUShader(&tr.bokehShader, "bokeh", attribs, qtrue, extradefines, qtrue, fallbackBokehShader_vp, fallbackBokehShader_fp, TEXTURECOLOR_UNIFORM_COUNT))
+	if (!GLSL_InitGPUShader(&tr.bokehShader, "bokeh", attribs, qtrue, extradefines, qtrue, fallbackShader_bokeh_vp, fallbackShader_bokeh_fp, TEXTURECOLOR_UNIFORM_COUNT))
 	{
 		ri.Error(ERR_FATAL, "Could not load bokeh shader!\n");
 	}
@@ -2225,7 +1326,7 @@
 	attribs = ATTR_POSITION | ATTR_TEXCOORD;
 	extradefines[0] = '\0';
 
-	if (!GLSL_InitGPUShader(&tr.tonemapShader, "tonemap", attribs, qtrue, extradefines, qtrue, fallbackToneMapShader_vp, fallbackToneMapShader_fp, TEXTURECOLOR_UNIFORM_COUNT))
+	if (!GLSL_InitGPUShader(&tr.tonemapShader, "tonemap", attribs, qtrue, extradefines, qtrue, fallbackShader_tonemap_vp, fallbackShader_tonemap_fp, TEXTURECOLOR_UNIFORM_COUNT))
 	{
 		ri.Error(ERR_FATAL, "Could not load tonemap shader!\n");
 	}
@@ -2258,7 +1359,7 @@
 		if (!i)
 			Q_strcat(extradefines, 1024, "#define FIRST_PASS\n");
 
-		if (!GLSL_InitGPUShader(&tr.calclevels4xShader[i], "calclevels4x", attribs, qtrue, extradefines, qtrue, fallbackCalcLevels4xShader_vp, fallbackCalcLevels4xShader_fp, TEXTURECOLOR_UNIFORM_COUNT))
+		if (!GLSL_InitGPUShader(&tr.calclevels4xShader[i], "calclevels4x", attribs, qtrue, extradefines, qtrue, fallbackShader_calclevels4x_vp, fallbackShader_calclevels4x_fp, TEXTURECOLOR_UNIFORM_COUNT))
 		{
 			ri.Error(ERR_FATAL, "Could not load calclevels4x shader!\n");
 		}
@@ -2296,7 +1397,7 @@
 	Q_strcat(extradefines, 1024, va("#define r_shadowCascadeZFar %f\n", r_shadowCascadeZFar->value));
 
 
-	if (!GLSL_InitGPUShader(&tr.shadowmaskShader, "shadowmask", attribs, qtrue, extradefines, qtrue, fallbackShadowmaskShader_vp, fallbackShadowmaskShader_fp, SHADOWMASK_UNIFORM_COUNT))
+	if (!GLSL_InitGPUShader(&tr.shadowmaskShader, "shadowmask", attribs, qtrue, extradefines, qtrue, fallbackShader_shadowmask_vp, fallbackShader_shadowmask_fp, SHADOWMASK_UNIFORM_COUNT))
 	{
 		ri.Error(ERR_FATAL, "Could not load shadowmask shader!\n");
 	}
@@ -2332,7 +1433,7 @@
 	attribs = ATTR_POSITION | ATTR_TEXCOORD;
 	extradefines[0] = '\0';
 
-	if (!GLSL_InitGPUShader(&tr.ssaoShader, "ssao", attribs, qtrue, extradefines, qtrue, fallbackSsaoShader_vp, fallbackSsaoShader_fp, SSAO_UNIFORM_COUNT))
+	if (!GLSL_InitGPUShader(&tr.ssaoShader, "ssao", attribs, qtrue, extradefines, qtrue, fallbackShader_ssao_vp, fallbackShader_ssao_fp, SSAO_UNIFORM_COUNT))
 	{
 		ri.Error(ERR_FATAL, "Could not load ssao shader!\n");
 	}
@@ -2363,7 +1464,7 @@
 			Q_strcat(extradefines, 1024, "#define USE_HORIZONTAL_BLUR\n");
 
 
-		if (!GLSL_InitGPUShader(&tr.depthBlurShader[i], "depthBlur", attribs, qtrue, extradefines, qtrue, fallbackDepthBlurShader_vp, fallbackDepthBlurShader_fp, DEPTHBLUR_UNIFORM_COUNT))
+		if (!GLSL_InitGPUShader(&tr.depthBlurShader[i], "depthBlur", attribs, qtrue, extradefines, qtrue, fallbackShader_depthblur_vp, fallbackShader_depthblur_fp, DEPTHBLUR_UNIFORM_COUNT))
 		{
 			ri.Error(ERR_FATAL, "Could not load depthBlur shader!\n");
 		}
@@ -2391,52 +1492,6 @@
 	ri.Printf(PRINT_ALL, "loaded %i GLSL shaders (%i gen %i light %i etc) in %5.2f seconds\n", 
 		numGenShaders + numLightShaders + numEtcShaders, numGenShaders, numLightShaders, 
 		numEtcShaders, (endTime - startTime) / 1000.0);
-
-	if (0)
-	{
-		GLSL_LoadGPUShaderText("Generic", NULL, GL_VERTEX_SHADER_ARB,   NULL, 0, qtrue);
-		GLSL_LoadGPUShaderText("Generic", NULL, GL_FRAGMENT_SHADER_ARB, NULL, 0, qtrue);
-
-		GLSL_LoadGPUShaderText("TextureColor", NULL, GL_VERTEX_SHADER_ARB,   NULL, 0, qtrue);
-		GLSL_LoadGPUShaderText("TextureColor", NULL, GL_FRAGMENT_SHADER_ARB, NULL, 0, qtrue);
-
-		GLSL_LoadGPUShaderText("FogPass", NULL, GL_VERTEX_SHADER_ARB,   NULL, 0, qtrue);
-		GLSL_LoadGPUShaderText("FogPass", NULL, GL_FRAGMENT_SHADER_ARB, NULL, 0, qtrue);
-		
-		GLSL_LoadGPUShaderText("Dlight", NULL, GL_VERTEX_SHADER_ARB,   NULL, 0, qtrue);
-		GLSL_LoadGPUShaderText("Dlight", NULL, GL_FRAGMENT_SHADER_ARB, NULL, 0, qtrue);
-
-		GLSL_LoadGPUShaderText("Lightall", NULL, GL_VERTEX_SHADER_ARB,   NULL, 0, qtrue);
-		GLSL_LoadGPUShaderText("Lightall", NULL, GL_FRAGMENT_SHADER_ARB, NULL, 0, qtrue);
-		
-		GLSL_LoadGPUShaderText("Shadowfill", NULL, GL_VERTEX_SHADER_ARB,   NULL, 0, qtrue);
-		GLSL_LoadGPUShaderText("Shadowfill", NULL, GL_FRAGMENT_SHADER_ARB, NULL, 0, qtrue);
-		
-		GLSL_LoadGPUShaderText("Pshadow", NULL, GL_VERTEX_SHADER_ARB,   NULL, 0, qtrue);
-		GLSL_LoadGPUShaderText("Pshadow", NULL, GL_FRAGMENT_SHADER_ARB, NULL, 0, qtrue);
-
-		GLSL_LoadGPUShaderText("Down4x", NULL, GL_VERTEX_SHADER_ARB,   NULL, 0, qtrue);
-		GLSL_LoadGPUShaderText("Down4x", NULL, GL_FRAGMENT_SHADER_ARB, NULL, 0, qtrue);
-
-		GLSL_LoadGPUShaderText("Bokeh", NULL, GL_VERTEX_SHADER_ARB,   NULL, 0, qtrue);
-		GLSL_LoadGPUShaderText("Bokeh", NULL, GL_FRAGMENT_SHADER_ARB, NULL, 0, qtrue);
-
-		GLSL_LoadGPUShaderText("ToneMap", NULL, GL_VERTEX_SHADER_ARB,   NULL, 0, qtrue);
-		GLSL_LoadGPUShaderText("ToneMap", NULL, GL_FRAGMENT_SHADER_ARB, NULL, 0, qtrue);
-
-		GLSL_LoadGPUShaderText("CalcLevels4x", NULL, GL_VERTEX_SHADER_ARB,   NULL, 0, qtrue);
-		GLSL_LoadGPUShaderText("CalcLevels4x", NULL, GL_FRAGMENT_SHADER_ARB, NULL, 0, qtrue);
-
-		GLSL_LoadGPUShaderText("Shadowmask", NULL, GL_VERTEX_SHADER_ARB,   NULL, 0, qtrue);
-		GLSL_LoadGPUShaderText("Shadowmask", NULL, GL_FRAGMENT_SHADER_ARB, NULL, 0, qtrue);
-
-		GLSL_LoadGPUShaderText("Ssao", NULL, GL_VERTEX_SHADER_ARB,   NULL, 0, qtrue);
-		GLSL_LoadGPUShaderText("Ssao", NULL, GL_FRAGMENT_SHADER_ARB, NULL, 0, qtrue);
-
-		GLSL_LoadGPUShaderText("DepthBlur", NULL, GL_VERTEX_SHADER_ARB,   NULL, 0, qtrue);
-		GLSL_LoadGPUShaderText("DepthBlur", NULL, GL_FRAGMENT_SHADER_ARB, NULL, 0, qtrue);
-	}
-
 }
 
 void GLSL_ShutdownGPUShaders(void)
Index: code/rend2/glsl/dlight_vp.glsl
===================================================================
--- code/rend2/glsl/dlight_vp.glsl	(revision 0)
+++ code/rend2/glsl/dlight_vp.glsl	(revision 334)
@@ -0,0 +1,92 @@
+attribute vec4 attr_Position;
+attribute vec4 attr_TexCoord0;
+attribute vec3 attr_Normal;
+
+uniform vec4   u_DlightInfo;
+
+#if defined(USE_DEFORM_VERTEXES)
+uniform int    u_DeformGen;
+uniform float  u_DeformParams[5];
+uniform float  u_Time;
+#endif
+
+uniform vec4   u_Color;
+uniform mat4   u_ModelViewProjectionMatrix;
+
+varying vec2   var_Tex1;
+varying vec4   var_Color;
+
+#if defined(USE_DEFORM_VERTEXES)
+vec3 DeformPosition(const vec3 pos, const vec3 normal, const vec2 st)
+{
+	if (u_DeformGen == 0)
+	{
+		return pos;
+	}
+
+	float base =      u_DeformParams[0];
+	float amplitude = u_DeformParams[1];
+	float phase =     u_DeformParams[2];
+	float frequency = u_DeformParams[3];
+	float spread =    u_DeformParams[4];
+
+	if (u_DeformGen == DGEN_BULGE)
+	{
+		phase *= M_PI * 0.25 * st.x;
+	}
+	else // if (u_DeformGen <= DGEN_WAVE_INVERSE_SAWTOOTH)
+	{
+		phase += dot(pos.xyz, vec3(spread));
+	}
+
+	float value = phase + (u_Time * frequency);
+	float func;
+
+	if (u_DeformGen == DGEN_WAVE_SIN)
+	{
+		func = sin(value * 2.0 * M_PI);
+	}
+	else if (u_DeformGen == DGEN_WAVE_SQUARE)
+	{
+		func = sign(sin(value * 2.0 * M_PI));
+	}
+	else if (u_DeformGen == DGEN_WAVE_TRIANGLE)
+	{
+		func = abs(fract(value + 0.75) - 0.5) * 4.0 - 1.0;
+	}
+	else if (u_DeformGen == DGEN_WAVE_SAWTOOTH)
+	{
+		func = fract(value);
+	}
+	else if (u_DeformGen == DGEN_WAVE_INVERSE_SAWTOOTH)
+	{
+		func = (1.0 - fract(value));
+	}
+	else if (u_DeformGen == DGEN_BULGE)
+	{
+		func = sin(value);
+	}
+
+	return pos + normal * (base + func * amplitude);
+}
+#endif
+
+void main()
+{
+	vec4 position = attr_Position;
+	vec3 normal = attr_Normal;
+
+#if defined(USE_DEFORM_VERTEXES)
+	position.xyz = DeformPosition(position.xyz, normal, attr_TexCoord0.st);
+#endif
+
+	gl_Position = u_ModelViewProjectionMatrix * position;
+		
+	vec3 dist = u_DlightInfo.xyz - position.xyz;	
+
+	var_Tex1 = dist.xy * u_DlightInfo.a + vec2(0.5);
+	float dlightmod = step(0.0, dot(dist, normal));
+	dlightmod *= clamp(2.0 * (1.0 - abs(dist.z) * u_DlightInfo.a), 0.0, 1.0);
+	
+	var_Color = u_Color * dlightmod;
+}
Index: code/rend2/glsl/generic_vp.glsl
===================================================================
--- code/rend2/glsl/generic_vp.glsl	(revision 0)
+++ code/rend2/glsl/generic_vp.glsl	(revision 334)
@@ -0,0 +1,251 @@
+attribute vec4 attr_Position;
+attribute vec3 attr_Normal;
+
+#if defined(USE_VERTEX_ANIMATION)
+attribute vec4 attr_Position2;
+attribute vec3 attr_Normal2;
+#endif
+
+attribute vec4 attr_Color;
+attribute vec4 attr_TexCoord0;
+
+#if defined(USE_LIGHTMAP) || defined(USE_TCGEN)
+attribute vec4 attr_TexCoord1;
+#endif
+
+uniform vec4   u_DiffuseTexMatrix;
+uniform vec4   u_DiffuseTexOffTurb;
+
+#if defined(USE_TCGEN) || defined(USE_RGBAGEN)
+uniform vec3   u_ViewOrigin;
+#endif
+
+#if defined(USE_TCGEN)
+uniform int    u_TCGen0;
+uniform vec3   u_TCGen0Vector0;
+uniform vec3   u_TCGen0Vector1;
+#endif
+
+#if defined(USE_FOG)
+uniform vec4   u_FogDistance;
+uniform vec4   u_FogDepth;
+uniform float  u_FogEyeT;
+uniform vec4   u_FogColorMask;
+#endif
+
+#if defined(USE_DEFORM_VERTEXES)
+uniform int    u_DeformGen;
+uniform float  u_DeformParams[5];
+uniform float  u_Time;
+#endif
+
+uniform mat4   u_ModelViewProjectionMatrix;
+uniform vec4   u_BaseColor;
+uniform vec4   u_VertColor;
+
+#if defined(USE_RGBAGEN)
+uniform int    u_ColorGen;
+uniform int    u_AlphaGen;
+uniform vec3   u_AmbientLight;
+uniform vec3   u_DirectedLight;
+uniform vec4   u_LightOrigin;
+uniform float  u_PortalRange;
+#endif
+
+#if defined(USE_VERTEX_ANIMATION)
+uniform float  u_VertexLerp;
+#endif
+
+varying vec2   var_DiffuseTex;
+#if defined(USE_LIGHTMAP)
+varying vec2   var_LightTex;
+#endif
+varying vec4   var_Color;
+
+#if defined(USE_DEFORM_VERTEXES)
+vec3 DeformPosition(const vec3 pos, const vec3 normal, const vec2 st)
+{
+	float base =      u_DeformParams[0];
+	float amplitude = u_DeformParams[1];
+	float phase =     u_DeformParams[2];
+	float frequency = u_DeformParams[3];
+	float spread =    u_DeformParams[4];
+
+	if (u_DeformGen == DGEN_BULGE)
+	{
+		phase *= M_PI * 0.25 * st.x;
+	}
+	else // if (u_DeformGen <= DGEN_WAVE_INVERSE_SAWTOOTH)
+	{
+		phase += dot(pos.xyz, vec3(spread));
+	}
+
+	float value = phase + (u_Time * frequency);
+	float func;
+
+	if (u_DeformGen == DGEN_WAVE_SIN)
+	{
+		func = sin(value * 2.0 * M_PI);
+	}
+	else if (u_DeformGen == DGEN_WAVE_SQUARE)
+	{
+		func = sign(sin(value * 2.0 * M_PI));
+	}
+	else if (u_DeformGen == DGEN_WAVE_TRIANGLE)
+	{
+		func = abs(fract(value + 0.75) - 0.5) * 4.0 - 1.0;
+	}
+	else if (u_DeformGen == DGEN_WAVE_SAWTOOTH)
+	{
+		func = fract(value);
+	}
+	else if (u_DeformGen == DGEN_WAVE_INVERSE_SAWTOOTH)
+	{
+		func = (1.0 - fract(value));
+	}
+	else if (u_DeformGen == DGEN_BULGE)
+	{
+		func = sin(value);
+	}
+
+	return pos + normal * (base + func * amplitude);
+}
+#endif
+
+#if defined(USE_TCGEN)
+vec2 GenTexCoords(int TCGen, vec3 position, vec3 normal, vec3 TCGenVector0, vec3 TCGenVector1)
+{
+	vec2 tex = attr_TexCoord0.st;
+
+	if (TCGen == TCGEN_LIGHTMAP)
+	{
+		tex = attr_TexCoord1.st;
+	}
+	else if (TCGen == TCGEN_ENVIRONMENT_MAPPED)
+	{
+		vec3 viewer = normalize(u_ViewOrigin - position);
+		tex = -reflect(viewer, normal).yz * vec2(0.5, -0.5) + 0.5;
+	}
+	else if (TCGen == TCGEN_VECTOR)
+	{
+		tex = vec2(dot(position, TCGenVector0), dot(position, TCGenVector1));
+	}
+	
+	return tex;
+}
+#endif
+
+#if defined(USE_TCMOD)
+vec2 ModTexCoords(vec2 st, vec3 position, vec4 texMatrix, vec4 offTurb)
+{
+	float amplitude = offTurb.z;
+	float phase = offTurb.w;
+	vec2 st2 = vec2(dot(st, texMatrix.xz), dot(st, texMatrix.yw)) + offTurb.xy;
+
+	vec3 offsetPos = position / 1024.0;
+	offsetPos.x += offsetPos.z;
+	
+	vec2 texOffset = sin((offsetPos.xy + vec2(phase)) * 2.0 * M_PI);
+	
+	return st2 + texOffset * amplitude;	
+}
+#endif
+
+#if defined(USE_RGBAGEN)
+vec4 CalcColor(vec3 position, vec3 normal)
+{
+	vec4 color = u_VertColor * attr_Color + u_BaseColor;
+	
+	if (u_ColorGen == CGEN_LIGHTING_DIFFUSE)
+	{
+		float incoming = clamp(dot(normal, u_LightOrigin.xyz), 0.0, 1.0);
+
+		color.rgb = clamp(u_DirectedLight * incoming + u_AmbientLight, 0.0, 1.0);
+	}
+	
+	vec3 toView = u_ViewOrigin - position;
+	vec3 viewer = normalize(u_ViewOrigin - position);
+
+	if (u_AlphaGen == AGEN_LIGHTING_SPECULAR)
+	{
+		vec3 lightDir = normalize(vec3(-960.0, -1980.0, 96.0) - position.xyz);
+		vec3 halfangle = normalize(lightDir + viewer);
+		
+		color.a = pow(max(dot(normal, halfangle), 0.0), 8.0);
+	}
+	else if (u_AlphaGen == AGEN_PORTAL)
+	{
+		float alpha = length(toView) / u_PortalRange;
+
+		color.a = clamp(alpha, 0.0, 1.0);
+	}
+	else if (u_AlphaGen == AGEN_FRESNEL)
+	{
+		color.a = 0.10 + 0.90 * pow(1.0 - dot(normal, viewer), 5);
+	}
+	
+	return color;
+}
+#endif
+
+#if defined(USE_FOG)
+float CalcFog(vec4 position)
+{
+	float s = dot(position, u_FogDistance) * 8.0;
+	float t = dot(position, u_FogDepth);
+
+	if (t < 1.0)
+	{
+		t = step(step(0.0, -u_FogEyeT), t);
+	}
+	else
+	{
+		t /= t - min(u_FogEyeT, 0.0);
+	}
+
+	return s * t;
+}
+#endif
+
+void main()
+{
+#if defined(USE_VERTEX_ANIMATION)
+	vec4 position = mix(attr_Position, attr_Position2, u_VertexLerp);
+	vec3 normal = normalize(mix(attr_Normal, attr_Normal2, u_VertexLerp));
+#else
+	vec4 position = attr_Position;
+	vec3 normal = attr_Normal;
+#endif
+
+#if defined(USE_DEFORM_VERTEXES)
+	position.xyz = DeformPosition(position.xyz, normal, attr_TexCoord0.st);
+#endif
+
+	gl_Position = u_ModelViewProjectionMatrix * position;
+
+#if defined(USE_TCGEN)
+	vec2 tex = GenTexCoords(u_TCGen0, position.xyz, normal, u_TCGen0Vector0, u_TCGen0Vector1);
+#else
+	vec2 tex = attr_TexCoord0.st;
+#endif
+
+#if defined(USE_TCMOD)
+	var_DiffuseTex = ModTexCoords(tex, position.xyz, u_DiffuseTexMatrix, u_DiffuseTexOffTurb);
+#else
+    var_DiffuseTex = tex;
+#endif
+
+#if defined(USE_LIGHTMAP)
+	var_LightTex = attr_TexCoord1.st;
+#endif
+
+#if defined(USE_RGBAGEN)
+	var_Color = CalcColor(position.xyz, normal);
+#else
+	var_Color = u_VertColor * attr_Color + u_BaseColor;
+#endif
+
+#if defined(USE_FOG)
+	var_Color *= vec4(1.0) - u_FogColorMask * sqrt(clamp(CalcFog(position), 0.0, 1.0));
+#endif
+}
Index: code/rend2/glsl/shadowfill_fp.glsl
===================================================================
--- code/rend2/glsl/shadowfill_fp.glsl	(revision 0)
+++ code/rend2/glsl/shadowfill_fp.glsl	(revision 334)
@@ -0,0 +1,41 @@
+uniform vec4  u_LightOrigin;
+uniform float u_LightRadius;
+
+varying vec3  var_Position;
+
+void main()
+{
+#if defined(USE_DEPTH)
+	float depth = length(u_LightOrigin.xyz - var_Position) / u_LightRadius;
+ #if 0
+	// 32 bit precision
+	const vec4 bitSh = vec4( 256 * 256 * 256,   256 * 256,         256,           1);
+	const vec4 bitMsk = vec4(              0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0);
+	
+	vec4 comp;
+	comp = depth * bitSh;
+	comp.xyz = fract(comp.xyz);
+	comp -= comp.xxyz * bitMsk;
+	gl_FragColor = comp;
+ #endif
+
+ #if 1
+	// 24 bit precision
+	const vec3 bitSh = vec3( 256 * 256,         256,           1);
+	const vec3 bitMsk = vec3(        0, 1.0 / 256.0, 1.0 / 256.0);
+	
+	vec3 comp;
+	comp = depth * bitSh;
+	comp.xy = fract(comp.xy);
+	comp -= comp.xxy * bitMsk;
+	gl_FragColor = vec4(comp, 1.0);
+ #endif
+
+ #if 0
+	// 8 bit precision
+	gl_FragColor = vec4(depth, depth, depth, 1);
+ #endif
+#else
+	gl_FragColor = vec4(0, 0, 0, 1);
+#endif
+}
Index: code/rend2/glsl/texturecolor_fp.glsl
===================================================================
--- code/rend2/glsl/texturecolor_fp.glsl	(revision 0)
+++ code/rend2/glsl/texturecolor_fp.glsl	(revision 334)
@@ -0,0 +1,12 @@
+#version 120
+
+uniform sampler2D u_DiffuseMap;
+uniform vec4      u_Color;
+
+varying vec2         var_Tex1;
+
+
+void main()
+{
+	gl_FragColor = texture2D(u_DiffuseMap, var_Tex1) * u_Color;
+}
Index: code/rend2/glsl/lightall_fp.glsl
===================================================================
--- code/rend2/glsl/lightall_fp.glsl	(revision 0)
+++ code/rend2/glsl/lightall_fp.glsl	(revision 334)
@@ -0,0 +1,355 @@
+uniform sampler2D u_DiffuseMap;
+
+#if defined(USE_LIGHTMAP)
+uniform sampler2D u_LightMap;
+#endif
+
+#if defined(USE_NORMALMAP)
+uniform sampler2D u_NormalMap;
+#endif
+
+#if defined(USE_DELUXEMAP)
+uniform sampler2D u_DeluxeMap;
+#endif
+
+#if defined(USE_SPECULARMAP)
+uniform sampler2D u_SpecularMap;
+#endif
+
+#if defined(USE_SHADOWMAP)
+uniform sampler2D u_ShadowMap;
+#endif
+
+uniform vec3      u_ViewOrigin;
+
+#if defined(USE_TCGEN)
+uniform int    u_TCGen0;
+#endif
+
+#if defined(USE_LIGHT_VECTOR)
+uniform vec3      u_DirectedLight;
+uniform vec3      u_AmbientLight;
+uniform float     u_LightRadius;
+#endif
+
+#if defined(USE_LIGHT)
+uniform vec2      u_MaterialInfo;
+#endif
+
+varying vec2      var_DiffuseTex;
+#if defined(USE_LIGHTMAP)
+varying vec2      var_LightTex;
+#endif
+varying vec4      var_Color;
+
+#if defined(USE_NORMALMAP) && !defined(USE_VERT_TANGENT_SPACE)
+varying vec3      var_Position;
+#endif
+
+varying vec3      var_SampleToView;
+
+#if !defined(USE_FAST_LIGHT)
+varying vec3      var_Normal;
+#endif
+
+#if defined(USE_VERT_TANGENT_SPACE)
+varying vec3      var_Tangent;
+varying vec3      var_Bitangent;
+#endif
+
+varying vec3      var_VertLight;
+
+#if defined(USE_LIGHT) && !defined(USE_DELUXEMAP)
+varying vec3      var_WorldLight;
+#endif
+
+#define EPSILON 0.00000001
+
+#if defined(USE_PARALLAXMAP)
+float SampleHeight(sampler2D normalMap, vec2 t)
+{
+  #if defined(SWIZZLE_NORMALMAP)
+	return texture2D(normalMap, t).r;
+  #else
+	return texture2D(normalMap, t).a;
+  #endif
+}
+
+float RayIntersectDisplaceMap(vec2 dp, vec2 ds, sampler2D normalMap)
+{
+	const int linearSearchSteps = 16;
+	const int binarySearchSteps = 6;
+
+	float depthStep = 1.0 / float(linearSearchSteps);
+
+	// current size of search window
+	float size = depthStep;
+
+	// current depth position
+	float depth = 0.0;
+
+	// best match found (starts with last position 1.0)
+	float bestDepth = 1.0;
+
+	// search front to back for first point inside object
+	for(int i = 0; i < linearSearchSteps - 1; ++i)
+	{
+		depth += size;
+		
+		float t = 1.0 - SampleHeight(normalMap, dp + ds * depth);
+		
+		if(bestDepth > 0.996)		// if no depth found yet
+			if(depth >= t)
+				bestDepth = depth;	// store best depth
+	}
+
+	depth = bestDepth;
+	
+	// recurse around first point (depth) for closest match
+	for(int i = 0; i < binarySearchSteps; ++i)
+	{
+		size *= 0.5;
+
+		float t = 1.0 - SampleHeight(normalMap, dp + ds * depth);
+		
+		if(depth >= t)
+		{
+			bestDepth = depth;
+			depth -= 2.0 * size;
+		}
+
+		depth += size;
+	}
+
+	return bestDepth;
+}
+#endif
+
+float CalcDiffuse(vec3 N, vec3 L, vec3 E, float NE, float NL, float fzero, float shininess)
+{
+  #if defined(USE_OREN_NAYAR) || defined(USE_TRIACE_OREN_NAYAR)
+	float gamma = dot(E, L) - NE * NL;
+	float B = 2.22222 + 0.1 * shininess;
+		
+	#if defined(USE_OREN_NAYAR)
+	float A = 1.0 - 1.0 / (2.0 + 0.33 * shininess);
+	gamma = clamp(gamma, 0.0, 1.0);
+	#endif
+	
+	#if defined(USE_TRIACE_OREN_NAYAR)
+	float A = 1.0 - 1.0 / (2.0 + 0.65 * shininess);
+
+	if (gamma >= 0.0)
+	#endif
+	{
+		B *= max(max(NL, NE), EPSILON);
+	}
+
+	return (A + gamma / B) * (1.0 - fzero);
+  #else
+	return 1.0 - fzero;
+  #endif
+}
+
+#if defined(USE_SPECULARMAP)
+float CalcSpecular(float NH, float NL, float NE, float EH, float fzero, float shininess)
+{
+  #if defined(USE_BLINN) || defined(USE_TRIACE) || defined(USE_TORRANCE_SPARROW)
+	float blinn = pow(NH, shininess);
+  #endif
+
+  #if defined(USE_BLINN)
+	return blinn;
+  #endif
+
+  #if defined(USE_COOK_TORRANCE) || defined (USE_TRIACE) || defined (USE_TORRANCE_SPARROW)
+	float fresnel = fzero + (1.0 - fzero) * pow(1.0 - EH, 5);
+  #endif
+
+  #if defined(USE_COOK_TORRANCE) || defined(USE_TORRANCE_SPARROW)
+	float geo = 2.0 * NH * min(NE, NL);
+	geo /= max(EH, geo);
+  #endif  
+
+  #if defined(USE_COOK_TORRANCE)
+	float m_sq = 2.0 / max(shininess, EPSILON);
+	float NH_sq = NH * NH;
+	float m_NH_sq = m_sq * NH_sq;
+	float beckmann = exp((NH_sq - 1.0) / max(m_NH_sq, EPSILON)) / max(4.0 * m_NH_sq * NH_sq, EPSILON);
+
+	return fresnel * geo * beckmann / max(NE, EPSILON);
+  #endif
+
+  #if defined(USE_TRIACE)
+	float scale = 0.1248582 * shininess + 0.2691817;
+
+	return fresnel * scale * blinn / max(max(NL, NE), EPSILON);
+  #endif
+  
+  #if defined(USE_TORRANCE_SPARROW)
+	float scale = 0.125 * shininess + 1.0;
+
+	return fresnel * geo * scale * blinn / max(NE, EPSILON);
+  #endif
+}
+#endif
+
+void main()
+{
+#if !defined(USE_FAST_LIGHT) && (defined(USE_LIGHT) || defined(USE_NORMALMAP))
+	vec3 surfNormal = normalize(var_Normal);
+#endif
+
+#if defined(USE_DELUXEMAP)
+	vec3 worldLight = 2.0 * texture2D(u_DeluxeMap, var_LightTex).xyz - vec3(1.0);
+	//worldLight += var_WorldLight * 0.0001;
+#elif defined(USE_LIGHT)
+	vec3 worldLight = var_WorldLight;
+#endif
+
+#if defined(USE_LIGHTMAP)
+	vec4 lightSample = texture2D(u_LightMap, var_LightTex).rgba;
+  #if defined(RGBE_LIGHTMAP)
+	lightSample.rgb *= exp2(lightSample.a * 255.0 - 128.0);
+  #endif
+	vec3 directedLight = lightSample.rgb;
+#elif defined(USE_LIGHT_VECTOR) && !defined(USE_FAST_LIGHT)
+  #if defined(USE_INVSQRLIGHT)
+	float intensity = 1.0 / dot(worldLight, worldLight);
+  #else
+	float intensity = clamp((1.0 - dot(worldLight, worldLight) / (u_LightRadius * u_LightRadius)) * 1.07, 0.0, 1.0);
+  #endif
+
+	vec3 directedLight = u_DirectedLight * intensity;
+	vec3 ambientLight  = u_AmbientLight;
+
+  #if defined(USE_SHADOWMAP)
+	vec2 shadowTex = gl_FragCoord.xy * r_FBufScale;
+	directedLight *= texture2D(u_ShadowMap, shadowTex).r;
+  #endif
+#elif defined(USE_LIGHT_VERTEX) && !defined(USE_FAST_LIGHT)
+	vec3 directedLight = var_VertLight;
+#endif
+	
+#if defined(USE_TCGEN) || defined(USE_NORMALMAP) || (defined(USE_LIGHT) && !defined(USE_FAST_LIGHT))
+	vec3 SampleToView = normalize(var_SampleToView);
+#endif
+	vec2 tex = var_DiffuseTex;
+
+	float ambientDiff = 1.0;
+
+#if defined(USE_NORMALMAP)
+  #if defined(USE_VERT_TANGENT_SPACE)
+    vec3   tangent = var_Tangent;
+	vec3 bitangent = var_Bitangent;
+  #else
+	vec3 q0  = dFdx(var_Position);
+	vec3 q1  = dFdy(var_Position);
+	vec2 st0 = dFdx(tex);
+	vec2 st1 = dFdy(tex);
+	float dir = sign(st1.t * st0.s - st0.t * st1.s);
+
+	vec3   tangent = normalize( q0 * st1.t - q1 * st0.t) * dir;
+	vec3 bitangent = -normalize( q0 * st1.s - q1 * st0.s) * dir;
+  #endif
+
+	mat3 tangentToWorld = mat3(tangent, bitangent, var_Normal);
+
+  #if defined(USE_PARALLAXMAP)
+	vec3 offsetDir = normalize(SampleToView * tangentToWorld);
+    #if 0
+    float height = SampleHeight(u_NormalMap, tex);
+	float pdist = 0.05 * height - (0.05 / 2.0);
+    #else
+	offsetDir.xy *= -0.05 / offsetDir.z;
+	float pdist = RayIntersectDisplaceMap(tex, offsetDir.xy, u_NormalMap);
+    #endif	
+	tex += offsetDir.xy * pdist;
+  #endif
+  #if defined(SWIZZLE_NORMALMAP)
+	vec3 normal = 2.0 * texture2D(u_NormalMap, tex).agb - 1.0;
+  #else
+	vec3 normal = 2.0 * texture2D(u_NormalMap, tex).rgb - 1.0;
+  #endif
+	normal.z = sqrt(clamp(1.0 - dot(normal.xy, normal.xy), 0.0, 1.0));
+	vec3 worldNormal = tangentToWorld * normal;
+  #if defined(r_normalAmbient)
+	ambientDiff = 0.781341 * normal.z + 0.218659;
+  #endif
+#elif defined(USE_LIGHT) && !defined(USE_FAST_LIGHT)
+	vec3 worldNormal = surfNormal;
+#endif
+
+#if (defined(USE_LIGHT) && !defined(USE_FAST_LIGHT)) || (defined(USE_TCGEN) && defined(USE_NORMALMAP))
+	worldNormal = normalize(worldNormal);
+#endif
+
+#if defined(USE_TCGEN) && defined(USE_NORMALMAP)
+	if (u_TCGen0 == TCGEN_ENVIRONMENT_MAPPED)
+	{
+		tex = -reflect(normalize(SampleToView), worldNormal).yz * vec2(0.5, -0.5) + 0.5;
+	}
+#endif
+
+	vec4 diffuse = texture2D(u_DiffuseMap, tex);
+
+#if defined(USE_LIGHT) && defined(USE_FAST_LIGHT)
+  #if defined(USE_LIGHTMAP)
+	diffuse.rgb *= directedLight;
+  #endif
+#elif defined(USE_LIGHT)
+	worldLight = normalize(worldLight);
+
+  #if defined(USE_LIGHTMAP) || defined(USE_LIGHT_VERTEX)
+	#if defined(r_normalAmbient)
+	vec3 ambientLight = directedLight * r_normalAmbient;
+	directedLight -= ambientLight;
+    #else
+	vec3 ambientLight = vec3(0.0);
+    #endif
+	directedLight /= max(dot(surfNormal, worldLight), 0.004);
+  #endif
+
+	float NL = clamp(dot(worldNormal,  worldLight),   0.0, 1.0);
+	float surfNL = clamp(dot(surfNormal,  worldLight),   0.0, 1.0);
+	NL = min(NL, surfNL * 2.0);
+	float NE = clamp(dot(worldNormal,  SampleToView), 0.0, 1.0);
+	
+	float fzero = u_MaterialInfo.x;
+	float shininess = u_MaterialInfo.y;
+  #if defined(USE_SPECULARMAP)
+	vec4 specular = texture2D(u_SpecularMap, tex);
+	//specular.rgb = clamp(specular.rgb - diffuse.rgb, 0.0, 1.0);
+	shininess *= specular.a;
+  #endif
+	float directedDiff = NL * CalcDiffuse(worldNormal, worldLight, SampleToView, NE, NL, fzero, shininess);
+	diffuse.rgb *= directedLight * directedDiff + ambientDiff * ambientLight;
+  
+  #if defined(USE_SPECULARMAP)
+	vec3 halfAngle = normalize(worldLight + SampleToView);
+
+	float EH = clamp(dot(SampleToView, halfAngle), 0.0, 1.0);
+	float NH = clamp(dot(worldNormal,  halfAngle), 0.0, 1.0);
+
+	float directedSpec = NL * CalcSpecular(NH, NL, NE, EH, fzero, shininess);
+  
+    #if defined(r_normalAmbient)
+	vec3 ambientHalf = normalize(surfNormal + SampleToView);
+	float ambientSpec = max(dot(ambientHalf, worldNormal) + 0.5, 0.0);
+	ambientSpec *= ambientSpec * 0.44;
+	ambientSpec = pow(ambientSpec, shininess) * fzero;
+	specular.rgb *= directedSpec * directedLight + ambientSpec * ambientLight;
+    #else
+	specular.rgb *= directedSpec * directedLight;
+    #endif
+  #endif
+#endif
+
+	gl_FragColor = diffuse;
+
+#if defined(USE_SPECULARMAP) && defined(USE_LIGHT) && !defined(USE_FAST_LIGHT)
+	gl_FragColor.rgb += specular.rgb;
+#endif
+
+	gl_FragColor *= var_Color;
+}
Index: code/rend2/glsl/shadowmask_fp.glsl
===================================================================
--- code/rend2/glsl/shadowmask_fp.glsl	(revision 0)
+++ code/rend2/glsl/shadowmask_fp.glsl	(revision 334)
@@ -0,0 +1,127 @@
+uniform sampler2D u_ScreenDepthMap;
+
+uniform sampler2D u_ShadowMap;
+#if defined(USE_SHADOW_CASCADE)
+uniform sampler2D u_ShadowMap2;
+uniform sampler2D u_ShadowMap3;
+#endif
+
+uniform mat4      u_ShadowMvp;
+#if defined(USE_SHADOW_CASCADE)
+uniform mat4      u_ShadowMvp2;
+uniform mat4      u_ShadowMvp3;
+#endif
+
+uniform vec3   u_ViewOrigin;
+uniform vec4   u_ViewInfo; // zfar / znear, zfar
+
+varying vec2   var_DepthTex;
+varying vec3   var_ViewDir;
+
+// Input: It uses texture coords as the random number seed.
+// Output: Random number: [0,1), that is between 0.0 and 0.999999... inclusive.
+// Author: Michael Pohoreski
+// Copyright: Copyleft 2012 :-)
+// Source: http://stackoverflow.com/questions/5149544/can-i-generate-a-random-number-inside-a-pixel-shader
+
+float random( const vec2 p )
+{
+  // We need irrationals for pseudo randomness.
+  // Most (all?) known transcendental numbers will (generally) work.
+  const vec2 r = vec2(
+    23.1406926327792690,  // e^pi (Gelfond's constant)
+     2.6651441426902251); // 2^sqrt(2) (Gelfond-Schneider constant)
+  //return fract( cos( mod( 123456789., 1e-7 + 256. * dot(p,r) ) ) );
+  return mod( 123456789., 1e-7 + 256. * dot(p,r) );  
+}
+
+float PCF(const sampler2D shadowmap, const vec2 st, const float dist)
+{
+	float mult;
+	float scale = 2.0 / r_shadowMapSize;
+		
+#if defined(USE_SHADOW_FILTER)
+	float r = random(var_DepthTex.xy);
+	float sinr = sin(r) * scale;
+	float cosr = cos(r) * scale;
+	mat2 rmat = mat2(cosr, sinr, -sinr, cosr);
+
+	mult =  step(dist, texture2D(shadowmap, st + rmat * vec2(-0.7055767, 0.196515)).r);
+	mult += step(dist, texture2D(shadowmap, st + rmat * vec2(0.3524343, -0.7791386)).r);
+	mult += step(dist, texture2D(shadowmap, st + rmat * vec2(0.2391056, 0.9189604)).r);
+  #if defined(USE_SHADOW_FILTER2)
+	mult += step(dist, texture2D(shadowmap, st + rmat * vec2(-0.07580382, -0.09224417)).r);
+	mult += step(dist, texture2D(shadowmap, st + rmat * vec2(0.5784913, -0.002528916)).r);
+	mult += step(dist, texture2D(shadowmap, st + rmat * vec2(0.192888, 0.4064181)).r);
+	mult += step(dist, texture2D(shadowmap, st + rmat * vec2(-0.6335801, -0.5247476)).r);
+	mult += step(dist, texture2D(shadowmap, st + rmat * vec2(-0.5579782, 0.7491854)).r);
+	mult += step(dist, texture2D(shadowmap, st + rmat * vec2(0.7320465, 0.6317794)).r);
+
+	mult *= 0.11111;
+  #else
+    mult *= 0.33333;
+  #endif
+#else
+	mult = step(dist, texture2D(shadowmap, st).r);
+#endif
+		
+	return mult;
+}
+
+float getLinearDepth(sampler2D depthMap, vec2 tex, float zFarDivZNear)
+{
+		float sampleZDivW = texture2D(depthMap, tex).r;
+		return 1.0 / mix(zFarDivZNear, 1.0, sampleZDivW);
+}
+
+void main()
+{
+	float result;
+	
+	float depth = getLinearDepth(u_ScreenDepthMap, var_DepthTex, u_ViewInfo.x);
+	float sampleZ = u_ViewInfo.y * depth;
+
+	vec4 biasPos = vec4(u_ViewOrigin + var_ViewDir * depth * 0.99, 1.0);
+	
+	vec4 shadowpos = u_ShadowMvp * biasPos;
+	
+#if defined(USE_SHADOW_CASCADE)
+	const float fadeTo = 0.5;
+	result = fadeTo;
+#else
+	result = 0.0;
+#endif
+
+	if (all(lessThanEqual(abs(shadowpos.xyz), vec3(abs(shadowpos.w)))))
+	{
+		shadowpos.xyz = shadowpos.xyz / shadowpos.w * 0.5 + 0.5;
+		result = PCF(u_ShadowMap, shadowpos.xy, shadowpos.z);
+	}
+#if defined(USE_SHADOW_CASCADE)
+	else
+	{
+		shadowpos = u_ShadowMvp2 * biasPos;
+
+		if (all(lessThanEqual(abs(shadowpos.xyz), vec3(abs(shadowpos.w)))))
+		{
+			shadowpos.xyz = shadowpos.xyz / shadowpos.w * 0.5 + 0.5;
+			result = PCF(u_ShadowMap2, shadowpos.xy, shadowpos.z);
+		}
+		else
+		{
+			shadowpos = u_ShadowMvp3 * biasPos;
+
+			if (all(lessThanEqual(abs(shadowpos.xyz), vec3(abs(shadowpos.w)))))
+			{
+				shadowpos.xyz = shadowpos.xyz / shadowpos.w * 0.5 + 0.5;
+				result = PCF(u_ShadowMap3, shadowpos.xy, shadowpos.z);
+
+				float fade = clamp(sampleZ / r_shadowCascadeZFar * 10.0 - 9.0, 0.0, 1.0);
+				result = mix(result, fadeTo, fade);
+			}
+		}
+	}
+#endif
+		
+	gl_FragColor = vec4(vec3(result), 1.0);
+}
Index: code/rend2/glsl/fogpass_fp.glsl
===================================================================
--- code/rend2/glsl/fogpass_fp.glsl	(revision 0)
+++ code/rend2/glsl/fogpass_fp.glsl	(revision 334)
@@ -0,0 +1,9 @@
+uniform vec4  u_Color;
+
+varying float var_Scale;
+
+void main()
+{
+	gl_FragColor = u_Color;
+	gl_FragColor.a *= sqrt(clamp(var_Scale, 0.0, 1.0));
+}
Index: code/rend2/glsl/down4x_vp.glsl
===================================================================
--- code/rend2/glsl/down4x_vp.glsl	(revision 0)
+++ code/rend2/glsl/down4x_vp.glsl	(revision 334)
@@ -0,0 +1,13 @@
+attribute vec4 attr_Position;
+attribute vec4 attr_TexCoord0;
+
+uniform mat4   u_ModelViewProjectionMatrix;
+
+varying vec2   var_TexCoords;
+
+
+void main()
+{
+	gl_Position = u_ModelViewProjectionMatrix * attr_Position;
+	var_TexCoords = attr_TexCoord0.st;
+}
Index: code/rend2/glsl/tonemap_fp.glsl
===================================================================
--- code/rend2/glsl/tonemap_fp.glsl	(revision 0)
+++ code/rend2/glsl/tonemap_fp.glsl	(revision 334)
@@ -0,0 +1,48 @@
+uniform sampler2D u_TextureMap;
+uniform sampler2D u_LevelsMap;
+
+uniform vec4      u_Color;
+
+uniform vec2      u_AutoExposureMinMax;
+uniform vec3      u_ToneMinAvgMaxLinear;
+
+varying vec2      var_TexCoords;
+
+const vec3  LUMINANCE_VECTOR =   vec3(0.2125, 0.7154, 0.0721); //vec3(0.299, 0.587, 0.114);
+
+vec3 FilmicTonemap(vec3 x)
+{
+	const float SS  = 0.22; // Shoulder Strength
+	const float LS  = 0.30; // Linear Strength
+	const float LA  = 0.10; // Linear Angle
+	const float TS  = 0.20; // Toe Strength
+	const float TAN = 0.01; // Toe Angle Numerator
+	const float TAD = 0.30; // Toe Angle Denominator
+	
+	vec3 SSxx = SS * x * x;
+	vec3 LSx = LS * x;
+	vec3 LALSx = LSx * LA;
+	
+	return ((SSxx + LALSx + TS * TAN) / (SSxx + LSx + TS * TAD)) - TAN / TAD;
+
+	//return ((x*(SS*x+LA*LS)+TS*TAN)/(x*(SS*x+LS)+TS*TAD)) - TAN/TAD;
+
+}
+
+void main()
+{
+	vec4 color = texture2D(u_TextureMap, var_TexCoords) * u_Color;
+	vec3 minAvgMax = texture2D(u_LevelsMap, var_TexCoords).rgb;
+	vec3 logMinAvgMaxLum = clamp(minAvgMax * 20.0 - 10.0, -u_AutoExposureMinMax.y, -u_AutoExposureMinMax.x);
+		
+	float avgLum = exp2(logMinAvgMaxLum.y);
+	//float maxLum = exp2(logMinAvgMaxLum.z);
+
+	color.rgb *= u_ToneMinAvgMaxLinear.y / avgLum;
+	color.rgb = max(vec3(0.0), color.rgb - vec3(u_ToneMinAvgMaxLinear.x));
+
+	vec3 fWhite = 1.0 / FilmicTonemap(vec3(u_ToneMinAvgMaxLinear.z - u_ToneMinAvgMaxLinear.x));
+	color.rgb = FilmicTonemap(color.rgb) * fWhite;
+	
+	gl_FragColor = clamp(color, 0.0, 1.0);
+}
Index: code/rend2/glsl/ssao_fp.glsl
===================================================================
--- code/rend2/glsl/ssao_fp.glsl	(revision 0)
+++ code/rend2/glsl/ssao_fp.glsl	(revision 334)
@@ -0,0 +1,86 @@
+uniform sampler2D u_ScreenDepthMap;
+
+uniform vec4   u_ViewInfo; // zfar / znear, zfar
+
+varying vec2   var_ScreenTex;
+
+vec2 poissonDisc[9] = vec2[9](
+vec2(-0.7055767, 0.196515),    vec2(0.3524343, -0.7791386),
+vec2(0.2391056, 0.9189604),    vec2(-0.07580382, -0.09224417),
+vec2(0.5784913, -0.002528916), vec2(0.192888, 0.4064181),
+vec2(-0.6335801, -0.5247476),  vec2(-0.5579782, 0.7491854),
+vec2(0.7320465, 0.6317794)
+);
+
+// Input: It uses texture coords as the random number seed.
+// Output: Random number: [0,1), that is between 0.0 and 0.999999... inclusive.
+// Author: Michael Pohoreski
+// Copyright: Copyleft 2012 :-)
+// Source: http://stackoverflow.com/questions/5149544/can-i-generate-a-random-number-inside-a-pixel-shader
+
+float random( const vec2 p )
+{
+  // We need irrationals for pseudo randomness.
+  // Most (all?) known transcendental numbers will (generally) work.
+  const vec2 r = vec2(
+    23.1406926327792690,  // e^pi (Gelfond's constant)
+     2.6651441426902251); // 2^sqrt(2) (Gelfond-Schneider constant)
+  //return fract( cos( mod( 123456789., 1e-7 + 256. * dot(p,r) ) ) );
+  return mod( 123456789., 1e-7 + 256. * dot(p,r) );  
+}
+
+mat2 randomRotation( const vec2 p )
+{
+	float r = random(p);
+	float sinr = sin(r);
+	float cosr = cos(r);
+	return mat2(cosr, sinr, -sinr, cosr);
+}
+
+float getLinearDepth(sampler2D depthMap, const vec2 tex, const float zFarDivZNear)
+{
+		float sampleZDivW = texture2D(depthMap, tex).r;
+		return 1.0 / mix(zFarDivZNear, 1.0, sampleZDivW);
+}
+
+float ambientOcclusion(sampler2D depthMap, const vec2 tex, const float zFarDivZNear, const float zFar)
+{
+	float result = 0;
+
+	float sampleZ = zFar * getLinearDepth(depthMap, tex, zFarDivZNear);
+
+	vec2 expectedSlope = vec2(dFdx(sampleZ), dFdy(sampleZ)) / vec2(dFdx(tex.x), dFdy(tex.y));
+	
+	if (length(expectedSlope) > 5000.0)
+		return 1.0;
+	
+	vec2 offsetScale = vec2(3.0 / sampleZ);
+	
+	mat2 rmat = randomRotation(tex);
+		
+	int i;
+	for (i = 0; i < 3; i++)
+	{
+		vec2 offset = rmat * poissonDisc[i] * offsetScale;
+		float sampleZ2 = zFar * getLinearDepth(depthMap, tex + offset, zFarDivZNear);
+
+		if (abs(sampleZ - sampleZ2) > 20.0)
+			result += 1.0;
+		else
+		{
+			float expectedZ = sampleZ + dot(expectedSlope, offset);
+			result += step(expectedZ - 1.0, sampleZ2);
+		}
+	}
+	
+	result *= 0.33333;
+	
+	return result;
+}
+
+void main()
+{
+	float result = ambientOcclusion(u_ScreenDepthMap, var_ScreenTex, u_ViewInfo.x, u_ViewInfo.y);
+			
+	gl_FragColor = vec4(vec3(result), 1.0);
+}
Index: code/rend2/glsl/pshadow_fp.glsl
===================================================================
--- code/rend2/glsl/pshadow_fp.glsl	(revision 0)
+++ code/rend2/glsl/pshadow_fp.glsl	(revision 334)
@@ -0,0 +1,98 @@
+uniform sampler2D u_ShadowMap;
+
+uniform vec3      u_LightForward;
+uniform vec3      u_LightUp;
+uniform vec3      u_LightRight;
+uniform vec4      u_LightOrigin;
+uniform float     u_LightRadius;
+varying vec3      var_Position;
+varying vec3      var_Normal;
+
+float sampleDistMap(sampler2D texMap, vec2 uv, float scale)
+{
+	vec3 distv = texture2D(texMap, uv).xyz;
+	return dot(distv, vec3(1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0)) * scale;
+}
+
+void main()
+{
+	vec3 lightToPos = var_Position - u_LightOrigin.xyz;
+	vec2 st = vec2(-dot(u_LightRight, lightToPos), dot(u_LightUp, lightToPos));
+	
+	float fade = length(st);
+	
+#if defined(USE_DISCARD)
+	if (fade >= 1.0)
+	{
+		discard;
+	}
+#endif
+
+	fade = clamp(8.0 - fade * 8.0, 0.0, 1.0);
+	
+	st = st * 0.5 + vec2(0.5);
+
+#if defined(USE_SOLID_PSHADOWS)
+	float intensity = max(sign(u_LightRadius - length(lightToPos)), 0.0);
+#else
+	float intensity = clamp((1.0 - dot(lightToPos, lightToPos) / (u_LightRadius * u_LightRadius)) * 2.0, 0.0, 1.0);
+#endif
+	
+	float lightDist = length(lightToPos);
+	float dist;
+
+#if defined(USE_DISCARD)
+	if (dot(u_LightForward, lightToPos) <= 0.0)
+	{
+		discard;
+	}
+
+	if (dot(var_Normal, lightToPos) > 0.0)
+	{
+		discard;
+	}
+#else
+	intensity *= max(sign(dot(u_LightForward, lightToPos)), 0.0);
+	intensity *= max(sign(-dot(var_Normal, lightToPos)), 0.0);
+#endif
+
+	intensity *= fade;
+#if defined(USE_PCF)
+	float part;
+	
+	dist = sampleDistMap(u_ShadowMap, st + vec2(-1.0/512.0, -1.0/512.0), u_LightRadius);
+	part =  max(sign(lightDist - dist), 0.0);
+
+	dist = sampleDistMap(u_ShadowMap, st + vec2( 1.0/512.0, -1.0/512.0), u_LightRadius);
+	part += max(sign(lightDist - dist), 0.0);
+
+	dist = sampleDistMap(u_ShadowMap, st + vec2(-1.0/512.0,  1.0/512.0), u_LightRadius);
+	part += max(sign(lightDist - dist), 0.0);
+
+	dist = sampleDistMap(u_ShadowMap, st + vec2( 1.0/512.0,  1.0/512.0), u_LightRadius);
+	part += max(sign(lightDist - dist), 0.0);
+
+  #if defined(USE_DISCARD)
+	if (part <= 0.0)
+	{
+		discard;
+	}
+  #endif
+
+	intensity *= part * 0.25;
+#else
+	dist = sampleDistMap(u_ShadowMap, st, u_LightRadius);
+
+  #if defined(USE_DISCARD)
+	if (lightDist - dist <= 0.0)
+	{
+		discard;
+	}
+  #endif
+			
+	intensity *= max(sign(lightDist - dist), 0.0);
+#endif
+		
+	gl_FragColor.rgb = vec3(0);
+	gl_FragColor.a = clamp(intensity, 0.0, 0.75);
+}
Index: code/rend2/glsl/bokeh_vp.glsl
===================================================================
--- code/rend2/glsl/bokeh_vp.glsl	(revision 0)
+++ code/rend2/glsl/bokeh_vp.glsl	(revision 334)
@@ -0,0 +1,13 @@
+attribute vec4 attr_Position;
+attribute vec4 attr_TexCoord0;
+
+uniform mat4   u_ModelViewProjectionMatrix;
+
+varying vec2   var_TexCoords;
+
+
+void main()
+{
+	gl_Position = u_ModelViewProjectionMatrix * attr_Position;
+	var_TexCoords = attr_TexCoord0.st;
+}
Index: code/rend2/glsl/depthblur_vp.glsl
===================================================================
--- code/rend2/glsl/depthblur_vp.glsl	(revision 0)
+++ code/rend2/glsl/depthblur_vp.glsl	(revision 334)
@@ -0,0 +1,12 @@
+attribute vec4 attr_Position;
+attribute vec4 attr_TexCoord0;
+
+varying vec2   var_ScreenTex;
+
+void main()
+{
+	gl_Position = attr_Position;
+	var_ScreenTex = attr_TexCoord0.xy;
+	//vec2 screenCoords = gl_Position.xy / gl_Position.w;
+	//var_ScreenTex = screenCoords * 0.5 + 0.5;
+}
Index: code/rend2/glsl/calclevels4x_vp.glsl
===================================================================
--- code/rend2/glsl/calclevels4x_vp.glsl	(revision 0)
+++ code/rend2/glsl/calclevels4x_vp.glsl	(revision 334)
@@ -0,0 +1,13 @@
+attribute vec4 attr_Position;
+attribute vec4 attr_TexCoord0;
+
+uniform mat4   u_ModelViewProjectionMatrix;
+
+varying vec2   var_TexCoords;
+
+
+void main()
+{
+	gl_Position = u_ModelViewProjectionMatrix * attr_Position;
+	var_TexCoords = attr_TexCoord0.st;
+}
Index: code/rend2/glsl/dlight_fp.glsl
===================================================================
--- code/rend2/glsl/dlight_fp.glsl	(revision 0)
+++ code/rend2/glsl/dlight_fp.glsl	(revision 334)
@@ -0,0 +1,12 @@
+uniform sampler2D u_DiffuseMap;
+
+varying vec2      var_Tex1;
+varying vec4      var_Color;
+
+
+void main()
+{
+	vec4 color = texture2D(u_DiffuseMap, var_Tex1);
+
+	gl_FragColor = color * var_Color;
+}
Index: code/rend2/glsl/shadowfill_vp.glsl
===================================================================
--- code/rend2/glsl/shadowfill_vp.glsl	(revision 0)
+++ code/rend2/glsl/shadowfill_vp.glsl	(revision 334)
@@ -0,0 +1,89 @@
+attribute vec4  attr_Position;
+attribute vec3  attr_Normal;
+attribute vec4  attr_TexCoord0;
+
+//#if defined(USE_VERTEX_ANIMATION)
+attribute vec4  attr_Position2;
+attribute vec3  attr_Normal2;
+//#endif
+
+//#if defined(USE_DEFORM_VERTEXES)
+uniform int     u_DeformGen;
+uniform float    u_DeformParams[5];
+//#endif
+
+uniform float   u_Time;
+uniform mat4    u_ModelViewProjectionMatrix;
+
+uniform mat4   u_ModelMatrix;
+
+//#if defined(USE_VERTEX_ANIMATION)
+uniform float   u_VertexLerp;
+//#endif
+
+varying vec3    var_Position;
+
+vec3 DeformPosition(const vec3 pos, const vec3 normal, const vec2 st)
+{
+	if (u_DeformGen == 0)
+	{
+		return pos;
+	}
+
+	float base =      u_DeformParams[0];
+	float amplitude = u_DeformParams[1];
+	float phase =     u_DeformParams[2];
+	float frequency = u_DeformParams[3];
+	float spread =    u_DeformParams[4];
+
+	if (u_DeformGen == DGEN_BULGE)
+	{
+		phase *= M_PI * 0.25 * st.x;
+	}
+	else // if (u_DeformGen <= DGEN_WAVE_INVERSE_SAWTOOTH)
+	{
+		phase += dot(pos.xyz, vec3(spread));
+	}
+
+	float value = phase + (u_Time * frequency);
+	float func;
+
+	if (u_DeformGen == DGEN_WAVE_SIN)
+	{
+		func = sin(value * 2.0 * M_PI);
+	}
+	else if (u_DeformGen == DGEN_WAVE_SQUARE)
+	{
+		func = sign(sin(value * 2.0 * M_PI));
+	}
+	else if (u_DeformGen == DGEN_WAVE_TRIANGLE)
+	{
+		func = abs(fract(value + 0.75) - 0.5) * 4.0 - 1.0;
+	}
+	else if (u_DeformGen == DGEN_WAVE_SAWTOOTH)
+	{
+		func = fract(value);
+	}
+	else if (u_DeformGen == DGEN_WAVE_INVERSE_SAWTOOTH)
+	{
+		func = (1.0 - fract(value));
+	}
+	else if (u_DeformGen == DGEN_BULGE)
+	{
+		func = sin(value);
+	}
+
+	return pos + normal * (base + func * amplitude);
+}
+
+void main()
+{
+	vec4 position = mix(attr_Position, attr_Position2, u_VertexLerp);
+	vec3 normal = normalize(mix(attr_Normal, attr_Normal2, u_VertexLerp));
+
+	position.xyz = DeformPosition(position.xyz, normal, attr_TexCoord0.st);
+
+	gl_Position = u_ModelViewProjectionMatrix * position;
+	
+	var_Position  = (u_ModelMatrix * position).xyz;
+}
Index: code/rend2/glsl/generic_fp.glsl
===================================================================
--- code/rend2/glsl/generic_fp.glsl	(revision 0)
+++ code/rend2/glsl/generic_fp.glsl	(revision 334)
@@ -0,0 +1,43 @@
+uniform sampler2D u_DiffuseMap;
+
+#if defined(USE_LIGHTMAP)
+uniform sampler2D u_LightMap;
+
+uniform int       u_Texture1Env;
+#endif
+
+varying vec2      var_DiffuseTex;
+
+#if defined(USE_LIGHTMAP)
+varying vec2      var_LightTex;
+#endif
+
+varying vec4      var_Color;
+
+
+void main()
+{
+	vec4 color  = texture2D(u_DiffuseMap, var_DiffuseTex);
+#if defined(USE_LIGHTMAP)
+	vec4 color2 = texture2D(u_LightMap, var_LightTex);
+  #if defined(RGBE_LIGHTMAP)
+	color2.rgb *= exp2(color2.a * 255.0 - 128.0);
+	color2.a = 1.0;
+  #endif
+
+	if (u_Texture1Env == TEXENV_MODULATE)
+	{
+		color *= color2;
+	}
+	else if (u_Texture1Env == TEXENV_ADD)
+	{
+		color += color2;
+	}
+	else if (u_Texture1Env == TEXENV_REPLACE)
+	{
+		color = color2;
+	}
+#endif
+
+	gl_FragColor = color * var_Color;
+}
Index: code/rend2/glsl/texturecolor_vp.glsl
===================================================================
--- code/rend2/glsl/texturecolor_vp.glsl	(revision 0)
+++ code/rend2/glsl/texturecolor_vp.glsl	(revision 334)
@@ -0,0 +1,15 @@
+#version 120
+
+attribute vec4 attr_Position;
+attribute vec4 attr_TexCoord0;
+
+uniform mat4   u_ModelViewProjectionMatrix;
+
+varying vec2   var_Tex1;
+
+
+void main()
+{
+	gl_Position = u_ModelViewProjectionMatrix * attr_Position;
+	var_Tex1 = attr_TexCoord0.st;
+}
Index: code/rend2/glsl/lightall_vp.glsl
===================================================================
--- code/rend2/glsl/lightall_vp.glsl	(revision 0)
+++ code/rend2/glsl/lightall_vp.glsl	(revision 334)
@@ -0,0 +1,219 @@
+attribute vec4 attr_TexCoord0;
+#if defined(USE_LIGHTMAP)
+attribute vec4 attr_TexCoord1;
+#endif
+attribute vec4 attr_Color;
+
+attribute vec4 attr_Position;
+attribute vec3 attr_Normal;
+
+#if defined(USE_VERT_TANGENT_SPACE)
+attribute vec3 attr_Tangent;
+attribute vec3 attr_Bitangent;
+#endif
+
+#if defined(USE_VERTEX_ANIMATION)
+attribute vec4 attr_Position2;
+attribute vec3 attr_Normal2;
+  #if defined(USE_VERT_TANGENT_SPACE)
+attribute vec3 attr_Tangent2;
+attribute vec3 attr_Bitangent2;
+  #endif
+#endif
+
+#if defined(USE_LIGHT) && !defined(USE_LIGHT_VECTOR)
+attribute vec3 attr_LightDirection;
+#endif
+
+#if defined(USE_TCGEN) || defined(USE_NORMALMAP) || defined(USE_LIGHT) && !defined(USE_FAST_LIGHT)
+uniform vec3   u_ViewOrigin;
+#endif
+
+#if defined(USE_TCGEN)
+uniform int    u_TCGen0;
+#endif
+
+#if defined(USE_TCMOD)
+uniform vec4   u_DiffuseTexMatrix;
+uniform vec4   u_DiffuseTexOffTurb;
+#endif
+
+uniform mat4   u_ModelViewProjectionMatrix;
+uniform vec4   u_BaseColor;
+uniform vec4   u_VertColor;
+
+#if defined(USE_MODELMATRIX)
+uniform mat4   u_ModelMatrix;
+#endif
+
+#if defined(USE_VERTEX_ANIMATION)
+uniform float  u_VertexLerp;
+#endif
+
+#if defined(USE_LIGHT_VECTOR)
+uniform vec4   u_LightOrigin;
+  #if defined(USE_FAST_LIGHT)
+uniform vec3   u_DirectedLight;
+uniform vec3   u_AmbientLight;
+uniform float  u_LightRadius;
+  #endif
+#endif
+
+varying vec2   var_DiffuseTex;
+
+#if defined(USE_LIGHTMAP)
+varying vec2   var_LightTex;
+#endif
+
+#if defined(USE_NORMALMAP) || defined(USE_LIGHT) && !defined(USE_FAST_LIGHT)
+varying vec3   var_SampleToView;
+#endif
+
+varying vec4   var_Color;
+
+#if defined(USE_NORMALMAP) && !defined(USE_VERT_TANGENT_SPACE)
+varying vec3   var_Position;
+#endif
+
+
+#if !defined(USE_FAST_LIGHT)
+varying vec3   var_Normal;
+  #if defined(USE_VERT_TANGENT_SPACE)
+varying vec3   var_Tangent;
+varying vec3   var_Bitangent;
+  #endif
+#endif
+
+#if defined(USE_LIGHT_VERTEX) && !defined(USE_FAST_LIGHT)
+varying vec3   var_VertLight;
+#endif
+
+#if defined(USE_LIGHT) && !defined(USE_DELUXEMAP) && !defined(USE_FAST_LIGHT)
+varying vec3   var_WorldLight;
+#endif
+
+#if defined(USE_TCMOD)
+vec2 ModTexCoords(vec2 st, vec3 position, vec4 texMatrix, vec4 offTurb)
+{
+	float amplitude = offTurb.z;
+	float phase = offTurb.w;
+	vec2 st2 = vec2(dot(st, texMatrix.xz), dot(st, texMatrix.yw)) + offTurb.xy;
+
+	vec3 offsetPos = position / 1024.0;
+	offsetPos.x += offsetPos.z;
+	
+	vec2 texOffset = sin((offsetPos.xy + vec2(phase)) * 2.0 * M_PI);
+	
+	return st2 + texOffset * amplitude;	
+}
+#endif
+
+
+void main()
+{
+#if defined(USE_VERTEX_ANIMATION)
+	vec4 position  = mix(attr_Position, attr_Position2, u_VertexLerp);
+	vec3 normal    = normalize(mix(attr_Normal,    attr_Normal2,    u_VertexLerp));
+  #if defined(USE_VERT_TANGENT_SPACE)
+	vec3 tangent   = normalize(mix(attr_Tangent,   attr_Tangent2,   u_VertexLerp));
+	vec3 bitangent = normalize(mix(attr_Bitangent, attr_Bitangent2, u_VertexLerp));
+  #endif
+#else
+	vec4 position  = attr_Position;
+	vec3 normal    = attr_Normal;
+  #if defined(USE_VERT_TANGENT_SPACE)
+	vec3 tangent   = attr_Tangent;
+	vec3 bitangent = attr_Bitangent;
+  #endif
+#endif
+
+	gl_Position = u_ModelViewProjectionMatrix * position;
+
+#if (defined(USE_LIGHTMAP) || defined(USE_LIGHT_VERTEX)) && !defined(USE_DELUXEMAP) && !defined(USE_FAST_LIGHT)
+	vec3 worldLight = attr_LightDirection;
+#endif
+	
+#if defined(USE_MODELMATRIX)
+	position  = u_ModelMatrix * position;
+	normal    = (u_ModelMatrix * vec4(normal, 0.0)).xyz;
+  #if defined(USE_VERT_TANGENT_SPACE)
+	tangent   = (u_ModelMatrix * vec4(tangent, 0.0)).xyz;
+	bitangent = (u_ModelMatrix * vec4(bitangent, 0.0)).xyz;
+  #endif
+
+  #if defined(USE_LIGHTMAP) && !defined(USE_DELUXEMAP) && !defined(USE_FAST_LIGHT)
+	worldLight = (u_ModelMatrix * vec4(worldLight, 0.0)).xyz;
+  #endif
+#endif
+
+#if defined(USE_NORMALMAP) && !defined(USE_VERT_TANGENT_SPACE)
+	var_Position = position.xyz;
+#endif
+
+#if defined(USE_TCGEN) || defined(USE_NORMALMAP) || defined(USE_LIGHT) && !defined(USE_FAST_LIGHT)
+	vec3 SampleToView = u_ViewOrigin - position.xyz;
+#endif
+
+#if defined(USE_NORMALMAP) || defined(USE_LIGHT) && !defined(USE_FAST_LIGHT)
+	var_SampleToView = SampleToView;
+#endif
+
+	vec2 tex;
+
+#if defined(USE_TCGEN)
+	if (u_TCGen0 == TCGEN_ENVIRONMENT_MAPPED)
+	{
+		tex = -reflect(normalize(SampleToView), normal).yz * vec2(0.5, -0.5) + 0.5;
+	}
+	else
+#endif
+	{
+		tex = attr_TexCoord0.st;
+	}
+
+#if defined(USE_TCMOD)
+	var_DiffuseTex = ModTexCoords(tex, position.xyz, u_DiffuseTexMatrix, u_DiffuseTexOffTurb);
+#else
+	var_DiffuseTex = tex;
+#endif
+
+#if defined(USE_LIGHTMAP)
+	var_LightTex = attr_TexCoord1.st;
+#endif
+
+#if !defined(USE_FAST_LIGHT)
+	var_Normal = normal;
+  #if defined(USE_VERT_TANGENT_SPACE)
+	var_Tangent = tangent;
+	var_Bitangent = bitangent;
+  #endif
+#endif
+
+#if defined(USE_LIGHT) && !defined(USE_DELUXEMAP)
+  #if defined(USE_LIGHT_VECTOR)
+	vec3 worldLight = u_LightOrigin.xyz - (position.xyz * u_LightOrigin.w);
+  #endif
+  #if !defined(USE_FAST_LIGHT)
+	var_WorldLight = worldLight;
+  #endif
+#endif
+	
+#if defined(USE_LIGHT_VERTEX) && !defined(USE_FAST_LIGHT)
+	var_VertLight = u_VertColor.rgb * attr_Color.rgb;
+	var_Color.rgb = vec3(1.0);
+	var_Color.a = u_VertColor.a * attr_Color.a + u_BaseColor.a;
+#else
+	var_Color = u_VertColor * attr_Color + u_BaseColor;
+#endif
+
+#if defined(USE_LIGHT_VECTOR) && defined(USE_FAST_LIGHT)
+  #if defined(USE_INVSQRLIGHT)
+	float intensity = 1.0 / dot(worldLight, worldLight);
+  #else
+	float intensity = clamp((1.0 - dot(worldLight, worldLight) / (u_LightRadius * u_LightRadius)) * 1.07, 0.0, 1.0);
+  #endif
+	float NL = clamp(dot(normal, normalize(worldLight)), 0.0, 1.0);
+
+	var_Color.rgb *= u_DirectedLight * intensity * NL + u_AmbientLight;
+#endif
+}
Index: code/rend2/glsl/shadowmask_vp.glsl
===================================================================
--- code/rend2/glsl/shadowmask_vp.glsl	(revision 0)
+++ code/rend2/glsl/shadowmask_vp.glsl	(revision 334)
@@ -0,0 +1,18 @@
+attribute vec4 attr_Position;
+attribute vec4 attr_TexCoord0;
+
+uniform vec3   u_ViewForward;
+uniform vec3   u_ViewLeft;
+uniform vec3   u_ViewUp;
+uniform vec4   u_ViewInfo; // zfar / znear
+
+varying vec2   var_DepthTex;
+varying vec3   var_ViewDir;
+
+void main()
+{
+	gl_Position = attr_Position;
+	vec2 screenCoords = gl_Position.xy / gl_Position.w;
+	var_DepthTex = attr_TexCoord0.xy;
+	var_ViewDir = u_ViewForward + u_ViewLeft * -screenCoords.x + u_ViewUp * screenCoords.y;
+}
Index: code/rend2/glsl/fogpass_vp.glsl
===================================================================
--- code/rend2/glsl/fogpass_vp.glsl	(revision 0)
+++ code/rend2/glsl/fogpass_vp.glsl	(revision 334)
@@ -0,0 +1,117 @@
+attribute vec4  attr_Position;
+attribute vec3  attr_Normal;
+attribute vec4  attr_TexCoord0;
+
+//#if defined(USE_VERTEX_ANIMATION)
+attribute vec4  attr_Position2;
+attribute vec3  attr_Normal2;
+//#endif
+
+uniform vec4    u_FogDistance;
+uniform vec4    u_FogDepth;
+uniform float   u_FogEyeT;
+
+//#if defined(USE_DEFORM_VERTEXES)
+uniform int     u_DeformGen;
+uniform float   u_DeformParams[5];
+//#endif
+
+uniform float   u_Time;
+uniform mat4    u_ModelViewProjectionMatrix;
+
+//#if defined(USE_VERTEX_ANIMATION)
+uniform float   u_VertexLerp;
+//#endif
+
+varying float   var_Scale;
+
+#if defined(USE_DEFORM_VERTEXES)
+vec3 DeformPosition(const vec3 pos, const vec3 normal, const vec2 st)
+{
+	if (u_DeformGen == 0)
+	{
+		return pos;
+	}
+
+	float base =      u_DeformParams[0];
+	float amplitude = u_DeformParams[1];
+	float phase =     u_DeformParams[2];
+	float frequency = u_DeformParams[3];
+	float spread =    u_DeformParams[4];
+
+	if (u_DeformGen == DGEN_BULGE)
+	{
+		phase *= M_PI * 0.25 * st.x;
+	}
+	else // if (u_DeformGen <= DGEN_WAVE_INVERSE_SAWTOOTH)
+	{
+		phase += dot(pos.xyz, vec3(spread));
+	}
+
+	float value = phase + (u_Time * frequency);
+	float func;
+
+	if (u_DeformGen == DGEN_WAVE_SIN)
+	{
+		func = sin(value * 2.0 * M_PI);
+	}
+	else if (u_DeformGen == DGEN_WAVE_SQUARE)
+	{
+		func = sign(sin(value * 2.0 * M_PI));
+	}
+	else if (u_DeformGen == DGEN_WAVE_TRIANGLE)
+	{
+		func = abs(fract(value + 0.75) - 0.5) * 4.0 - 1.0;
+	}
+	else if (u_DeformGen == DGEN_WAVE_SAWTOOTH)
+	{
+		func = fract(value);
+	}
+	else if (u_DeformGen == DGEN_WAVE_INVERSE_SAWTOOTH)
+	{
+		func = (1.0 - fract(value));
+	}
+	else if (u_DeformGen == DGEN_BULGE)
+	{
+		func = sin(value);
+	}
+
+	return pos + normal * (base + func * amplitude);
+}
+#endif
+
+float CalcFog(vec4 position)
+{
+	float s = dot(position, u_FogDistance) * 8.0;
+	float t = dot(position, u_FogDepth);
+
+	if (t < 1.0)
+	{
+		t = step(step(0.0, -u_FogEyeT), t);
+	}
+	else
+	{
+		t /= t - min(u_FogEyeT, 0.0);
+	}
+	
+	return s * t;
+}
+
+void main()
+{
+#if defined(USE_VERTEX_ANIMATION)
+	vec4 position = mix(attr_Position, attr_Position2, u_VertexLerp);
+	vec3 normal = normalize(mix(attr_Normal, attr_Normal2, u_VertexLerp));
+#else
+	vec4 position = attr_Position;
+	vec3 normal = attr_Normal;
+#endif
+
+#if defined(USE_DEFORM_VERTEXES)
+	position.xyz = DeformPosition(position.xyz, normal, attr_TexCoord0.st);
+#endif
+
+	gl_Position = u_ModelViewProjectionMatrix * position;
+
+	var_Scale = CalcFog(position);
+}
Index: code/rend2/glsl/down4x_fp.glsl
===================================================================
--- code/rend2/glsl/down4x_fp.glsl	(revision 0)
+++ code/rend2/glsl/down4x_fp.glsl	(revision 334)
@@ -0,0 +1,34 @@
+uniform sampler2D u_TextureMap;
+
+uniform vec2      u_InvTexRes;
+varying vec2      var_TexCoords;
+
+void main()
+{
+	vec4 color;
+	vec2 tc;
+	
+	tc = var_TexCoords + u_InvTexRes * vec2(-1.5, -1.5);  color  = texture2D(u_TextureMap, tc);
+	tc = var_TexCoords + u_InvTexRes * vec2(-0.5, -1.5);  color += texture2D(u_TextureMap, tc);
+	tc = var_TexCoords + u_InvTexRes * vec2( 0.5, -1.5);  color += texture2D(u_TextureMap, tc);
+	tc = var_TexCoords + u_InvTexRes * vec2( 1.5, -1.5);  color += texture2D(u_TextureMap, tc);
+
+	tc = var_TexCoords + u_InvTexRes * vec2(-1.5, -0.5); color += texture2D(u_TextureMap, tc);
+	tc = var_TexCoords + u_InvTexRes * vec2(-0.5, -0.5); color += texture2D(u_TextureMap, tc);
+	tc = var_TexCoords + u_InvTexRes * vec2( 0.5, -0.5); color += texture2D(u_TextureMap, tc);
+	tc = var_TexCoords + u_InvTexRes * vec2( 1.5, -0.5); color += texture2D(u_TextureMap, tc);
+
+	tc = var_TexCoords + u_InvTexRes * vec2(-1.5,  0.5); color += texture2D(u_TextureMap, tc);
+	tc = var_TexCoords + u_InvTexRes * vec2(-0.5,  0.5); color += texture2D(u_TextureMap, tc);
+	tc = var_TexCoords + u_InvTexRes * vec2( 0.5,  0.5); color += texture2D(u_TextureMap, tc);
+	tc = var_TexCoords + u_InvTexRes * vec2( 1.5,  0.5); color += texture2D(u_TextureMap, tc);
+
+	tc = var_TexCoords + u_InvTexRes * vec2(-1.5,  1.5);  color += texture2D(u_TextureMap, tc);
+	tc = var_TexCoords + u_InvTexRes * vec2(-0.5,  1.5);  color += texture2D(u_TextureMap, tc);
+	tc = var_TexCoords + u_InvTexRes * vec2( 0.5,  1.5);  color += texture2D(u_TextureMap, tc);
+	tc = var_TexCoords + u_InvTexRes * vec2( 1.5,  1.5);  color += texture2D(u_TextureMap, tc);
+	
+	color *= 0.0625;
+	
+	gl_FragColor = color;
+}
Index: code/rend2/glsl/tonemap_vp.glsl
===================================================================
--- code/rend2/glsl/tonemap_vp.glsl	(revision 0)
+++ code/rend2/glsl/tonemap_vp.glsl	(revision 334)
@@ -0,0 +1,13 @@
+attribute vec4 attr_Position;
+attribute vec4 attr_TexCoord0;
+
+uniform mat4   u_ModelViewProjectionMatrix;
+
+varying vec2   var_TexCoords;
+
+
+void main()
+{
+	gl_Position = u_ModelViewProjectionMatrix * attr_Position;
+	var_TexCoords = attr_TexCoord0.st;
+}
Index: code/rend2/glsl/pshadow_vp.glsl
===================================================================
--- code/rend2/glsl/pshadow_vp.glsl	(revision 0)
+++ code/rend2/glsl/pshadow_vp.glsl	(revision 334)
@@ -0,0 +1,17 @@
+attribute vec4 attr_Position;
+attribute vec3 attr_Normal;
+
+uniform mat4   u_ModelViewProjectionMatrix;
+varying vec3   var_Position;
+varying vec3   var_Normal;
+
+
+void main()
+{
+	vec4 position  = attr_Position;
+
+	gl_Position = u_ModelViewProjectionMatrix * position;
+
+	var_Position  = position.xyz;
+	var_Normal    = attr_Normal;
+}
Index: code/rend2/glsl/ssao_vp.glsl
===================================================================
--- code/rend2/glsl/ssao_vp.glsl	(revision 0)
+++ code/rend2/glsl/ssao_vp.glsl	(revision 334)
@@ -0,0 +1,12 @@
+attribute vec4 attr_Position;
+attribute vec4 attr_TexCoord0;
+
+varying vec2   var_ScreenTex;
+
+void main()
+{
+	gl_Position = attr_Position;
+	var_ScreenTex = attr_TexCoord0.xy;
+	//vec2 screenCoords = gl_Position.xy / gl_Position.w;
+	//var_ScreenTex = screenCoords * 0.5 + 0.5;
+}
Index: code/rend2/glsl/bokeh_fp.glsl
===================================================================
--- code/rend2/glsl/bokeh_fp.glsl	(revision 0)
+++ code/rend2/glsl/bokeh_fp.glsl	(revision 334)
@@ -0,0 +1,70 @@
+uniform sampler2D u_TextureMap;
+
+uniform vec4      u_Color;
+
+uniform vec2      u_InvTexRes;
+varying vec2      var_TexCoords;
+
+void main()
+{
+	vec4 color;
+	vec2 tc;
+
+#if 0
+	float c[7] = float[7](1.0, 0.9659258263, 0.8660254038, 0.7071067812, 0.5, 0.2588190451, 0.0);
+
+	tc = var_TexCoords + u_InvTexRes * vec2(  c[0],  c[6]);  color =  texture2D(u_TextureMap, tc);
+	tc = var_TexCoords + u_InvTexRes * vec2(  c[1],  c[5]);  color += texture2D(u_TextureMap, tc);
+	tc = var_TexCoords + u_InvTexRes * vec2(  c[2],  c[4]);  color += texture2D(u_TextureMap, tc);
+	tc = var_TexCoords + u_InvTexRes * vec2(  c[3],  c[3]);  color += texture2D(u_TextureMap, tc);
+	tc = var_TexCoords + u_InvTexRes * vec2(  c[4],  c[2]);  color += texture2D(u_TextureMap, tc);
+	tc = var_TexCoords + u_InvTexRes * vec2(  c[5],  c[1]);  color += texture2D(u_TextureMap, tc);
+	tc = var_TexCoords + u_InvTexRes * vec2(  c[6],  c[0]);  color += texture2D(u_TextureMap, tc);
+
+	tc = var_TexCoords + u_InvTexRes * vec2(  c[1], -c[5]);  color += texture2D(u_TextureMap, tc);
+	tc = var_TexCoords + u_InvTexRes * vec2(  c[2], -c[4]);  color += texture2D(u_TextureMap, tc);
+	tc = var_TexCoords + u_InvTexRes * vec2(  c[3], -c[3]);  color += texture2D(u_TextureMap, tc);
+	tc = var_TexCoords + u_InvTexRes * vec2(  c[4], -c[2]);  color += texture2D(u_TextureMap, tc);
+	tc = var_TexCoords + u_InvTexRes * vec2(  c[5], -c[1]);  color += texture2D(u_TextureMap, tc);
+	tc = var_TexCoords + u_InvTexRes * vec2(  c[6], -c[0]);  color += texture2D(u_TextureMap, tc);
+
+	tc = var_TexCoords + u_InvTexRes * vec2( -c[0],  c[6]);  color += texture2D(u_TextureMap, tc);
+	tc = var_TexCoords + u_InvTexRes * vec2( -c[1],  c[5]);  color += texture2D(u_TextureMap, tc);
+	tc = var_TexCoords + u_InvTexRes * vec2( -c[2],  c[4]);  color += texture2D(u_TextureMap, tc);
+	tc = var_TexCoords + u_InvTexRes * vec2( -c[3],  c[3]);  color += texture2D(u_TextureMap, tc);
+	tc = var_TexCoords + u_InvTexRes * vec2( -c[4],  c[2]);  color += texture2D(u_TextureMap, tc);
+	tc = var_TexCoords + u_InvTexRes * vec2( -c[5],  c[1]);  color += texture2D(u_TextureMap, tc);
+
+	tc = var_TexCoords + u_InvTexRes * vec2( -c[1], -c[5]);  color += texture2D(u_TextureMap, tc);
+	tc = var_TexCoords + u_InvTexRes * vec2( -c[2], -c[4]);  color += texture2D(u_TextureMap, tc);
+	tc = var_TexCoords + u_InvTexRes * vec2( -c[3], -c[3]);  color += texture2D(u_TextureMap, tc);
+	tc = var_TexCoords + u_InvTexRes * vec2( -c[4], -c[2]);  color += texture2D(u_TextureMap, tc);
+	tc = var_TexCoords + u_InvTexRes * vec2( -c[5], -c[1]);  color += texture2D(u_TextureMap, tc);
+	
+	gl_FragColor = color * 0.04166667 * u_Color;
+#endif
+
+	float c[5] = float[5](1.0, 0.9238795325, 0.7071067812, 0.3826834324, 0.0);
+
+	tc = var_TexCoords + u_InvTexRes * vec2(  c[0],  c[4]);  color =  texture2D(u_TextureMap, tc);
+	tc = var_TexCoords + u_InvTexRes * vec2(  c[1],  c[3]);  color += texture2D(u_TextureMap, tc);
+	tc = var_TexCoords + u_InvTexRes * vec2(  c[2],  c[2]);  color += texture2D(u_TextureMap, tc);
+	tc = var_TexCoords + u_InvTexRes * vec2(  c[3],  c[1]);  color += texture2D(u_TextureMap, tc);
+	tc = var_TexCoords + u_InvTexRes * vec2(  c[4],  c[0]);  color += texture2D(u_TextureMap, tc);
+
+	tc = var_TexCoords + u_InvTexRes * vec2(  c[1], -c[3]);  color += texture2D(u_TextureMap, tc);
+	tc = var_TexCoords + u_InvTexRes * vec2(  c[2], -c[2]);  color += texture2D(u_TextureMap, tc);
+	tc = var_TexCoords + u_InvTexRes * vec2(  c[3], -c[1]);  color += texture2D(u_TextureMap, tc);
+	tc = var_TexCoords + u_InvTexRes * vec2(  c[4], -c[0]);  color += texture2D(u_TextureMap, tc);
+
+	tc = var_TexCoords + u_InvTexRes * vec2( -c[0],  c[4]);  color += texture2D(u_TextureMap, tc);
+	tc = var_TexCoords + u_InvTexRes * vec2( -c[1],  c[3]);  color += texture2D(u_TextureMap, tc);
+	tc = var_TexCoords + u_InvTexRes * vec2( -c[2],  c[2]);  color += texture2D(u_TextureMap, tc);
+	tc = var_TexCoords + u_InvTexRes * vec2( -c[3],  c[1]);  color += texture2D(u_TextureMap, tc);
+
+	tc = var_TexCoords + u_InvTexRes * vec2( -c[1], -c[3]);  color += texture2D(u_TextureMap, tc);
+	tc = var_TexCoords + u_InvTexRes * vec2( -c[2], -c[2]);  color += texture2D(u_TextureMap, tc);
+	tc = var_TexCoords + u_InvTexRes * vec2( -c[3], -c[1]);  color += texture2D(u_TextureMap, tc);
+	
+	gl_FragColor = color * 0.0625 * u_Color;
+}
Index: code/rend2/glsl/depthblur_fp.glsl
===================================================================
--- code/rend2/glsl/depthblur_fp.glsl	(revision 0)
+++ code/rend2/glsl/depthblur_fp.glsl	(revision 334)
@@ -0,0 +1,58 @@
+uniform sampler2D u_ScreenImageMap;
+uniform sampler2D u_ScreenDepthMap;
+
+uniform vec4   u_ViewInfo; // zfar / znear, zfar
+varying vec2   var_ScreenTex;
+
+//float gauss[5] = float[5](0.30, 0.23, 0.097, 0.024, 0.0033);
+float gauss[4] = float[4](0.40, 0.24, 0.054, 0.0044);
+//float gauss[3] = float[3](0.60, 0.19, 0.0066);
+#define GAUSS_SIZE 4
+
+float getLinearDepth(sampler2D depthMap, const vec2 tex, const float zFarDivZNear)
+{
+		float sampleZDivW = texture2D(depthMap, tex).r;
+		return 1.0 / mix(zFarDivZNear, 1.0, sampleZDivW);
+}
+
+vec4 depthGaussian1D(sampler2D imageMap, sampler2D depthMap, vec2 tex, float zFarDivZNear, float zFar)
+{
+	float scale = 1.0 / 256.0;
+
+#if defined(USE_HORIZONTAL_BLUR)
+    vec2 direction = vec2(1.0, 0.0) * scale;
+#else // if defined(USE_VERTICAL_BLUR)
+	vec2 direction = vec2(0.0, 1.0) * scale;
+#endif
+	
+	float depthCenter = zFar * getLinearDepth(depthMap, tex, zFarDivZNear);
+	vec2 centerSlope = vec2(dFdx(depthCenter), dFdy(depthCenter)) / vec2(dFdx(tex.x), dFdy(tex.y));
+		
+	vec4 result = texture2D(imageMap, tex) * gauss[0];
+	float total = gauss[0];
+
+	int i, j;
+	for (i = 0; i < 2; i++)
+	{
+		for (j = 1; j < GAUSS_SIZE; j++)
+		{
+			vec2 offset = direction * j;
+			float depthSample = zFar * getLinearDepth(depthMap, tex + offset, zFarDivZNear);
+			float depthExpected = depthCenter + dot(centerSlope, offset);
+			if(abs(depthSample - depthExpected) < 5.0)
+			{
+				result += texture2D(imageMap, tex + offset) * gauss[j];
+				total += gauss[j];
+			}
+		}
+		
+		direction = -direction;
+	}	
+		
+	return result / total;
+}
+
+void main()
+{		
+	gl_FragColor = depthGaussian1D(u_ScreenImageMap, u_ScreenDepthMap, var_ScreenTex, u_ViewInfo.x, u_ViewInfo.y);
+}
Index: code/rend2/glsl/calclevels4x_fp.glsl
===================================================================
--- code/rend2/glsl/calclevels4x_fp.glsl	(revision 0)
+++ code/rend2/glsl/calclevels4x_fp.glsl	(revision 334)
@@ -0,0 +1,55 @@
+uniform sampler2D u_TextureMap;
+
+uniform vec4      u_Color;
+
+uniform vec2      u_InvTexRes;
+varying vec2      var_TexCoords;
+
+const vec3  LUMINANCE_VECTOR =   vec3(0.2125, 0.7154, 0.0721); //vec3(0.299, 0.587, 0.114);
+
+vec3 GetValues(vec2 offset, vec3 current)
+{
+	vec3 minAvgMax;
+	vec2 tc = var_TexCoords + u_InvTexRes * offset; minAvgMax = texture2D(u_TextureMap, tc).rgb;
+
+#ifdef FIRST_PASS
+	float lumi = max(dot(LUMINANCE_VECTOR, minAvgMax), 0.000001);
+	float loglumi = clamp(log2(lumi), -10.0, 10.0);
+	minAvgMax = vec3(loglumi * 0.05 + 0.5);
+#endif
+
+	return vec3(min(current.x, minAvgMax.x), current.y + minAvgMax.y, max(current.z, minAvgMax.z));
+}
+
+void main()
+{
+	vec3 current = vec3(1.0, 0.0, 0.0);
+
+#ifdef FIRST_PASS
+	current = GetValues(vec2( 0.0,  0.0), current);
+#else
+	current = GetValues(vec2(-1.5, -1.5), current);
+	current = GetValues(vec2(-0.5, -1.5), current);
+	current = GetValues(vec2( 0.5, -1.5), current);
+	current = GetValues(vec2( 1.5, -1.5), current);
+	
+	current = GetValues(vec2(-1.5, -0.5), current);
+	current = GetValues(vec2(-0.5, -0.5), current);
+	current = GetValues(vec2( 0.5, -0.5), current);
+	current = GetValues(vec2( 1.5, -0.5), current);
+	
+	current = GetValues(vec2(-1.5,  0.5), current);
+	current = GetValues(vec2(-0.5,  0.5), current);
+	current = GetValues(vec2( 0.5,  0.5), current);
+	current = GetValues(vec2( 1.5,  0.5), current);
+
+	current = GetValues(vec2(-1.5,  1.5), current);
+	current = GetValues(vec2(-0.5,  1.5), current);
+	current = GetValues(vec2( 0.5,  1.5), current);
+	current = GetValues(vec2( 1.5,  1.5), current);
+
+	current.y *= 0.0625;
+#endif
+
+	gl_FragColor = vec4(current, 1.0f);
+}
Index: code/rend2/tr_backend.c
===================================================================
--- code/rend2/tr_backend.c	(revision 329)
+++ code/rend2/tr_backend.c	(revision 334)
@@ -1529,22 +1529,38 @@
 		{
 			vec4_t quadVerts[4];
 			vec2_t texCoords[4];
+			vec4_t box;
 
 			FBO_Bind(tr.screenShadowFbo);
 
-			qglViewport(0, 0, tr.screenShadowFbo->width, tr.screenShadowFbo->height);
-			qglScissor(0, 0, tr.screenShadowFbo->width, tr.screenShadowFbo->height);
+			box[0] = (backEnd.refdef.x     ) * tr.screenShadowFbo->width  / (float)glConfig.vidWidth;
+			box[1] = (backEnd.refdef.y     ) * tr.screenShadowFbo->height / (float)glConfig.vidHeight;
+			box[2] = (backEnd.refdef.width ) * tr.screenShadowFbo->width  / (float)glConfig.vidWidth;
+			box[3] = (backEnd.refdef.height) * tr.screenShadowFbo->height / (float)glConfig.vidHeight;
 
-			VectorSet4(quadVerts[0], -1,  1, 0, 1);
-			VectorSet4(quadVerts[1],  1,  1, 0, 1);
-			VectorSet4(quadVerts[2],  1, -1, 0, 1);
-			VectorSet4(quadVerts[3], -1, -1, 0, 1);
+			qglViewport(box[0], box[1], box[2], box[3]);
+			qglScissor(box[0], box[1], box[2], box[3]);
 
-			texCoords[0][0] = 0; texCoords[0][1] = 1;
-			texCoords[1][0] = 1; texCoords[1][1] = 1;
-			texCoords[2][0] = 1; texCoords[2][1] = 0;
-			texCoords[3][0] = 0; texCoords[3][1] = 0;
+			box[0] = (backEnd.refdef.x                        ) / (float)glConfig.vidWidth;
+			box[1] = (backEnd.refdef.y                        ) / (float)glConfig.vidHeight;
+			box[2] = (backEnd.refdef.x + backEnd.refdef.width ) / (float)glConfig.vidWidth;
+			box[3] = (backEnd.refdef.y + backEnd.refdef.height) / (float)glConfig.vidHeight;
 
+			texCoords[0][0] = box[0]; texCoords[0][1] = box[3];
+			texCoords[1][0] = box[2]; texCoords[1][1] = box[3];
+			texCoords[2][0] = box[2]; texCoords[2][1] = box[1];
+			texCoords[3][0] = box[0]; texCoords[3][1] = box[1];
+
+			box[0] = -1.0f;
+			box[1] = -1.0f;
+			box[2] =  1.0f;
+			box[3] =  1.0f;
+
+			VectorSet4(quadVerts[0], box[0], box[3], 0, 1);
+			VectorSet4(quadVerts[1], box[2], box[3], 0, 1);
+			VectorSet4(quadVerts[2], box[2], box[1], 0, 1);
+			VectorSet4(quadVerts[3], box[0], box[1], 0, 1);
+
 			GL_State( GLS_DEPTHTEST_DISABLE );
 
 			GLSL_BindProgram(&tr.shadowmaskShader);
Index: code/cgame/cg_playerstate.c
===================================================================
--- code/cgame/cg_playerstate.c	(revision 329)
+++ code/cgame/cg_playerstate.c	(revision 334)
@@ -311,7 +311,7 @@
 ==================
 */
 void CG_CheckLocalSounds( playerState_t *ps, playerState_t *ops ) {
-	int			highScore, reward;
+	int			reward;
 #ifdef MISSIONPACK
 	int			health, armor;
 #endif
@@ -440,30 +440,62 @@
 		}
 	}
 
-	// lead changes
-	if (!reward) {
+	if (reward) {
+		// ignore lead changes this frame because a reward sound was played.
+		cg.bestLeadChange = LEAD_IGNORE;
+	} else {
 		//
 		if ( !cg.warmup ) {
 			// never play lead changes during warmup
 			if ( ps->persistant[PERS_RANK] != ops->persistant[PERS_RANK] ) {
 				if ( cgs.gametype < GT_TEAM) {
-					if (  ps->persistant[PERS_RANK] == 0 ) {
-						CG_AddBufferedSound(cgs.media.takenLeadSound);
-					} else if (cg.snap->numPSs <= 1) {
-						// ZTM: Don't play tied or lost lead when there are multiple local clients
-						//      multiple sounds play and it's annoying.
+					leadChange_t leadChange = LEAD_NONE;
 
-						if ( ps->persistant[PERS_RANK] == RANK_TIED_FLAG ) {
-							CG_AddBufferedSound(cgs.media.tiedLeadSound);
-						} else if ( ( ops->persistant[PERS_RANK] & ~RANK_TIED_FLAG ) == 0 ) {
-							CG_AddBufferedSound(cgs.media.lostLeadSound);
-						}
+					if ( ps->persistant[PERS_RANK] == 0 ) {
+						leadChange = LEAD_TAKEN;
+					} else if ( ps->persistant[PERS_RANK] == RANK_TIED_FLAG ) {
+						leadChange = LEAD_TIED;
+					} else if ( ( ops->persistant[PERS_RANK] & ~RANK_TIED_FLAG ) == 0 ) {
+						leadChange = LEAD_LOST;
 					}
+
+					if ( leadChange > cg.bestLeadChange ) {
+						cg.bestLeadChange = leadChange;
+					}
 				}
 			}
 		}
 	}
+}
 
+/*
+===============
+CG_CheckGameSounds
+
+Sounds that use to be played in CG_CheckLocalSounds, but with splitscreen we only want these done once.
+===============
+*/
+void CG_CheckGameSounds( void ) {
+	int		highScore;
+
+	// lead changes
+	switch ( cg.bestLeadChange ) {
+		case LEAD_TAKEN:
+			CG_AddBufferedSound(cgs.media.takenLeadSound);
+			break;
+		case LEAD_TIED:
+			CG_AddBufferedSound(cgs.media.tiedLeadSound);
+			break;
+		case LEAD_LOST:
+			CG_AddBufferedSound(cgs.media.lostLeadSound);
+			break;
+		default:
+			break;
+	}
+
+	// reset lead change
+	cg.bestLeadChange = LEAD_NONE;
+
 	// timelimit warnings
 	if ( cgs.timelimit > 0 ) {
 		int		msec;
Index: code/cgame/cg_local.h
===================================================================
--- code/cgame/cg_local.h	(revision 329)
+++ code/cgame/cg_local.h	(revision 334)
@@ -441,6 +441,17 @@
 } skulltrail_t;
 
 
+typedef enum {
+	LEAD_NONE,
+
+	LEAD_LOST,
+	LEAD_TIED,
+	LEAD_TAKEN,
+
+	LEAD_IGNORE // a client played a reward sound, so no lead change sfx this frame.
+} leadChange_t;
+
+
 #define MAX_REWARDSTACK		10
 #define MAX_SOUNDBUFFER		20
 
@@ -588,6 +599,7 @@
 
 	int			physicsTime;	// either cg.snap->time or cg.nextSnap->time
 
+	leadChange_t bestLeadChange;
 	int			timelimitWarnings;	// 5 min, 1 min, overtime
 	int			fraglimitWarnings;
 
@@ -1229,6 +1241,7 @@
 extern	vmCvar_t		cg_oldPlasma;
 extern	vmCvar_t		cg_trueLightning;
 extern	vmCvar_t		cg_atmosphericEffects;
+extern	vmCvar_t		cg_teamDmLeadAnnouncements;
 #ifdef MISSIONPACK
 extern	vmCvar_t		cg_redTeamName;
 extern	vmCvar_t		cg_blueTeamName;
@@ -1590,6 +1603,7 @@
 void CG_Respawn( int clientNum );
 void CG_TransitionPlayerState( playerState_t *ps, playerState_t *ops );
 void CG_CheckChangedPredictableEvents( playerState_t *ps );
+void CG_CheckGameSounds( void );
 
 
 //
Index: code/cgame/cg_view.c
===================================================================
--- code/cgame/cg_view.c	(revision 329)
+++ code/cgame/cg_view.c	(revision 334)
@@ -1053,6 +1053,9 @@
 		renderClientViewport[0] = qtrue;
 	}
 
+	// play lead change annoucement and time/frag limit warnings
+	CG_CheckGameSounds();
+
 	for (i = 0, cg.viewport = -1; i < CG_MaxSplitView(); i++) {
 		if (!renderClientViewport[i]) {
 			continue;
Index: code/cgame/cg_event.c
===================================================================
--- code/cgame/cg_event.c	(revision 329)
+++ code/cgame/cg_event.c	(revision 334)
@@ -1214,13 +1214,19 @@
 					CG_AddBufferedSound(cgs.media.blueScoredSound);
 					break;
 				case GTS_REDTEAM_TOOK_LEAD:
-					CG_AddBufferedSound(cgs.media.redLeadsSound);
+					if ( cgs.gametype != GT_TEAM || cg_teamDmLeadAnnouncements.integer ) {
+						CG_AddBufferedSound(cgs.media.redLeadsSound);
+					}
 					break;
 				case GTS_BLUETEAM_TOOK_LEAD:
-					CG_AddBufferedSound(cgs.media.blueLeadsSound);
+					if ( cgs.gametype != GT_TEAM || cg_teamDmLeadAnnouncements.integer ) {
+						CG_AddBufferedSound(cgs.media.blueLeadsSound);
+					}
 					break;
 				case GTS_TEAMS_ARE_TIED:
-					CG_AddBufferedSound( cgs.media.teamsTiedSound );
+					if ( cgs.gametype != GT_TEAM || cg_teamDmLeadAnnouncements.integer ) {
+						CG_AddBufferedSound( cgs.media.teamsTiedSound );
+					}
 					break;
 #ifdef MISSIONPACK
 				case GTS_KAMIKAZE:
Index: code/cgame/cg_main.c
===================================================================
--- code/cgame/cg_main.c	(revision 329)
+++ code/cgame/cg_main.c	(revision 334)
@@ -201,6 +201,7 @@
 vmCvar_t	cg_oldPlasma;
 vmCvar_t	cg_trueLightning;
 vmCvar_t	cg_atmosphericEffects;
+vmCvar_t	cg_teamDmLeadAnnouncements;
 
 #ifdef MISSIONPACK
 vmCvar_t 	cg_redTeamName;
@@ -353,7 +354,8 @@
 	{ &cg_oldRocket, "cg_oldRocket", "1", CVAR_ARCHIVE},
 	{ &cg_oldPlasma, "cg_oldPlasma", "1", CVAR_ARCHIVE},
 	{ &cg_trueLightning, "cg_trueLightning", "0.0", CVAR_ARCHIVE},
-	{ &cg_atmosphericEffects, "cg_atmosphericEffects", "1", CVAR_ARCHIVE }
+	{ &cg_atmosphericEffects, "cg_atmosphericEffects", "1", CVAR_ARCHIVE },
+	{ &cg_teamDmLeadAnnouncements, "cg_teamDmLeadAnnouncements", "1", CVAR_ARCHIVE }
 //	{ &cg_pmove_fixed, "cg_pmove_fixed", "0", CVAR_USERINFO | CVAR_ARCHIVE }
 };
 
Index: Makefile
===================================================================
--- Makefile	(revision 329)
+++ Makefile	(revision 334)
@@ -5,7 +5,7 @@
 #
 
 # ioquake3 svn version that this is based on
-IOQ3_REVISION = 2369
+IOQ3_REVISION = 2372
 
 COMPILE_PLATFORM=$(shell uname|sed -e s/_.*//|tr '[:upper:]' '[:lower:]'|sed -e 's/\//_/g')
 
@@ -1063,6 +1063,14 @@
 $(Q)$(CC) $(SHLIBCFLAGS) $(CFLAGS) $(CLIENT_CFLAGS) $(OPTIMIZE) -o $@ -c $<
 endef
 
+define DO_REF_STR
+$(echo_cmd) "REF_STR $<"
+$(Q)rm -f $@
+$(Q)echo "const char *fallbackShader_$(notdir $(basename $<)) =" >> $@
+$(Q)cat $< | sed 's/\\/\\\\/;s/\t/\\t/;s/\"/\\"/;s/$$/\\n"/;s/^/"/' >> $@
+$(Q)echo ";" >> $@
+endef
+
 define DO_SMP_CC
 $(echo_cmd) "SMP_CC $<"
 $(Q)$(CC) $(SHLIBCFLAGS) $(CFLAGS) $(CLIENT_CFLAGS) $(OPTIMIZE) -DSMP -o $@ -c $<
@@ -1228,6 +1236,7 @@
 	@if [ ! -d $(B)/client/vorbis ];then $(MKDIR) $(B)/client/vorbis;fi
 	@if [ ! -d $(B)/renderer ];then $(MKDIR) $(B)/renderer;fi
 	@if [ ! -d $(B)/rend2 ];then $(MKDIR) $(B)/rend2;fi
+	@if [ ! -d $(B)/rend2/glsl ];then $(MKDIR) $(B)/rend2/glsl;fi
 	@if [ ! -d $(B)/renderersmp ];then $(MKDIR) $(B)/renderersmp;fi
 	@if [ ! -d $(B)/ded ];then $(MKDIR) $(B)/ded;fi
 	@if [ ! -d $(B)/$(BASEGAME) ];then $(MKDIR) $(B)/$(BASEGAME);fi
@@ -1603,6 +1612,36 @@
   $(B)/rend2/tr_world.o \
   \
   $(B)/renderer/sdl_gamma.o
+  
+Q3R2STRINGOBJ = \
+  $(B)/rend2/glsl/bokeh_fp.o \
+  $(B)/rend2/glsl/bokeh_vp.o \
+  $(B)/rend2/glsl/calclevels4x_fp.o \
+  $(B)/rend2/glsl/calclevels4x_vp.o \
+  $(B)/rend2/glsl/depthblur_fp.o \
+  $(B)/rend2/glsl/depthblur_vp.o \
+  $(B)/rend2/glsl/dlight_fp.o \
+  $(B)/rend2/glsl/dlight_vp.o \
+  $(B)/rend2/glsl/down4x_fp.o \
+  $(B)/rend2/glsl/down4x_vp.o \
+  $(B)/rend2/glsl/fogpass_fp.o \
+  $(B)/rend2/glsl/fogpass_vp.o \
+  $(B)/rend2/glsl/generic_fp.o \
+  $(B)/rend2/glsl/generic_vp.o \
+  $(B)/rend2/glsl/lightall_fp.o \
+  $(B)/rend2/glsl/lightall_vp.o \
+  $(B)/rend2/glsl/pshadow_fp.o \
+  $(B)/rend2/glsl/pshadow_vp.o \
+  $(B)/rend2/glsl/shadowfill_fp.o \
+  $(B)/rend2/glsl/shadowfill_vp.o \
+  $(B)/rend2/glsl/shadowmask_fp.o \
+  $(B)/rend2/glsl/shadowmask_vp.o \
+  $(B)/rend2/glsl/ssao_fp.o \
+  $(B)/rend2/glsl/ssao_vp.o \
+  $(B)/rend2/glsl/texturecolor_fp.o \
+  $(B)/rend2/glsl/texturecolor_vp.o \
+  $(B)/rend2/glsl/tonemap_fp.o \
+  $(B)/rend2/glsl/tonemap_vp.o
 
 Q3ROBJ = \
   $(B)/renderer/tr_animation.o \
@@ -1909,14 +1948,14 @@
 	$(Q)$(CC) $(CFLAGS) $(SHLIBLDFLAGS) -o $@ $(Q3ROBJ) $(Q3RPOBJ_SMP) $(JPGOBJ) $(FTOBJ) \
 		$(THREAD_LIBS) $(LIBSDLMAIN) $(RENDERER_LIBS) $(LIBS)
 
-$(B)/renderer_rend2_$(SHLIBNAME): $(Q3R2OBJ) $(Q3RPOBJ_UP) $(JPGOBJ) $(FTOBJ)
+$(B)/renderer_rend2_$(SHLIBNAME): $(Q3R2OBJ) $(Q3R2STRINGOBJ) $(Q3RPOBJ_UP) $(JPGOBJ) $(FTOBJ)
 	$(echo_cmd) "LD $@"
-	$(Q)$(CC) $(CFLAGS) $(SHLIBLDFLAGS) -o $@ $(Q3R2OBJ) $(Q3RPOBJ_UP) $(JPGOBJ) $(FTOBJ) \
+	$(Q)$(CC) $(CFLAGS) $(SHLIBLDFLAGS) -o $@ $(Q3R2OBJ) $(Q3R2STRINGOBJ) $(Q3RPOBJ_UP) $(JPGOBJ) $(FTOBJ) \
 		$(THREAD_LIBS) $(LIBSDLMAIN) $(RENDERER_LIBS) $(LIBS)
 
-$(B)/renderer_rend2_smp_$(SHLIBNAME): $(Q3R2OBJ) $(Q3RPOBJ_SMP) $(JPGOBJ) $(FTOBJ)
+$(B)/renderer_rend2_smp_$(SHLIBNAME): $(Q3R2OBJ) $(Q3R2STRINGOBJ) $(Q3RPOBJ_SMP) $(JPGOBJ) $(FTOBJ)
 	$(echo_cmd) "LD $@"
-	$(Q)$(CC) $(CFLAGS) $(SHLIBLDFLAGS) -o $@ $(Q3R2OBJ) $(Q3RPOBJ_SMP) $(JPGOBJ) $(FTOBJ) \
+	$(Q)$(CC) $(CFLAGS) $(SHLIBLDFLAGS) -o $@ $(Q3R2OBJ) $(Q3R2STRINGOBJ) $(Q3RPOBJ_SMP) $(JPGOBJ) $(FTOBJ) \
 		$(THREAD_LIBS) $(LIBSDLMAIN) $(RENDERER_LIBS) $(LIBS)
 
 else
@@ -1932,16 +1971,16 @@
 		-o $@ $(Q3OBJ) $(Q3ROBJ) $(Q3RPOBJ_SMP) $(JPGOBJ) $(FTOBJ) \
 		$(THREAD_LIBS) $(LIBSDLMAIN) $(CLIENT_LIBS) $(RENDERER_LIBS) $(LIBS)
 
-$(B)/$(CLIENTBIN)_rend2$(FULLBINEXT): $(Q3OBJ) $(Q3R2OBJ) $(Q3RPOBJ_UP) $(JPGOBJ) $(FTOBJ) $(LIBSDLMAIN)
+$(B)/$(CLIENTBIN)_rend2$(FULLBINEXT): $(Q3OBJ) $(Q3R2OBJ) $(Q3R2STRINGOBJ) $(Q3RPOBJ_UP) $(JPGOBJ) $(FTOBJ) $(LIBSDLMAIN)
 	$(echo_cmd) "LD $@"
 	$(Q)$(CC) $(CLIENT_CFLAGS) $(CFLAGS) $(CLIENT_LDFLAGS) $(LDFLAGS) \
-		-o $@ $(Q3OBJ) $(Q3R2OBJ) $(Q3RPOBJ_UP) $(JPGOBJ) $(FTOBJ) \
+		-o $@ $(Q3OBJ) $(Q3R2OBJ) $(Q3R2STRINGOBJ) $(Q3RPOBJ_UP) $(JPGOBJ) $(FTOBJ) \
 		$(LIBSDLMAIN) $(CLIENT_LIBS) $(RENDERER_LIBS) $(LIBS)
 
-$(B)/$(CLIENTBIN)_rend2-smp$(FULLBINEXT): $(Q3OBJ) $(Q3R2OBJ) $(Q3RPOBJ_SMP) $(JPGOBJ) $(FTOBJ) $(LIBSDLMAIN)
+$(B)/$(CLIENTBIN)_rend2-smp$(FULLBINEXT): $(Q3OBJ) $(Q3R2OBJ) $(Q3R2STRINGOBJ) $(Q3RPOBJ_SMP) $(JPGOBJ) $(FTOBJ) $(LIBSDLMAIN)
 	$(echo_cmd) "LD $@"
 	$(Q)$(CC) $(CLIENT_CFLAGS) $(CFLAGS) $(CLIENT_LDFLAGS) $(LDFLAGS) $(THREAD_LDFLAGS) \
-		-o $@ $(Q3OBJ) $(Q3R2OBJ) $(Q3RPOBJ_SMP) $(JPGOBJ) $(FTOBJ) \
+		-o $@ $(Q3OBJ) $(Q3R2OBJ) $(Q3R2STRINGOBJ) $(Q3RPOBJ_SMP) $(JPGOBJ) $(FTOBJ) \
 		$(THREAD_LIBS) $(LIBSDLMAIN) $(CLIENT_LIBS) $(RENDERER_LIBS) $(LIBS)
 endif
 
@@ -2490,7 +2529,13 @@
 
 $(B)/renderer/%.o: $(CMDIR)/%.c
 	$(DO_REF_CC)
-	
+
+$(B)/rend2/glsl/%.c: $(R2DIR)/glsl/%.glsl
+	$(DO_REF_STR)
+
+$(B)/rend2/glsl/%.o: $(B)/rend2/glsl/%.c
+	$(DO_REF_CC)
+
 $(B)/rend2/%.o: $(R2DIR)/%.c
 	$(DO_REF_CC)
 
@@ -2690,6 +2735,7 @@
   $(MPGOBJ) $(Q3GOBJ) $(Q3CGOBJ) $(MPCGOBJ) $(Q3UIOBJ) $(MPUIOBJ) \
   $(MPGVMOBJ) $(Q3GVMOBJ) $(Q3CGVMOBJ) $(MPCGVMOBJ) $(Q3UIVMOBJ) $(MPUIVMOBJ)
 TOOLSOBJ = $(LBURGOBJ) $(Q3CPPOBJ) $(Q3RCCOBJ) $(Q3LCCOBJ) $(Q3ASMOBJ)
+STRINGOBJ = $(Q3R2STRINGOBJ)
 
 
 copyfiles: release
@@ -2763,6 +2809,7 @@
 	@echo "CLEAN $(B)"
 	@rm -f $(OBJ)
 	@rm -f $(OBJ_D_FILES)
+	@rm -f $(STRINGOBJ)
 	@rm -f $(TARGETS)
 
 toolsclean: toolsclean-debug toolsclean-release
